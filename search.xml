<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[今天，我向开源世界迈出了第一步]]></title>
    <url>%2F2020%2F03%2F13%2F313%2F</url>
    <content type="text"><![CDATA[今天，我在halo中提交了人生中的第一个pull request， 优化了一下附件上传的逻辑。 最主要的，是我成功迈出了走向开源的第一步。事情起因疫情在家， 时间充足;再不收假， 毕设踌躇;静极思动， 久坐念学;项目先冲， 秋招一绝;写个网盘， 两眼抹黑;不会咋办？ 翻遍Git;突遇哈喽， 研究一手;宝刀屠龙， 思路已有;操作一波， 回看哈喽;部分冗余， 可以动手;轮讯不易， Hash优许;说干就干， 编码走起;改动的模块在 halo 中，附件图片模块有多种存储方式， 如SMMS、阿里OSS、腾讯COS等。 一开始 halo 是将其存储在一个LinkList中的，用策略模式（或者是适配器？）在 FileHandler中提供统一的方法，然后根据参数去调用不同的实现。 这样就导致每次上传附件都需要遍历这个LinkList。 自然，此处比较容易想到可以用 Map 去存放数据，然后能够在 $O(1)$ 的时间内取得所需要的资源。 但是 Map 系列的容器需要取得所用的 Key。 这里由于上述的存储方式都实现自统一接口，所以我在接口中新加了一个方法getType去返回具体实现所支持的存储类型，然后小改了一下逻辑，使得逻辑更清楚了一些。这里贴一下我改动影响比较大的部分改动前（一）1234567891011121314151617181920212223242526272829@NonNullpublic UploadResult upload(@NonNull MultipartFile file, @NonNull AttachmentType attachmentType) &#123; public UploadResult upload(@NonNull MultipartFile file, @NonNull AttachmentType attachmentType) &#123; Assert.notNull(attachmentType, "Attachment type must not be null"); return upload(file, attachmentType.name()); &#125; &#125;/** * Uploads files. * * @param file multipart file must not be null * @param type store type * @return upload result * @throws FileOperationException throws when fail to delete attachment or no available file handler to upload it */ @NonNull public UploadResult upload(@NonNull MultipartFile file, @Nullable String type) &#123; Assert.notNull(file, "Multipart file must not be null"); for (FileHandler fileHandler : fileHandlers) &#123; if (fileHandler.supportType(type)) &#123; return fileHandler.upload(file); &#125; &#125; throw new FileOperationException("No available file handlers to upload the file").setErrorData(type); &#125;改动后(一)1234@NonNullpublic UploadResult upload(@NonNull MultipartFile file, @NonNull AttachmentType attachmentType) &#123; return getSupportedType(attachmentType).upload(file);&#125;改动前123456789101112131415161718192021222324public void delete(@NonNull Attachment attachment) &#123; Assert.notNull(attachment, "Attachment must not be null" getSupportedType(attachment.getType()) delete(attachment.getType().name(), attachment.getFileKey()); &#125; /** * Deletes attachment. * * @param key file key * @throws FileOperationException throws when fail to delete attachment or no available file handler to delete it */ public void delete(@Nullable String type, @NonNull String key) &#123; for (FileHandler fileHandler : fileHandlers) &#123; if (fileHandler.supportType(type)) &#123; // Delete the file fileHandler.delete(key); return; &#125; &#125; throw new FileOperationException("No available file handlers to delete the file").setErrorData(type); &#125;改动后（二）1234public void delete(@NonNull Attachment attachment) &#123; Assert.notNull(attachment, "Attachment must not be null"); getSupportedType(attachment.getType()).delete(attachment.getFileKey());&#125;新增方法1234567private FileHandler getSupportedType(AttachmentType type) &#123; FileHandler handler = fileHandlers.getOrDefault(type, fileHandlers.get(AttachmentType.LOCAL)); if (handler == null) &#123; throw new FileOperationException("No available file handlers to operate the file").setErrorData(type); &#125; return handler;&#125;可以看到，改动之后确实省下了不少代码量。 而且整个时间复杂度也从$O(n)$降低到了$O(1)$.小记在此之前，我一直很喜欢GitHub， 也想过贡献一些自己的代码。 但是限于能力和精力， 只是提交了几个 issue, 一是用到的开源产品已经比较完善了，二是没有深入研究过某些模块的源码。其实这次我也没有专门去研究 halo 的全部源码，只是因为我自己毕设(打算写个可高度自定义的个人网盘)的原因就去参考了一下 halo 的附件模块和缓存模块的实现， 后来自己在仿写的时候发现这一部分能够优化，才有了提交 pull request 的想法。 我个人其实对开源世界一直怀有憧憬， 从我大二课设使用的 durid 开始， 一直到后面了解到 Lombok、 fFastjson 、 Spring、 MyBatis 这些优秀的开源产品。 就像小时候有个江湖梦一样，现在的我也怀有一个开源的梦。此次有机会能够为 halo 贡献小小的几十行代码我真的特别开心。愿大家各出己力， 为开源世界添砖加瓦～]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coding到底是怎么回事？]]></title>
    <url>%2F2020%2F01%2F31%2F131%2F</url>
    <content type="text"><![CDATA[之前从wordpress迁移到hexo的时候，用了很多家静态页面托管方案。 一开始是用的GitHub Pages，后来一是因为百度不收录这一部分，二是国内在不修改Host的情况下访问GitHub相关服务确实有点卡… 所以后来GitHub就只用作备份了。 然后又试了试码云，体验也不是很好。一是页面广告太多不喜欢，还有个也是因为SEO问题。一直到现在用的coding(貌似早就被腾讯开发者平台合并了)。能被百度收购，而且仓库界面还算比较习惯(虽然根本不会进几次网页,但是顺心最重要呀～)，就一直沿用了下来。直到前一阵子…为什么最后还是选择将静态博客部署到自己的服务器上呢，主要是因为前一阵子coding的更新。coding在2020年1月份的时候做了一个比较大的架构改动，剔除了个人版帐号，所有个人帐号将会被升级成团体帐号。同时由于某些原因，团体帐号需要进行实名认证之后才能使用他们家的静态页面托管服务。本来一开始我都没觉得什么，老老实实做实名认证去了。毕竟咱也是良好公民是吧，还是要积极响应号召的。可秀到我头皮发麻的是：他家的实名认证手机号是不能更改的？我不清楚是不是前端的锅还是测试的锅还是我哪里操作不对，一个输入框居然是被锁死了的？这是什么操作？点击获取验证码提示用户手机号不能为空，那倒是让我输入手机号试试啊喂！尝试看了一下，发现点击发送验证码的时候向/api/team/bestsort-01/verification/send-phone-code这个地址post了一条请求，参数只有一个phone，当然因为填不了所以phone是空的。我用postman手动尝试了一下post:/api/team/bestsort-01/verification/send-phone-code?phone=xxxx,返回json如下1234&#123; "code": 0, "data": true&#125;也就是说接口还是正常的哈。接着我手机收到了验证码，填上去点提交验证试试，提示有误，查看发现赤脚了一个check-phone-code的请求，带上了phone和code两个参数，依旧用postman尝试一下https://bestsort-01.coding.net/api/team/bestsort-01/verification/check-phone-code?phone=xxxxx&amp;code=357938，返回结果还是跟上面的一样，然而帐号依旧没有认证。我甚至想直接去修改input框的value，但是不清楚是用的什么加密只好作罢～之后去官方社区提问也没人回复，唉。想了想，还是靠自己吧，就设了一下GitHub提供的webhook，然后把博客部署到服务器上了，原域名也解析到了服务器。太难了]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式实现---单例模式]]></title>
    <url>%2F2020%2F01%2F28%2F128%2F</url>
    <content type="text"><![CDATA[单例模式可能是最最经常使用的模式之一了（另一个竞争对手是工厂模式）。 可能你并不知道单例模式是什么，但是无论是工作还是面试，你一定会听到这个词汇。概念单例模式是设计模式的一种，属于创建型模式。单例模式是指在一次程序的运行中，相同类的实例有且最多只有一个。这样看来，用static修饰的方法好像满足条件(因为每次都是调用的同一个类而不是用new关键字创建出来的类)。sorry，并不是这样的，单例模式由他自己的 style:单例模式只能有一个实例单例类必须自己创建自己的唯一实例（我生我自己~）单例类必须给所有其他对象提供这一实例（换句话说就是类似于写个get方法这种的~）要满足上面的要求，我们可以设想下需要进行以下操作：因为只有一个实例，所以我们需要将修饰词为public的构造方法改为private（只需州官放火，不许百姓点灯）自己创建自己，所以我们可以用static修饰一个对象并且初始化能给其他对象提供实例，也就是说我们需要写一个public修饰的get方法，方法返回实例内存的那个唯一对象实现单例模式的实现依照构建方式分类都能分成两个大类：懒汉式和饿汉式；其中因为需要考虑线程安全（因为单例模式只有一个实例，所以在多线程环境下创建的时候可能会出现重复创建的情况）的原因，实现细节又有些许改变懒汉式懒汉式是指只在第一次使用到这个类的时候构建实例，如果不用则不构建。相比于下面的饿汉式，更加节省内存空间。普通实现1234567891011121314151617181920212223242526/** * @author bestsort */public class Singleton &#123; private int a; private static Singleton instance; /** * 改为private,禁止从外部调用构造方法创建新的实例 */ private Singleton()&#123;&#125; /** * get方法用于获取唯一实例 */ public static Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125;这种实现非常简单，但是会出现线程安全问题。如果是多个线程同时访问，此时由于未加锁，会 new 出来多个Singleton对象.加锁实现1234567891011121314151617181920/** * @author bestsort */public class Singleton &#123; private int a; private static Singleton instance; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; if (instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125;相较于上面的不加锁，虽然在get方法上加上synchronized关键字能够保证其线程安全，但是锁粒度太大了，会影响效率，毕竟大多数情况下并不需要同步。饿汉式饱汉式是指不管用没有用到这个类，都会在类装载的时候构建一个唯一实例出来。123456789101112131415161718/** * @author bestsort */public class Singleton &#123; private int a; /** * 默认创建一个实例 */ private static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123;return instance;&#125; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125;可以通过Singleton.getInstance()形式获取 Singleton 实例。这是最简单的一种实现，但是容易产生垃圾对象（因为new出来的instance实例不一定会用到）。而且因为是基于static关键字，所以初始化的时候不会产生线程安全问题。其他实现双重校验锁实现双重校验锁会进行两次检查，第一次是当实例为null的时候，如果需要创建实例对象，则会用synchronized关键字锁住响应对象头，然后再次检查对象是否为空（因为从检查到上锁前这段时间里实例对象可能已经被其他线程创建出来了，只有上锁后才能唯一确定其状态是【null】还是【已创建】）。而且相较于其他方法，双重校验锁能够在多线程的情况下依旧保持较高的性能。代码示例如下：123456789101112131415161718192021222324252627282930313233/** * @author bestsort */public class Singleton &#123; private int a; /** * 这里使用 volatile 防止指令重排，因为new并不是一个原子操作 * 不加 volatile 的话可能其他线程会访问到未初始化的对象 * 可以参见 java.util.concurrent.atomic 下的类,里面的value同样用volatile修饰过 */ private volatile static Singleton instance; private Singleton()&#123;&#125; /** * 双重检查锁（double-checked locking） */ public static Singleton getInstance()&#123; if (instance == null)&#123; //这里用synchronized锁住了该对象，保证有且只有一个线程创建Singleton实例 synchronized (Singleton.class)&#123; if (instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125;静态内部类实现静态内部类的好处是通过classloader的特性，可以天生实现懒加载和线程安全。只有当调用getInstance时，classloader才会去装在SingletonHolder，从而实例化INSTANCE。如果要实现懒加载特性，推荐使用之这种方法1234567891011121314151617181920/** * @author bestsort */public class Singleton &#123; private int a; private static Singleton instance; private static class SingletonHolder&#123; private static Singleton INSTANCE = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return SingletonHolder.INSTANCE; &#125; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125;枚举枚举类实现单例模式有很多优点：枚举类默认有private的无参构造方法自带线程安全枚举类天生支持序列化，也能防止反序列化重新创建新的对象枚举类编译后方法修饰词默认是final，能够防止反射攻击。此点存疑，笔者通过Fernflower decompiler反编译后并未看到final关键字，但是StackOverflow上时这么说的。这里因为笔者水平限制，所以给出相关链接由读者自行鉴别：StackOverflow相关问题、问题中提到的外链，CSDN博文对此解释.相关代码如下：1234567891011public enum Singleton&#123; // 实例 INSTANCE; int a; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125;调用的时候可以通过123456public class Main &#123; public static void main(String[] args) &#123; Singleton singleton = Singleton.INSTANCE; System.out.println(singleton.getA()); &#125;&#125;进行调用。单例模式使用场景个人认为，绝大多数用于数据处理的类都应该通过单例模式创建。Spring 就是这么做的，默认组件就是通过单例模式创建，有且仅有一个实例。还有就是频繁创建/销毁的对象，因为创建/销毁通常需要更多的GC次数，所以可以通过单例实现对象的复用。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JDK动态代理源码剖析]]></title>
    <url>%2F2020%2F01%2F14%2F114%2F</url>
    <content type="text"><![CDATA[newProxyInstance在上一文中(没看的欢迎回去复习，要考的～)，我们通过JDK实现了动态代理。为什么实现了InvocationHandler接口就可以进行代理？ 我们这一次尝试从 Main 开始去分析一下源码。可以看到Main调用了123Proxy.newProxyInstance(RobTicket.class.getClassLoader(), new Class[]&#123;RobTicket.class&#125;, new RobTicketInvocationHandler(new _12306()))去构造一个_12306的类，点进去看一下 newProxyInstance 到底做了什么1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; // InvocationHandler不可为空，这也就是为什么我们一开始要实现InvocationHandler接口 Objects.requireNonNull(h); // 浅拷贝 final Class&lt;?&gt;[] intfs = interfaces.clone(); /*当运行未知的Java程序的时候，该程序可能有恶意代码（删除系统文件、重启系统等），为了防止运行恶意代码对系统产生影响，需要对运行的代码的权限进行控制，这时候就要启用Java安全管理器,也就是这里的 SecurityManager。*/ final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. * 生成代理类，在此之前需进行权限检查 */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; //检查创建代理类所需的权限。 checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; //获取构造方法对象 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; //当修饰符不为public时，将其修改为可执行 if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; //新鲜出炉的代理类对象 return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125;Ok， 上面我们可以看到生成一个代理类的大概步骤如下：检查（非空检查、权限检查）生成代理类（主要是通过getProxyClass0）获取构造器，若修饰符不为public，则修改其可执行权限(setAccessible(true))返回通过构造器所创建的代理类对象关于检查这一块，我们不做过多讲解，doc里有很清晰的描述(大致就是检查一下包权限和类加载器)。我们从第二步开始进行分析。getProxyClass0从 newProxyInstance 查看getProxyClass0, 可以看到第一次是同一个类中进行跳转，然后调用了proxyClassCache.get(loader, interfaces) 这个方法。12345678910111213private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; // 这里检查了一下接口总数(感觉不痛不痒...) if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory // 这里是从缓存中拿到的代理类。如果不存在则会先创建 return proxyClassCache.get(loader, interfaces); &#125;我们接着跟下去，发现代码如下：WeakCache1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192final class WeakCache&lt;K, P, V&gt; &#123; private final ReferenceQueue&lt;K&gt; refQueue = new ReferenceQueue&lt;&gt;(); // the key type is Object for supporting null key private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map = new ConcurrentHashMap&lt;&gt;(); private final ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap = new ConcurrentHashMap&lt;&gt;(); private final BiFunction&lt;K, P, ?&gt; subKeyFactory; private final BiFunction&lt;K, P, V&gt; valueFactory; public WeakCache(BiFunction&lt;K, P, ?&gt; subKeyFactory, BiFunction&lt;K, P, V&gt; valueFactory) &#123; this.subKeyFactory = Objects.requireNonNull(subKeyFactory); this.valueFactory = Objects.requireNonNull(valueFactory); &#125; //key --&gt; ClassLoader loader | parameter --&gt; Class&lt;?&gt;... interfaces public V get(K key, P parameter) &#123; Objects.requireNonNull(parameter); //虽然这个方法没有给注释，但是我们跟进refQueue.poll()发现这个方法的作用是查看是否有可引用对象。然后再结合这个方法看，就能知道这个方法的目的：删除refQueue中所有已被回收的引用对象～ expungeStaleEntries(); //将 ClassLoader 弄成cacheKey的形式(这是一个弱引用). 根据下面的注释可以倒推这里的cacheKey作为一级缓存使用 Object cacheKey = CacheKey.valueOf(key, refQueue); // lazily install the 2nd level valuesMap for the particular cacheKey // 这里大意是组装一个二级缓存，。用到了线程安全的ConcurrentMap ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); // 当loader==null的时候就会出现valuesMap==null的情况 if (valuesMap == null) &#123; //尝试为values分配空间(有就返回，不存在就创建并put) ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); //如果不等于null的话说明还有救，就把valuesMap换成新地址 if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that // subKey from valuesMap // 在这里生成key Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); Supplier&lt;V&gt; supplier = valuesMap.get(subKey); Factory factory = null; // 轮询, 直到能从supplier取到value为止.理论上一次就够了，但是WeakCache没加锁，valueFactory是可能被其他线程修改的？所以这里采用了轮询，见缝插针咯～ while (true) &#123; if (supplier != null) &#123; //在这里取得所需要的代理类，详见Factory中的get方法 V value = supplier.get(); if (value != null) &#123; return value; &#125; &#125; // 下面对以下3种情况进行了处理.通过下面的处理后，某些情况下将会将supplier具体化为Factory(Factory 是 Supplier 的实现) // 1. 在缓存中没有该supplier --&gt; new 一个 Factory 作为 supplier 的值 // 2. 缓存中已有supplier --&gt; 尝试替换valuesMap中的supplier为现在的factory // 懒加载 if (factory == null) &#123; // Factory的构造和get方法推荐去看一下, 有一些比较有意思的东西，总共50行左右。这里就不作论述了 factory = new Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; supplier = valuesMap.putIfAbsent(subKey, factory); //supplier == null且valueMap成功put if (supplier == null) &#123; // successfully installed Factory supplier = factory; &#125; // else retry with winning supplier &#125; else &#123; if (valuesMap.replace(subKey, supplier, factory)) &#123; // successfully replaced // cleared CacheEntry / unsuccessful Factory // with our Factory supplier = factory; &#125; else &#123; // retry with current supplier supplier = valuesMap.get(subKey); &#125; &#125; &#125; &#125; private void expungeStaleEntries() &#123; CacheKey&lt;K&gt; cacheKey; while ((cacheKey = (CacheKey&lt;K&gt;)refQueue.poll()) != null) &#123; cacheKey.expungeFrom(map, reverseMap); &#125; &#125;&#125;这一部分是对于缓存的一些处理， 其中关于检查方面的代码依旧用了较多篇幅，逻辑部分不是很多。大致就是从缓存中获取代理，关于subKeyFactory.apply(key, parameter)这里123//Proxyprivate static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());123456//WeakCachepublic WeakCache(BiFunction&lt;K, P, ?&gt; subKeyFactory, BiFunction&lt;K, P, V&gt; valueFactory) &#123; this.subKeyFactory = Objects.requireNonNull(subKeyFactory); this.valueFactory = Objects.requireNonNull(valueFactory); &#125;我们通过Proxy类下的默认构造和WeakCache这里的赋值能发现这里的subKeyFactory是一个KeyFactory实例,而valueFactory则是一个ProxyClassFactory实例(下面要考的，记住咯)其中比较重要的是supplier.get()这个地方，如果这里是Factory实例的话，get()方法会调用ProxyClassFactory去生成一个代理类。这里先看一下Factory中的方法12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic synchronized V get() &#123; // serialize access // re-check Supplier&lt;V&gt; supplier = valuesMap.get(subKey); if (supplier != this) &#123; // something changed while we were waiting: // might be that we were replaced by a CacheValue // or were removed because of failure -&gt; // return null to signal WeakCache.get() to retry // the loop return null; &#125; // else still us (supplier == this) // create new value V value = null; try &#123; value = Objects.requireNonNull(valueFactory.apply(key, parameter)); &#125; finally &#123; if (value == null) &#123; // remove us on failure valuesMap.remove(subKey, this); &#125; &#125; // the only path to reach here is with non-null value assert value != null; // wrap value with CacheValue (WeakReference) CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value); // put into reverseMap reverseMap.put(cacheValue, Boolean.TRUE); // try replacing us with CacheValue (this should always succeed) if (!valuesMap.replace(subKey, this, cacheValue)) &#123; throw new AssertionError("Should not reach here"); &#125; // successfully replaced us with new CacheValue -&gt; return the value // wrapped by it return value;&#125;上面是自带的注释，因为比较详尽就不多做解释了。这里我们需要重点关注valueFactory.apply(key, parameter)这一行。create new value,这不就是咱要的东西嘛！跳转到调用的地方。有点长，不要怂，胜利就在眼前了！ProxyClassFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; // prefix for all proxy class names // 前缀，看来带这个的都是走这里造出来的 private static final String proxyClassNamePrefix = "$Proxy"; // 自增的Long，还是线程安全的 // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); //这个循环的目的 --&gt; 验证从传进来的类加载器加载出来的接口是不是和给的这堆接口是一样的玩意(可以去看看双亲委派哟) for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + " is not visible from class loader"); &#125; /* * 看看这万一是不是真的是接口,免得对牛谈琴 * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) &#123; //亲, 您不是接口嘞, 别想着偷渡了 throw new IllegalArgumentException( interfaceClass.getName() + " is not an interface"); &#125; /* * Verify that this interface is not a duplicate. * 避免重复实现某一接口(表示看到这里之前不知道能重复实现一个接口，写完这篇文章我去试试) */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( "repeated interface: " + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. * 还是校验，工业代码真的是...emmmm保险箱? */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( "non-public interfaces from different packages"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // 如果没有非public(双重否定 --&gt; 如果都是public就用com.sun.proxy这个包) // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; &#125; /* * Choose a name for the proxy class to generate. * 不必BB的线程安全.. */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. * 看到了什么!? 这就是曙光啊同志们，生!成!一!个！指！定！的！代！理！类！ */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125; &#125;ProxyGenerator希望就在前方～ 我们再点开ProxyGenerator.generateProxyClass这个方法，看一下具体实现:12345678910111213141516171819202122232425262728293031323334public static byte[] generateProxyClass(final String name, Class&lt;?&gt;[] interfaces, int accessFlags)&#123; ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags); //boss哟～ final byte[] classFile = gen.generateClassFile(); //这一堆是持久化生成出来的代理类，不用管 if (saveGeneratedFiles) &#123; java.security.AccessController.doPrivileged( new java.security.PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; try &#123; int i = name.lastIndexOf('.'); Path path; if (i &gt; 0) &#123; Path dir = Paths.get(name.substring(0, i).replace('.', File.separatorChar)); Files.createDirectories(dir); path = dir.resolve(name.substring(i+1, name.length()) + ".class"); &#125; else &#123; path = Paths.get(name + ".class"); &#125; Files.write(path, classFile); return null; &#125; catch (IOException e) &#123; throw new InternalError( "I/O exception saving generated file: " + e); &#125; &#125; &#125;); &#125; return classFile;&#125;又调用了一层… 再跟进去看看gen.generateClassFile(); 这个方法。前方高能预警：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155private byte[] generateClassFile() &#123; /* ============================================================ * Step 1: Assemble ProxyMethod objects for all methods to * generate proxy dispatching code for. * 为所有方法组装ProxyMethod对象，以生成代理调度代码。 */ /* * Record that proxy methods are needed for the hashCode, equals, * and toString methods of java.lang.Object. This is done before * the methods from the proxy interfaces so that the methods from * java.lang.Object take precedence over duplicate methods in the * proxy interfaces. * 这三个方法不用说了吧...hashCode，equals,toString */ addProxyMethod(hashCodeMethod, Object.class); addProxyMethod(equalsMethod, Object.class); addProxyMethod(toStringMethod, Object.class); /* * Now record all of the methods from the proxy interfaces, giving * earlier interfaces precedence over later ones with duplicate * methods. * 添加所有接口要求实现的方法 */ for (Class&lt;?&gt; intf : interfaces) &#123; for (Method m : intf.getMethods()) &#123; addProxyMethod(m, intf); &#125; &#125; /* * For each set of proxy methods with the same signature, * verify that the methods' return types are compatible. * 验证返回值 */ for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123; checkReturnTypes(sigmethods); &#125; /* ============================================================ * Step 2: Assemble FieldInfo and MethodInfo structs for all of * fields and methods in the class we are generating. * 为这些方法生成字段和方法信息 */ try &#123; //构造方法 methods.add(generateConstructor()); for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123; for (ProxyMethod pm : sigmethods) &#123; // add static field for method's Method object fields.add(new FieldInfo(pm.methodFieldName, "Ljava/lang/reflect/Method;", ACC_PRIVATE | ACC_STATIC)); // generate code for proxy method and add it methods.add(pm.generateMethod()); &#125; &#125; //生成静态代码块 methods.add(generateStaticInitializer()); &#125; catch (IOException e) &#123; throw new InternalError("unexpected I/O Exception", e); &#125; if (methods.size() &gt; 65535) &#123; throw new IllegalArgumentException("method limit exceeded"); &#125; if (fields.size() &gt; 65535) &#123; throw new IllegalArgumentException("field limit exceeded"); &#125; /* ============================================================ * Step 3: Write the final class file. * 最终文件 */ /* * Make sure that constant pool indexes are reserved for the * following items before starting to write the final class file. * 确保在开始写最终之前constant pool 的索引会被保留 */ cp.getClass(dotToSlash(className)); cp.getClass(superclassName); for (Class&lt;?&gt; intf: interfaces) &#123; cp.getClass(dotToSlash(intf.getName())); &#125; /* * Disallow new constant pool additions beyond this point, since * we are about to write the final constant pool table. * 设置只读 --&gt; 下面要开始往常量池里写东西了 */ cp.setReadOnly(); ByteArrayOutputStream bout = new ByteArrayOutputStream(); DataOutputStream dout = new DataOutputStream(bout); try &#123; /* * Write all the items of the "ClassFile" structure. * See JVMS section 4.1. */ // u4 magic; // 熟悉的CAFEBABE,看过JVM虚拟机的应该都知道。 dout.writeInt(0xCAFEBABE); // u2 minor_version; dout.writeShort(CLASSFILE_MINOR_VERSION); // u2 major_version; dout.writeShort(CLASSFILE_MAJOR_VERSION); cp.write(dout); // (write constant pool) // u2 access_flags; dout.writeShort(accessFlags); // u2 this_class; dout.writeShort(cp.getClass(dotToSlash(className))); // u2 super_class; dout.writeShort(cp.getClass(superclassName)); // u2 interfaces_count; dout.writeShort(interfaces.length); // u2 interfaces[interfaces_count]; for (Class&lt;?&gt; intf : interfaces) &#123; dout.writeShort(cp.getClass( dotToSlash(intf.getName()))); &#125; // u2 fields_count; dout.writeShort(fields.size()); // field_info fields[fields_count]; for (FieldInfo f : fields) &#123; f.write(dout); &#125; // u2 methods_count; dout.writeShort(methods.size()); // method_info methods[methods_count]; for (MethodInfo m : methods) &#123; m.write(dout); &#125; // u2 attributes_count; dout.writeShort(0); // (no ClassFile attributes for proxy classes) &#125; catch (IOException e) &#123; throw new InternalError("unexpected I/O Exception", e); &#125; return bout.toByteArray();&#125;在这里如果我们配置了System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);那么会在com.sun.proxy下生成我们代理类的字节码文件,还是使用上一文中的JDK动态代理的代码,最终生成结果如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.sun.proxy;import cn.bestsort.code.proxy.RobTicket;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;//可以看到实现了我们需要代理的类的接口public final class $Proxy0 extends Proxy implements RobTicket &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; //这里实现了咱们的抢票～ public final void startRob() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m2 = Class.forName("java.lang.Object").getMethod("toString"); m3 = Class.forName("cn.bestsort.code.proxy.RobTicket").getMethod("startRob"); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125;这里的supper.h其实是Proxy类里的成员变量InvocationHandler，这玩意就是我们上一文中实现的那个接口。忘了？没关系，来复习一下：1234567891011121314151617public class RobTicketInvocationHandler implements InvocationHandler &#123; private Object object; public RobTicketInvocationHandler(Object o)&#123; object = o; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(object, args); end(); return result; &#125; private void before()&#123; System.out.println("导入身份信息"); &#125; private void end()&#123; System.out.println("抢票成功, 开始付款"); &#125;&#125;因为在构造啊的时候我们将这个自己实现的RobTicketInvocationHandler作为h传进去了，所以调用的invoke其实是我们自己写的这个invoke方法，也就是说，到此为止，JDK动态代理的过程就结束了～12345RobTicket robTicket = (RobTicket) Proxy.newProxyInstance( RobTicket.class.getClassLoader(), new Class[]&#123;RobTicket.class&#125;, new RobTicketInvocationHandler(new _12306()));完结撒花～～～后记第一次这么完整地看完一部分源码，好激动。。。最后，欢迎关注我的公众号丫 —&gt; 直接在公众号搜索页面搜 bestsort, bestsort的秘密基地就是我啦～非常感谢街灯下的小草他的关于JDK动态代理的那篇文章给我阅读源码的大致脉络提供了非常大的帮助(可惜他那篇文章有一部分有错误，差点让我怀疑人生…)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proxy模式概述及如何实现动态代理]]></title>
    <url>%2F2020%2F01%2F03%2F107%2F</url>
    <content type="text"><![CDATA[前一阵子不是用AOP的时候碰见了一些问题嘛， 由于AOP是基于动态代理实现的，所以今天就抽时间看了一下～代理(proxy)模式算是很经常用到的一种模式了。就像日常生活一样，自己做不到的一些事情可以找别人帮忙完成一下～比如上不去分了找代练、不想出去吃饭叫外卖 等等..代理 说简单点就是四个字找人帮忙。在编码过程中具体体现为 通过低侵入的方式来实现一些功能代理模式主要分为两种实现. 按照职责划分的话。可以大致分作8类：远程代理虚拟代理Copy-on-Write 代理保护代理Cache代理防火墙代理同步化代理智能引用代理静态代理通过硬编码实现。 需要代理的对象在程序运行前就是已知的。换句话说，就是写死了的代理～比如说作为新生代优秀大学生， 部分人喜欢通过 智行 抢火车票而不是 12306， 但是我们知道网上的放票途径只有一种： 12306。 那么智行是怎么抢着票的呢？ 它其实是拿着你的信息去找12306要票啦～（瞎猜的，不可确信）也就是说， 在这里智行扮演了个代理者的形象。我们可以直接到 12306 抢票，但是由于智行在抢票的基础上提供了更便捷的功能，所以也有不少人用智行。这一过程可以用以下代码描述出来示例123456789101112 /** * 抢票 * @author bestsort * @version 1.0 * @date 1/3/20 12:47 PM */public interface RobTicket &#123; /** *开始抢票 */ public void startRob();&#125;123456789101112/** * 到官网( 12306 )去抢票 * @author bestsort * @version 1.0 * @date 1/3/20 12:52 PM */public class _12306 implements RobTicket&#123; @Override public void startRob() &#123; System.out.println("进入12306抢票"); &#125;&#125;123456789101112131415161718192021222324/** * 用智行抢票 * @author bestsort * @version 1.0 * @date 1/3/20 12:53 PM */public class ZhiXing implements RobTicket&#123; private _12306 officialWebsite = new _12306(); @Override public void startRob() &#123; before(); System.out.println("智行正在帮忙抢票~"); officialWebsite.startRob(); end(); System.out.println("抢票结束----"); &#125; private void before()&#123; System.out.println("导入身份信息"); &#125; private void end()&#123; System.out.println("抢票成功, 开始自动帮忙订酒店~"); &#125;&#125;从上面的代码可以看到， 智行持有了 12306 这个对象， 当有人用智行的时候， 智行可以QWER一通乱秀后再去抢票， 同时惹出事后还能帮忙擦个屁股～ 上面的例子有点类似 AOP 中的 环绕增强(Around)。 所以，当我们想在访问一个类时做一些控制或者其他花里胡哨的操作的时候可以试一试这个模式。动态代理上面的代码功能确实不错，但是写起来是真的累死个人…一次只能代理一个类。要是需要代理的类一多，来个超级加倍怕不怕？ 更别说静态代理这个东西。写的太多了看起来确实不好看…要知道懒是人类的本质懒是人类的本质懒是人类的本质（复读也是～）。动态代理就因此而生了。当然，它和静态代理还是有一些不同的地方的。 动态代理是通过反射创建，也就是说它是动态生成的。动态代理一般通过两种方式实现： JDK代理 和 CGLIB代理 两者底层实现不同， 我会尽力描述一下两者的特点和使用形式。P.s: 在Spring 中的组件如果没有实现接口会使用 CGLIB代理，而对于已经实现了接口的组件会使用 JDK代理，可以Debug看一下地址，CGLIB代理的类会有CGLIB-xxxxxx的标识.JDK 代理JDK代理 是基于反射和拦截器实现的，在我们代理一个类时，要确保满足以下条件：这个类必须实现了某一接口代理时需要实现InvocationHandler接口需要用Proxy.newProxyInstance 生成代理对象JDK代理主要依赖于 java.lang.reflect包 中的 Proxy 和 InvocationHandler 这两个类。 依旧以抢火车票为例， 看一下是咋实现的:上面的RobTicket接口和_12306实现不用变， 新增一个RobTicketInvocationHandler类，这个类实现了InvocationHandler方法,这个类现在的作用就相当于上面的ZhiXing，帮忙抢票的～12345678910111213141516171819202122232425import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * @author bestsort * @version 1.0 * @date 1/7/20 10:00 AM */public class RobTicketInvocationHandler implements InvocationHandler &#123; private Object object; public RobTicketInvocationHandler(Object o)&#123; object = o; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(object, args); end(); return result; &#125; private void before()&#123; System.out.println("导入身份信息"); &#125; private void end()&#123; System.out.println("抢票成功, 开始付款"); &#125;&#125;然后Main方法也需要变动一下:1234567891011121314151617181920import cn.bestsort.code.proxy.jdk.RobTicketInvocationHandler;import java.lang.reflect.Proxy;/** * @author bestsort * @version 1.0 * @date 1/3/20 12:44 PM */public class Main &#123; public static void main(String[] args) &#123; try &#123; RobTicket robTicket = (RobTicket) Proxy.newProxyInstance(RobTicket.class.getClassLoader(), new Class[]&#123;RobTicket.class&#125;, new RobTicketInvocationHandler(new _12306())); robTicket.startRob(); &#125;catch (Exception e)&#123; System.out.println(e.getMessage()); &#125; &#125;&#125;执行结果如下：123导入身份信息进入官网抢票抢票成功, 开始付款可以看到已经成功进行代理了。CGLIB代理cglib is a powerful, high performance and quality Code Generation Library, It is used to extend JAVA classes and implements interfaces at runtime.上述是CGLIB 对自己的一个描述。CGLIB是一个很强大的代码生成类库，可以在运行期间扩展Java类与实现Java接口。在 Spring 中如果要对某一组组件使用 AOP 进行切入话，如果组件实现了接口，则会通过 JDK 进行代理，否则就会通过 CGLIB 进行代理。 也就是说，使用CGLIB代理的类可以不实现接口下面还是通过代码来看一下怎么实现的使用 CGLIB 需要引入依赖， 这里通过 maven 导入cglib3.2.5：12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;_1230612345public class _12306&#123; public void startRob() &#123; System.out.println("进入官网抢票"); &#125;&#125;RobTicketMethodInterceptor123456789101112131415161718192021222324252627282930313233import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * @author bestsort * @version 1.0 * @date 1/7/20 4:12 PM */public class RobTicketMethodInterceptor implements MethodInterceptor &#123; /** * @param o 代理对象(由CGLIB生成) * @param method 要执行的方法 * @param objects 参数列表 * @param methodProxy 代理方法 * @return * @throws Throwable */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; before(); Object object = methodProxy.invokeSuper(o, objects); end(); return object; &#125; private void before()&#123; System.out.println("导入身份信息"); &#125; private void end()&#123; System.out.println("抢票成功, 开始付款"); &#125;&#125;Main123456789101112131415161718import cn.bestsort.code.proxy.cglib.RobTicketMethodInterceptor;import net.sf.cglib.proxy.Enhancer;/** * @author bestsort * @version 1.0 * @date 1/3/20 12:44 PM */public class Main &#123; public static void main(String[] args) &#123; //new 一个 Enhancer 对象 Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(_12306.class); //设置回调对象 enhancer.setCallback(new RobTicketMethodInterceptor()); _12306 proxy = (_12306)enhancer.create(); proxy.startRob(); &#125;&#125;执行结果如下：123导入身份信息进入官网抢票抢票成功, 开始付款后记我们在这里只说明了怎样进行静态代理和动态代理， 至于代理的具体步骤和源码分析， 本来想写的，后来发现篇幅过长。以后会专门写两篇文章尝试分析一下 JDK代理 和 CGLIB代理 的源码的]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bestsort 开通公众号了～欢迎关注哟～]]></title>
    <url>%2F2020%2F01%2F03%2F1203%2F</url>
    <content type="text"><![CDATA[为什么会有这个想法这一阵子一直都在 看书 / 划水 / 完成课程作业。 由于想准备一下春招实习， 所以也看了不少 掘金, 知乎, 公众号上的文章。 真心觉得公众号是个好东西～ 个人博客最近更新很少， 其实不是因为懒。 而是觉得： 我不仅仅把博客当成发布文章的地方，而是一个我自己个人学习、总结的地方。 最近由于准备春招的原因， 知识摄入的都是一些零零碎碎的东西， 而且这部分内容很容易找到非常优秀的文章， 我也不好意思现丑。 再加上某些知识我自己掌握也不是很好(比如说 Java 常用的一些知识)， 怕引起读者误解也就没有写。 并不是把这个博客遗弃了。。。我开通公众号主要是想有一个能够一起成长的地方， 目前打算写一些 后端技术栈相关知识(主要是Java)， 都是一些我学习过程中碰到的一些东西。还打算分享一些工具使用技巧(IntellIj IDEA， Markdown， 服务器等等一切我在玩的或者准备玩的东西)。博文发布的文章公众号也会同步推送， 不习惯用 RSS订阅 又想关注我的也可以关注公众号丫(开玩笑，怎么会有人想关注我这个菜狗)恩，就这样啦～微信搜索公众号 bestsort 就是我啦，头像和博客头像一样～呐，也可以扫描下面二维码关注～]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Redis缓存的一些思考]]></title>
    <url>%2F2019%2F12%2F18%2F1218%2F</url>
    <content type="text"><![CDATA[前言从一开始写 BBS-lite 的时候我就有打算整合 Redis 作为缓存， 但是在经历过 MyBatis整合Redis --&gt; Spring Boot封装好了的Redis Cache --&gt; 自己写Jedis控制 --&gt; 自定义注解切入Service层进行缓存 等一系列流程后， 我发现缓存并不是这么简单。上述我使用过的方式都有一定的缺陷…MyBatis二级缓存整合RedisMyBatis的二级缓存作用域是基于命名空间的，默认一个XML配置文件内都处于同一命名空间，而通过 MyBatis Generator 生成的 XML 文件每一个都对应了一张表。但是头疼的来了, 在二级缓存里每次进行修改/插入/删除都会刷新当前命名空间内的缓存。也就是说:碰见修改密集的部分模块，用了缓存基本跟没用一样…当然也可能是我才疏血浅不知道更好的方案，不过我在官方文档和Google也没找出合理的解决方案。使用Spring Boot的组件 spring-boot-starter-redis-cache用起来能满足基本的缓存需求， 但是由于是通过注册 CacheManager Bean 实现的，所以一些Redis的特性并未体现出来。 即便是通过注册相关配置Bean 能调整的东西也有限。 一些缓存问题也不能很好的处理，如: 缓存雪崩(因为不支持随机TTL)、自增/自减(计数应该是比较频繁的场景了)。自己写Jedis控制这个没什么好说的，单纯因为我有代码洁癖…不想在Service里来回调用Jedis引入一大堆重复代码…毕竟基本上每段Service层的代码里都有Jedis相关代码来回穿梭还是很烦的…就跟每个类都定义一个LogFactory的成员变量一样. @Slf4j和Log4j什么的它不香嘛？你把问题抛给我，我先看看我这有没有，没有我去仓库里拿出来给你同时我再记一下答案，这样下次问同样的问题我就不用再跑到仓库里去找了。 抽象一下，就会发现跟AOP很想呐～一些思考暂时想不到比较好的解决方案， Google到的也只是Redis Cache的一些基本运用， 达不到我想要的效果。我想写一个比较好用的 Redis 缓存。起码能达到以下效果:开箱即用: 通过AOP和自定义注解切入到一些层进行缓存操作。就这块而言很喜欢Spring Boot注解,在简化配置的同时侵入性也很低可扩展: 能够被很方便的二次开发, 可以通过自定义配置信息来加入一些自定义操作（比如说某些模块未实现的功能）自定义: 可以通过组合注解在原模块的基础注解上进行封装能够支持 inc(以及对 zset、 list、 set等数据结构的支持)支持随机TTL然后，注解里应该有以下字段(仅供参考):key/keyGenerator(支持自定义key)ttl(时间)timeType(时间单位,目前我定义了秒/分/时/天)randomTtl(boolean，是否开启随机ttl.p.s:此处开启后应该在ttl一段范围内随机浮动，不用太多，个人觉得+-2即可)strategy(缓存过期策略)cacheType(里面应该有四种，默认的新增，inc,delete和flush,当然也可以拆分成四个注解)不过我现在只在BBS-lite中实现上述 1、4中对inc的支持和 5。想的时候很简单， 真正到写的时候就不一样了。 一开始想把缓存切入到Service - Dao之间(理论上也应该这样)，后来发现Dao是通过MBG（MyBatis Generator）自动生成的，如果表结构后续有改动的话(肯定有改动的)都得写一遍…而放在Controller - Service之间的话由于AOP是基于proxy模式实现的，所以一些数据组装的活放在Service层的话又会失效。比如我要查看一篇文章的话那么对应的应该调用Service层中 incArticleView 和 getArticleInfo 以及 getUserInfo 等方法然后将数据组装，但是如果以这种思路就得把组装放在Controller层(前面有提到过AOP基于proxy模式实现，所以不能”我切我自己”)，又违背了单一职责原则后来又想到单独开一个Cache层，在Cache层中再注入Service,和Service实现同一个接口并加上@Primary注解，然后Controller层通过注入接口调用，如果当前接口有实现Cache的话，则默认通过Cache层代理一些操作。但是这样又回到开头的写Jedis手动控制了….目前来看，最优方案就只有将注解打在Service - Dao之间的，前人的经验果然是有道理的～]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[氢论坛:评论系统]]></title>
    <url>%2F2019%2F10%2F29%2F1029%2F</url>
    <content type="text"><![CDATA[前言终于把 氢论坛 的评论系统完成的七七八八了,卡了我很久很久,一直在想怎样才能简洁, 优美地弄出来一个评论系统.然而写着写着发现不知不觉中反而变得愚钝而麻烦了.前前后后花了将近一周时间(期间在写其他模块,闲暇的时候就会想一想关于评论的实现),最后也没有很满意.但是不管怎么样,功能终归是实现了.其中还有一部分未完成,比如说@某人,以及评论区的 markdown语法解析 .不过这些都不是什么问题了,所以暂且忽略掉这些细枝末节,就当我完成了叭.此文用来记录下我的设计思路及过程,毕竟是第一次写.权当借鉴啦~演示gif静态图后端设计一开始,我想的是评论共分成四级,每一级多一点缩进,这样显示层次. 不过在看了看 bilibili, 掘金, CSDN 等一些网站后发现基本上都是用的二级.就也改成二级的了.父评论作为对文章的评论,如上图的”我来评论一下“和”在来一下“.子评论是对评论的回复.如上图无名氏对bestsort的回复.这里我把父评论和子评论单独拆分成了两个表,其主要结构如下:1234567891011#父评论create table comment_parent( id bigint auto_increment primary key , comment_by_id bigint, question_id bigint, gmt_modified bigint, gmt_create bigint, content varchar(255), like_count bigint default 0);12345678910#子评论create table comment_kid( id bigint auto_increment primary key , comment_by_id bigint, pid bigint, gmt_modified bigint, gmt_create bigint, content varchar(255));其实起初我是放在一个表里的,但是那样的话把对应文章的评论取出来后还得在后台进行排序,然后在进行归类处理.但是排序本身的时间复杂度就是 $O(nlog(n))$的,而且把评论放在一个表里的话子评论会占据大量无用空间,如果想要加速就得依靠索引.但是添加联合索引其实没有太大必要,而且也没有拆开后分别添加索引来的快.想了想(其实就是踩了坑)最终还是把表拆成了上面这样子,然后 以 comment_parent为驱动表,comment_kid 为被驱动表去查询.因为我用了 mybatis, 所以可以直接将结果映射成 CommentParent实体中嵌套List&lt;CommentKid&gt;的形式. sql查询语句如下(知道最好不用select *,但是我真的懒得写了,目前来说这个不足以影响到性能).12345678910111213select comment_parent.*, kid.id kid_id, kid.pid pid, kid.comment_by_id kid_comment_by_id, kid.content kid_content, kid.gmt_create kid_gmt_create, kid.gmt_modified kid_gmt_modified from comment_parent left join comment_kid kid on kid.pid = comment_parent.id where comment_parent.question_id = #&#123;id,jdbcType=BIGINT&#125; order by gmt_create desc,kid_gmt_create前端我觉得前端才是我写这个的最大掣肘…因为我是真的不会阿QAQ.因为父评论涉及到点赞功能,所以要在 HTML 中嵌入每一个评论在数据库中对应的id, 还得根据选择器确定到底选的是哪一条,还得判断是父评论还是子评论. 偏偏我又不想循环去每个评论上都加一个id然后直接用id选择器去选择对应评论…这就导致了大部分时间我都在想怎么捣鼓这里…最后无奈之下,采用了以下方案:在一个选项点击后,用jQuery去取出它父级/祖父内存着的value(因为无论是父评论还是子评论结构都是固定的.但是这样有个很不好的点就是修改结构后得连这块一起修改,可以说是增加了耦合度吧),然后通过jQuery去修改弹出框的内容.HTML 部分如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;li style="margin: 0" value="4"&gt; &lt;div class="comment-main-level"&gt; &lt;div class="comment-avatar"&gt;&lt;img src="https://avatars1.githubusercontent.com/u/43701948?v=4" alt=""&gt;&lt;/div&gt; &lt;div class="comment-box"&gt; &lt;div class="comment-head"&gt; &lt;h6 class="comment-name by-author "&gt; &lt;a href="https://github.com/bestsort"&gt;bestsort&lt;/a&gt; &lt;/h6&gt; &lt;span class="comment-post pull-right" style="top: 0"&gt; &lt;input name="commentId" value="4" hidden="true"&gt; &lt;span class="option hover-point"&gt; &lt;i class="iconfont icon-zan"&gt; 点赞(0) &lt;/i&gt; &lt;/span&gt; &lt;span class="option hover-point" style="margin-right: 25px"&gt; &lt;i class="iconfont icon-fenxiang"&gt;&lt;/i&gt; 评论 &lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class="comment-content"&gt;我来评论一下 &lt;span&gt; 2019-10-29 14:57:36&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Respuestas de los comentarios --&gt; &lt;ul class="comments-list reply-list"&gt; &lt;li&gt; &lt;!-- Avatar --&gt; &lt;div class="comment-avatar"&gt;&lt;img src="https://alicdn.bestsort.cn/icon/default.jpeg" alt=""&gt;&lt;/div&gt; &lt;!-- Contenedor del Comentario --&gt; &lt;div class="comment-box"&gt; &lt;div class="comment-head"&gt; &lt;h6 class="comment-name "&gt;&lt;a href="null"&gt;无名氏&lt;/a&gt;&lt;/h6&gt; &lt;span class="comment-post pull-right"&gt; &lt;input value="1" hidden="true"&gt; &lt;span class="option hover-point" style="margin-right: 25px;top: 0"&gt; &lt;i class="iconfont icon-fenxiang"&gt;&lt;/i&gt; 评论 &lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class="comment-content"&gt;默认账户再测试一下 &lt;span&gt;2019-10-29 14:58:17&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/li&gt;jQuery 相关部分123456789101112131415161718192021222324252627282930$(document).on('click',".comment-post&gt;span",function () &#123; /** * 子评论 */ if ($(this).parents("li").length === 2)&#123; let own = $(this).prevAll("input"); let pid = $(this).parents("li")[1]; reply_comment(own,pid); &#125; /** * 父评论 */ else &#123; let commentId = $(this).prevAll("input").val(); /** * 评论 */ if ($(this).next().length === 0)&#123; reply_comment($(this).prevAll("input")); &#125; /** * 点赞 */ else&#123; let count = $(this).children().text().replace(/[^\d]/g, ''); let isActive = $(this).children().hasClass("on"); thumb_up_comment(commentId,isActive,count,$(this)); &#125; &#125; &#125;);当然整体肯定不止才这么点,我只是在这里提供一下思路抛砖引玉.想进一步了解的可以去我的仓库查看源码.其中后端处理部分主要位于CommentService.java前端处理部分主要位于question-details.js.氢论坛目前还在搭建中,不介意的话赏个 star 鼓励一下呀~]]></content>
      <categories>
        <category>氢论坛</category>
      </categories>
      <tags>
        <tag>氢论坛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机探究(二)—运行时数据区域]]></title>
    <url>%2F2019%2F10%2F13%2F1013%2F</url>
    <content type="text"><![CDATA[本文由作者通过《深入理解Java虚拟机》总结而来转载注明出自bestsort.cn,谢谢合作概览Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域,这些区域都有各自的用途， 以及创建及销毁的时间，有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而建立和销毁.在 Java7 中，Java虚拟机所管理的内存包括下图所示的几个运行时数据区域在 Java8 中，内存结构发生了些许变化。最主要的还是移除了方法区，确定了“元数据区”的概念。如下图方法区（Method Area）这里，我们不按照《深入理解JAVA虚拟机》里的顺序来介绍，而是先介绍方法区，并试着分析一下它为什么被抛弃。概念方法区（Method Area）是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息：非静态的属性非静态的方法的元数据运行时常量池方法和构造函数编译后的代码类加载初始化或者实例对象初始化用到的特殊方法虽然 Java虚拟机规范 把方法区描述为堆的逻辑部分，但是它却有一个别名叫做 Non-堆(非堆）,目的应该是与 Java堆区分开来经常会听到有人把方法区叫做永久代（Permanent Generation）。这是因为在 HotSpot（目前使用最广泛的虚拟机） 中选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区（其他虚拟机并没有这样实现，所以也就没有永久代这一说法），实际上两者并不等价。将GC分代扩展至方法区后，HotSpot 的垃圾收集器就可以像管理 Java堆 一样去管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。乍一看，方法区貌似是个好东西。但是需要注意的是，在 Java8 已经取消了方法区这个概念，而是用元数据区来接管方法区的一些工作。在方法区内，所有线程共享，生命周期与JVM一致，无需地址连续的内存。上文中说过常量池等一些类信息被存储在方法区内，但是这样有很多坏处: 容易造成内存溢出；也会产生性能问题. 因为每次Full GC 都会连带永久代一起GC。而且类及方法的信息难以确定其大小。如果加载比较多的类很有可能造成内存溢出。而如果为方法区指定较大的内存的话，势必会压缩老年代内存空间，又容易造成老年代的溢出Java8 改动在 Java8 中，方法区被移除，类的元数据被放在 native 堆中(点此查看通知邮件)这个空间被叫做元数据区.而字符串常量被移动到了 Java堆 中;元空间的特点充分利用了 Java 语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。每个加载器有专门的存储空间只进行线性分配不会单独回收某个类省掉了 GC 扫描及压缩的时间元空间里的对象的位置是固定的如果 GC 发现某个类加载器不再存活了，会把相关的空间整个回收掉元空间的内存分配模型绝大多数的类元数据的空间都从本地内存中分配用来描述类元数据的类也被删除了分元数据分配了多个虚拟内存空间给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型；sun / 反射 / 代理对应的类加载器的块会小一些归还内存块，释放内存块列表一旦元空间的数据被清空了，虚拟内存的空间会被回收掉减少碎片的策略以下部分参考自java-latte.blogspot我们可以通过下面这张图片看到如何为元数据分配虚拟内存空间，以及如何为每个类加载器加载虚拟存储空间。CL 是 Class Loader 的缩写你可以看到虚拟内存空间是如何分配的 (vs1,vs2,vs3) ，以及类加载器的内存块是如何分配的。CL 是 Class Loader 的缩写。理解_mark和_klass指针要想理解上面这张图，首先得搞清楚这些指针都是什么东西。JVM 中，每个对象都有一个指向它自身类的指针，不过这个指针只是指向具体的实现类，而不是接口或者抽象类。32 位的 JVM:_mark : 4 字节常量_klass: 指向类的 4 字节指针 对象的内存布局中的第二个字段 (_klass，在 32 位 JVM 中，相对对象在内存中的位置的偏移量是 4，64 位的是 8) 指向的是内存中对象的类定义。64 位的 JVM：_mark : 8 字节常量_klass: 指向类的 8 字节的指针开启了指针压缩的 64 位 JVM：_mark : 8 字节常量_klass: 指向类的 4 字节的指针只有是 64 位平台上启用了类指针压缩才会存在类指针压缩空间（Compressed Class Pointer Space）。对于 64 位平台，为了压缩 JVM 对象中的_klass 指针的大小，引入了类指针压缩空间（Compressed Class Pointer Space）。压缩后内存布局如下:改动后的优势如果你理解了元空间的概念，很容易发现 GC 的性能得到了提升。Full GC 中，元数据指向元数据的那些指针都不用再扫描了。很多复杂的元数据扫描的代码（尤其是 CMS 里面的那些）都删除了。元空间只有少量的指针指向 Java 堆。这包括：类的元数据中指向 java/lang/Class 实例的指针；数组类的元数据中，指向 java/lang/Class 集合的指针。没有元数据压缩的开销减少了根对象的扫描（不再扫描虚拟机里面的已加载类的字典以及其它的内部哈希表）减少了 Full GC 的时间G1 回收器中，并发标记阶段完成后可以进行类的卸载Hotspot 中的元数据现在存储到了元空间里。mmap 中的内存块的生命周期与类加载器的一致。类指针压缩空间（Compressed class pointer space）目前仍然是固定大小的，但它的空间较大可以进行参数的调优，不过这不是必需的。未来可能会增加其它的优化及新特性。比如， 应用程序类数据共享；新生代 GC 优化，G1 回收器进行类的回收；减少元数据的大小，以及 JVM 内部对象的内存占用量。因为上面的种种理由，最终在Java8中，元数据区替换掉了方法区堆(Java Heap)说完了非堆(前面有提到过方法区又名为Non-Heap(非堆）)，接下来就说一下堆吧.对于大多数应用来说,Java 堆是 Java 虚拟机所管理的内存中最大的一块.对于大多数刚刚创建的Java应用来说,如果觉得运行卡顿,第一想到的可能是提高-Xmx和-Xms的数值，这个在网上一些关于IDEA卡顿的文章里也有这个建议(IDEA本身就是使用Java构建的)Java 堆在虚拟机启动时创建，这块区域唯一的目的就是存放对象实例(包括字符串常量也在这里面). 几乎所有的对象实例都要在这里分配内存。在Java虚拟机规范中的描述是: 所有的对象实例以及数组都要在堆上分配。当然有时候为了调优和减少GC次数，程序员会选择在栈上分配对象实例，或者是进行标量替换。当然这里并不会详细分析这些策略，今后可能会试着分析一下这些方法。在Java 堆中，可大致分为新生代和老年代。其中又可细分为Eden，From Survivor，To Survivor等. 其具体的从属和大小关系如下图所示其中Form和To之间是动态切换的，以后我会单独写一下堆内存的分配、回收策略程序计数器(Program Counter Register)程序计数器是当前线程正在执行的字节码的地址。程序计数器是线程隔离的，每一个线程在工作的时候都有一个独立的计数器。在Java虚拟机中，多线程是靠CPU时间片轮转来调度的,也就是说一个线程可能还没有结束就被挂起。而当它再次获取时间片时，就需要从挂起的地方继续执行。在Java虚拟机中，通过程序计数器来记录程序的字节码执行位置。因为记录的信息很少，所以程序计数器占用的内存空间几乎可以忽略不计。而且程序计数器是java虚拟机规范中唯一一个没有规定任何OutofMemeryError的区域Java虚拟机栈（Java stack）如果把方法类比为C++中的函数的话，就会发现栈的作用几乎一样。在Java中，每个方法在运行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。其中，局部变量表存放了基本数据类型，对象引用类型（只是引用，不是对象本身。可类比C++中的指针）栈和程序计数器一样，也是线程隔离的。本地方法栈(Native Method Stack)本地方法栈和虚拟机栈的区别在与虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中堆本地方法栈Native方法要了解Native方法，我们首先需要知道JNI这个概念JNI允许程序员用其他编程语言来解决用纯粹的Java代码不好处理的情况，例如，Java标准库不支持的平台相关功能或者程序库。也用于改造已存在的用其它语言写的程序，供Java程序调用。许多基于JNI的标准库提供了很多功能给程序员使用，例如文件I/O、音频相关的功能。当然，也有各种高性能的程序，以及平台相关的API实现，允许所有Java应用程序安全并且平台独立地使用这些功能。native关键字被native关键字声明的方法说明该方法不是以Java语言实现的，而是以本地语言实现的。这也就是我们上面所说的Native方法本地方法和其它方法不一样，本地方法意味着和平台有关，因此使用了native的程序可移植性都不太高。另外native方法在JVM中运行时数据区也和其它方法不一样，它有专门的本地方法栈。native方法主要用于加载文件和动态链接库，由于Java语言无法访问操作系统底层信息（比如：底层硬件设备等），这时候就需要借助C语言来完成了。被native修饰的方法可以被C语言重写。堆外内存也是通过Native函数库分配的]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机探究(一)—八大垃圾收集器概览]]></title>
    <url>%2F2019%2F10%2F06%2F106%2F</url>
    <content type="text"><![CDATA[本文由作者通过《深入理解Java虚拟机》和部分网络资料总结而来转载注明出自bestsort.cn,谢谢合作JVM 垃圾收集器文中部分概念并行并行计算（英语：parallel computing）一般是指许多指令得以同时进行的计算模式。在同时进行的前提下，可以将计算的过程分解成小部分，之后以并发方式来加以解决。并发并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任意时刻点上只有一个程序在处理机上运行。Minor GC: 新生代的垃圾回收Major GC: 老年代的垃圾回收Full GC:整堆包括新生代和老年代的垃圾回收JVM常用的垃圾收集器有7种, 除了G1以外每种收集器只能作用于不同分代.SerialSerial 是最老的收集器, 在JDK1.3.1之前曾是新生代收集的唯一选择. 老就意味着历史遗留问题难以处理,这一点在Serial身上也有体现: Serial是一个单线程的收集器,也就是说它只能用一个CPU或一条线程去完成收集工作.在收集时，会暂停其他所有的工作进程. 这其实是很不可思议的. 试想, 在看电影看到酣畅淋漓的时候 Serial 告诉你: 停下来，我要开始GC了！尽管只有短短的几分钟，但是一场电影的观感体验肯定是大不如之前了。虽然看起来Serial 已经没什么存在的必要了,但是实际上,它仍然是虚拟机运行在Client模式下的默认新生代收集器.相对于其他收集器而言,它足够简单,而且对于单线程环境来讲,由于没有线程交互的开销,Serial反而能获取最高的资源收集效率. 所以,Serial对于运行在Client模式下的虚拟机是一个比较好的选择ParNewParNew 虽然有个新名字,但是它和Serial基本一致.包括Serial可用的控制参数,收集算法,对象分配规则,回收策略等都和Serial一致. 可以说两者是同一个模子里刻出来的.不过,ParNew 是多线程的. 它的出现解决了Serial不能多线程作业的这个痛点.还有值得一提的就是: 只有它和Serial能够和CMS(下文中会讲到,一款真正意义上支持并发的收集器) 配合工作.同其他多线程收集器一样, ParNew在限制单线程环境下依旧打不过天生只支持单线程的Serial收集器(甚至连超线程的Serial都打不过).Parallel ScavengeParallel Scavenge 是用于新生代的收集器. 和ParNew一样:也是使用复制算法并且是多线程收集器. 不过相较于其他收集器而言,Parallel Scavenge 的关注点并不在于怎样缩短GC时用户线程的停顿时间,而是达到一个可控制的吞吐量($吞吐量 = 运行用户代码时间/(运行用户代码时间 + GC时间)*100%$).Parallel Scavenge 提供了以下两个参数以用于控制吞吐量-XX:MaxGCPauseMillis : 控制最大GC停顿时间-XX:GCTimeRatio: 直接设置吞吐量大小($0&lt; n &lt;100$ 为GC时间占总时间的比率)此外, Parallel Scavenge 还提供了-XX：+UseAdaptiveSizePolicy以动态选择最大的吞吐量/最合适的停顿时间，自适应策略也是Parallel Scavenge和ParNew收集器的一个重要区别Serial Old顾名思义, Serial Old是Serial的老年代版本。同Serial一样， 它也是单线程收集器。用的是“标记——整理”算法。主要用于Client模式下的虚拟机。如果是Server模式的话，他也可以用于以下用途JDK1.5之前和Parallel Scavenge搭配使用(虽然Parallel Scavenge自身架构有用于老年代GC的PS MarkSweep，但是这两个收集器的实现方式非常接近)作为CMS的备用方案，在并行收集发生Concurrent Mode Failure 的时候使用Parallel OldParallel Old 是 Parallel Scavenge 的老年代版本，使用多线程和“标记——整理算法”。这个收集器是JDK1.6中才开始提供的，在此之前Parallel Scavenge可谓是处于一个非常尴尬的地位：在此之前要使用Parallel Scavenge的话只能搭配Serial Old(PS MarkSweep) 收集器。但是Serial Old在服务端应用性能上的低效（我们前面指出过Serial Old只能用于单线程），使得即使使用Parallel Scavenge也不能在整体应用上获得吞吐量最大化的效果。不过在Parallel Old出现过后，Parallel Scavenge + Parallel Old的搭配组合有了比较明确的应用场景。在注重吞吐量和CPU资源敏感的场合，都可优先考虑这个组合CMSCMS收集器是一种以获取最短回收停顿时间为目标的收集器，对于采用B/S架构的应用，CMS能很好的满足“流畅”这一需求，给用户带来较好的体验。CMS采用“标记——清除”算法，不过相较于前面几种收集器，CMS更复杂一些，整个GC过程分为以下几个步骤初始标记（CMS inital mark） 标记GC Roots 能直接关联到的对象并发标记（CMS concurrent mark）进行GC Roots Tracing的过程,在整个过程中耗时最长重新标记（CMS remark）为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短并发清除（CMS concurrent sweep）其中，初始标记和重新标记**仍然需要Stop The World。优点并发收集低停顿缺点对CPU资源非常敏感.在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。为了解决这种问题，虚拟机还提供了一种“增量式并发收集器”(Incremental Concurrent Mark Sweep/i-CMS).但是其效果很一般,目前，i-CMS已经不再提倡用户使用无法处理浮动垃圾（Floating Garbage）可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。当CMS运行期间预留的内存无法满足程序需要时，就会出现一次“ConCurrent Model Failure失败，这时候虚拟机将会临时启用Serial Old 来进行老年代的垃圾收集，这时候停顿时间就很长了标记-清除算法导致的空间碎片CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。G1G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一（14年开始商用），它是一款面向服务端应用的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：并行与并发 G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。分代收集 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。空间整合 G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。可预测的停顿 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。横跨整个堆内存在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。建立可预测的时间模型G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。避免全堆扫描——Remembered SetG1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。为了避免全堆扫描的发生，虚拟机为G1中每个Region维护了一个与之对应的Remembered Set。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：初始标记（Initial Marking） 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。并发标记（Concurrent Marking） 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。最终标记（Final Marking） 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。筛选回收（Live Data Counting and Evacuation） 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。总结收集器运行方式应用的年代算法目标适用场景Serial单线程新生代复制响应速度优先单CPU下的Client模式Serial Old单线程老年代标记-整理响应速度优先单CPU下的Client模式，CMS的后背预案ParNew多线程,并行新生代复制响应速度优先多CPU环境在Server模式下与CMS配合Parallel Scavenge多线程,并行新生代复制吞吐量优先在后台运算且不需要太多交互的任务Parallel Old多线程,并行老年代标记-整理吞吐量优先在后台运算且不需要太多交互的任务CMS多线程,并发老年代标记-清除响应速度优先B/S架构G1多线程,并发新生代&amp;&amp;老年代标记-整理+复制相应速度优先面向服务端应用,以后会逐步替换CMS后记标题写的是八大,但是上文中只有七个垃圾收集器.最后一个我想谈到的垃圾收集器是ZGC.没在上面出现主要有以下两个原因:在《深入理解Java虚拟机》中并未提到该垃圾收集器,因为到现在(JDK13)为止ZGC都未发布正式版本.在可预见的将来(JDK14)也仍然将G1作为首选的垃圾收集器网上关于ZGC的资料较少, 我所写下的内容仅仅代表个人理解,不一定正确ZGC此部分内容主要参照以下文章. 小部分来自其余网络资料Java 程序员的荣光，听 R 大论 JDK11 的 ZGCOpenJDK Wiki在上文中我们提到过 G1 是非常优秀的垃圾收集器了. 那么为什么还需要 ZGC 呢? 自然是 ZGC 比 G1 更优秀了~.ZGC 主要有以下几个特点:暂停时间不超过10 毫秒暂停时间不会随堆或活动集的大小而增加堆范围可从M到T碎碎念虽然是国庆七天乐，但是我真的是写了七天BUG啊QAQ最近因为写项目的关系也没时间更新博客了也抽不出太多时间去看书我太难了]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 整合 Redis 作为二级缓存]]></title>
    <url>%2F2019%2F10%2F02%2F102%2F</url>
    <content type="text"><![CDATA[前言为了配个缓存我容易吗我….最近在写一个个人项目, 用 Spring Boot 构建, 因为懒省事就用了 Myatis 和 MyBatis Generator 管理我的 SQL 语句. 昨天心血来潮想用缓存减轻数据库压力(因为某些特定页面信息量比较多,所以SQL查询比较慢). 想了想觉得还是不用 MyBatis 自带的二级缓存(HashMap 实现的, 感觉不是很好), 最后选择了 Redis 作为缓存方案.但是 MyBatis 整合 Redis 这个东西, 网上的坑是真的多阿… 还都是相互抄的… 偏偏 MyBatis 的官方文档对于二级缓存这一部分资料又比较少, 基本上就是一笔带过. 因为还要肝项目,所以就直接 Baid/Google 各种解决方案, 最后还是在掘金找到了个能用的,下面附上参考链接当然因为我是用的 MyBatis Generator, 所以生成的时候没法序列化, 翻了好久,最后才发现官方已经给了序列化的插件开始这里我附上 import, 缺的包自行下载. 另外,日志我使用的是 @Slf4j 注解,这个需要搭配 IDEA 的 Lombook插件使用(Eclipse我不确定有没有),如果不想安装的话可以自行参考上面我所附参考链接的日志写法首先,我们需要实现 org.apache.ibatis.cache.Cache 类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.cache.Cache;import org.springframework.data.redis.core.RedisCallback;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * @ClassName RedisCache * @Description Mybatis 二级缓存实现 * @Author bestsort * @Date 19-10-2 上午10:15 * @Version 1.0 */@Slf4jpublic class RedisCache implements Cache &#123; private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); /** * id,每个实现 Cache 的类都需要实现带 id 的构造方法 */ private final String id; private RedisTemplate redisTemplate; /** * redis过期时间 */ private static final long EXPIRE_TIME_IN_MINUTES = 30; public RedisCache(String id) &#123; if (id == null) &#123; throw new IllegalArgumentException("Cache instances require an ID"); &#125; this.id = id; &#125; @Override public String getId() &#123; return id; &#125; @Override @SuppressWarnings("unchecked") public void putObject(Object key, Object value) &#123; try &#123; RedisTemplate redisTemplate = getRedisTemplate(); ValueOperations opsForValue = redisTemplate.opsForValue(); opsForValue.set(key, value, EXPIRE_TIME_IN_MINUTES, TimeUnit.MINUTES); log.debug("Put query result to redis"); &#125; catch (Throwable t) &#123; log.error("Redis put failed", t); &#125; &#125; @Override public Object getObject(Object key) &#123; try &#123; RedisTemplate redisTemplate = getRedisTemplate(); ValueOperations opsForValue = redisTemplate.opsForValue(); log.debug("Get cached query result from redis"); return opsForValue.get(key); &#125; catch (Throwable t) &#123; log.error("Redis get failed, fail over to db", t); return null; &#125; &#125; @Override @SuppressWarnings("unchecked") public Object removeObject(Object key) &#123; try &#123; RedisTemplate redisTemplate = getRedisTemplate(); redisTemplate.delete(key); log.debug("Remove cached query result from redis"); &#125; catch (Throwable t) &#123; log.error("Redis remove failed", t); &#125; return null; &#125; @Override public void clear() &#123; RedisTemplate redisTemplate = getRedisTemplate(); redisTemplate.execute((RedisCallback) connection -&gt; &#123; connection.flushDb(); return null; &#125;); log.debug("Clear all the cached query result from redis"); &#125; @Override public int getSize() &#123; return 0; &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return readWriteLock; &#125; private RedisTemplate getRedisTemplate() &#123; if (redisTemplate == null) &#123; redisTemplate = ApplicationContextHolder.getBean("redisTemplate"); &#125; return redisTemplate; &#125;&#125;需要注意的是，这里不能通过 @Autowire 的方式引用redisTemplate，因为RedisCache并不是Spring容器里的bean。所以我们需要手动地去调用容器的getBean方法来拿到这个bean,所以需要再创建一个类拿到 bean12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.bestsort.bbslite.cache;/** * @ClassName ApplicationContextHolder * @Author bestsort * @Date 19-10-2 上午10:22 * @Version 1.0 */import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;@Componentpublic class ApplicationContextHolder implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123; applicationContext = ctx; &#125; /** * Get application context from everywhere * * @return */ public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; /** * Get bean by class * * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; return applicationContext.getBean(clazz); &#125; /** * Get bean by class name * * @param name * @param &lt;T&gt; * @return */ @SuppressWarnings("unchecked") public static &lt;T&gt; T getBean(String name) &#123; return (T) applicationContext.getBean(name); &#125;&#125;序列化当然, 光上面是不够的,还需要在 数据库的查询对象 里实现 Serializable 接口. 拿我项目中的 topic 类举例,需要像这样:未实现 Serializable1234567891011121314public class Topic &#123; private Long id; private String name; private String avatarUrl; private Long questionCount; private Long followCount; //getter 和 setter&#125;实现后1234567891011121314public class Topic implements Serializable &#123; private Long id; private String name; private String avatarUrl; private Long questionCount; private Long followCount; private static final long serialVersionUID = 1L; //getter 和 setter&#125;实现了 Serializable 接口后,我们可以在 xxxMapper.xml 中添加字段来使用二级缓存了.MyBatis Generator因为我用了 MyBatis Generator,所以不可能手动去写的, 这样每次重新生成 mapper 文件的时候我还得手动改,不存在的.幸运的是,官方已经为我们提供了 自动序列化的插件,所以只需要添加插件就可以了. 在 generatorConfiguration 字段下的 context 里添加两个插件12345678910&lt;!-- 序列化插件 --&gt;&lt;plugin type="org.mybatis.generator.plugins.SerializablePlugin"/&gt;&lt;!-- 所有Mapper 都开启缓存 --&gt;&lt;plugin type="org.mybatis.generator.plugins.CachePlugin"&gt; &lt;property name="cache_type" value="cn.bestsort.bbslite.cache.RedisCache"/&gt; &lt;property name="cache_eviction" value="LRU"/&gt; &lt;property name="cache_flushInterval" value="60000"/&gt; &lt;property name="cache_size" value="512"/&gt;&lt;/plugin&gt;然后再执行一次 mvn -Dmybatis.generator.overwrite=true mybatis-generator:generate 重新生成并覆盖生成的文件即可测试运行一下我的项目,下面这是第一次访问第二次访问相同内容,可以在日志中看到缓存已经命中]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布隆过滤器初步学习]]></title>
    <url>%2F2019%2F09%2F18%2F918%2F</url>
    <content type="text"><![CDATA[布隆过滤器概念布隆过滤器用类似HashMap的实现方式, 可以在大数据量下进行高效的插入和查询操作(时间复杂度近似O(1)). 但是只能判断某个数据不存在而不能断定其存在.至于为什么会这样, 其实是因为布隆过滤器的实现方法所限制的.优点在Java 的 HashMap 中,存储数据是用的数组-链表的形式,每一个 Key 都对应着一个 Value.而布隆过滤器用 bit 代替了其中的数组和链表, 并使用多次映射来降低误判率,相当于用多个 Key 对应一个 Value.之所以这么实现, 是因为 HashMap 这样的数据结构在面对大量数据的时候会花费海量内存.而布隆过滤器可以用很小的代价(较低的误判率)来达到目的(减少内存开销)缺点不支持删除因为是多Hash值对应的同一个Value,所以可能会存在某些数据的部分Hash值重叠的情况.这时候如果删除的话,会使其他数据被波及误算率随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用Hash表足矣。应用场景布隆过滤器通常用在过滤Web请求方面.比如说一个个人搭建的网站,其URL用的是 https://bestsort.cn/id 的形式,在遭到爬虫爬取的时候,很多人看到id会想到直接爬取 id 为$1-n$的所有内容.但是问题是很多 id 可能都是无效的.这时候如果按照$1-n$爬取就会造成大量浪费服务器资源. 这种场景下,就可以使用布隆过滤器,对于非法请求直接返回错误页面,不再进行数据库查询等一系列操作.大Value拆分因为通常来说使用布隆过滤器都是在数据量极大的情况下,所以即使是 bit, 也会使用较大的空间来减少误算率(空间越大,碰撞可能性就越少).而对于redis来说可能就成了一个不得不拆分的大Value.通常来说，一般会把一个 bit 数组拆分成多个数组，同时使得计算出来的多个Key尽可能均匀的分布在各个bit数组上，最后查询的时候分别查询即可]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 分页查询优化]]></title>
    <url>%2F2019%2F08%2F29%2F829%2F</url>
    <content type="text"><![CDATA[今天写自己的项目的时候碰到了一个关于分页的问题,但是参考的那个分页写的很朴素(就是很费时~),正好以前也貌似听说过分页的优化.就自己动手测了一下优化前后的时间开销.在 MySQL 中(为什么不谈 Oracle 或者 SQL Server? 因为我没用过阿~),我所查询到的分页常用的方案有使用limit 和 子查询 俩种方案.在我参考的那个项目中,针对与 MySQL 的分页直接用的 SELECT * FROM (table) LIMITE (num1),(num2) 进行分页. 但是我查了查这种分页方式有点垃圾不大好. 垃圾不好之处在于当偏移量增大后,查询速度会明显变慢. 先说有没有, 再说是不是. 为了避免 你抄我博文我抄你博文最后全抄错 的情况,我决定亲自试一下.开局准备建表语句如下:123456789create table test( id int auto_increment primary key, col1 int null, col2 varchar(20) null, col3 varchar(20) null, col4 varchar(20) null, col5 varchar(20) null);然后我在里面插了一堆数据,大致都如下面这样类似上面的数据,我共计插入了 10059564 行. 一般来说百万行就要进行分库分表了,这里为了测试,就写到了千万行.注意本次测试均在未建立索引,未排序情况下进行. 至于建立索引/顺序分页,等我要用到的时候再回来补充Limit 方案先试一下SELECT * FROM test LIMIT num1,num2, 看看它到底哪里慢.执行结果如下:num1num2执行时间(s)10001000000.06399575100001000000.073557251000001000000.103766510000001000000.324019100000001000002.628352251000100000.0167992510000100000.01331575100000100000.031857751000000100000.252816510000000100003.19394325由上表可以看出来, 确实是 当偏移量增大后,查询速度会明显变慢, 尤其是在行数到达千万级后,最佳方案是将行数维持在 100000 以内.换句话说, Limit 只适用于中小型表的分页.使用子查询优化接下来我们再试一下子查询优化. 既然时间花费在偏移量上,那我们就先找到偏移量,再使用 Limit 进行查询. SQL 如下:SELECT * FROM test WHERE id &gt;= (SELECT id FROM test LIMIT num1,1) LIMIT num2然后再看一下时间开销num1num2执行时间(s)10001000000.07758550100001000000.082301501000001000000.0975295010000001000000.24955775100000001000001.854807001000100000.0087980010000100000.00879800100000100000.025380501000000100000.1558520010000000100001.76606600总结num1num2执行时间(Limit)执行时间(子查询)10001000000.063995750.07758550100001000000.073557250.082301501000001000000.10376650.0975295010000001000000.3240190.24955775100000001000002.628352251.854807001000100000.016799250.0087980010000100000.013315750.00879800100000100000.031857750.025380501000000100000.25281650.1558520010000000100003.193943251.76606600从测试结果来看,使用 子查询优化是不错的选择, 当然,在表较小的时候,使用 Limit 进行分页也无可厚非. 但是频繁分页访问的表还是优先推荐 子查询优化.后记其实,在 W3Cschool 上还有一种 以ID限定进行优化的方案,但是个人觉得连续递增ID这个条件很难实现(自增的时候总要删掉一些没用数据)故没有进行测试. 有兴趣的可以自己试一试]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>分页查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Java 编程风格指南(中文)]]></title>
    <url>%2F2019%2F08%2F21%2F821-4%2F</url>
    <content type="text"><![CDATA[PDF 文件下载前言这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。术语说明在本文档中，除非另有说明：术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。其他的术语说明会偶尔在后面的文档出现。指南说明本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。源文件基础文件名源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。文件编码：UTF-8源文件编码格式为UTF-8。特殊字符空白字符除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：所有其它字符串中的空白字符都要进行转义。制表符不用于缩进。特殊转义序列对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, “, ‘及)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。非ASCII字符对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。例如：1234567891011121314/*赞，即使没有注释也非常清晰*/String unitAbbrev="μs";/*允许，但没有理由要这样做*/String unitAbbrev="\u03bcs";// "μs"/*允许，但这样做显得笨拙还容易出错*/String unitAbbrev="\u03bcs";// Greek letter mu, "s"/*很糟，读者根本看不出这是什么*/String unitAbbrev="\u03bcs";///*Good，对于非打印字符，使用转义，并在必要时写上注释*/return'\ufeff'+content;// byte order markTip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行，你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)源文件结构一个源文件包含(按顺序地)：许可证或版权信息(如有需要)package语句import语句一个顶级类(只有一个)以上每个部分之间用一个空行隔开。许可证或版权信息如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。package语句package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)import语句import不要使用通配符即，不要出现类似这样的import语句：import java.util.*;不要换行import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)顺序和间距import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：所有的静态导入独立成组com.google imports(仅当这个源文件是在com.google包下)第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sunjava importsjavax imports组内不空行，按字典序排列。类声明只有一个顶级类声明每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。例外：package-info.java，该文件中可没有package-info类。类成员顺序类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。重载：永不分离当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。格式术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。大括号使用大括号大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。非空块：K &amp; R 风格对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格(Egyptian brackets):左大括号前不换行左大括号后换行右大括号前换行如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。示例：123456789101112return new MyClass()&#123; @Override public void method()&#123; if(condition())&#123; try&#123; something(); &#125;catch(ProblemExceptione)&#123; recover(); &#125; &#125; &#125; &#125;;空块：可以用简洁版本一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally)，即使大括号内没内容，右大括号也要换行。示例：1void do Nothing()&#123;&#125;块缩进：2个空格每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)一行一个语句每个语句后要换行。列限制：80或100一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。例外：不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。package和import语句(见3.2节和3.3节)。注释中那些可能被剪切并粘贴到shell中的命令行。自动换行术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(合理缩短命名长度)从哪里断开自动换行的基本准则是：更倾向于在更高的语法级别处断开。如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（&lt;T extends Foo &amp; Bar&gt;)，catch块中的管道符号(catch (FooException | BarException e)如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。方法名或构造函数名与左括号留在同一行。逗号(,)与其前面的内容留在同一行。自动换行时缩进至少+4个空格自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。空白垂直空白以下情况需要使用一个空行：类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。在函数体内，语句的逻辑分组间使用空行。类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。要满足本文档中其他节的空行要求(比如3.3节：import语句)多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。水平空白除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。分隔任何保留字与其前面的右大括号(})(如else, catch)。在任何左大括号前({)，两个例外：@SomeAnnotation({a, b})(不使用空格)。String[][] x = foo;(大括号间没有空格，见下面的Note)。在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：类型界限中的&amp;(&lt;T extends Foo &amp; Bar&gt;)。catch块中的管道符号(catch (FooException | BarException e)。foreach语句中的分号。在, : ;及右括号())后如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。类型和变量之间：List list。数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。水平对齐：不做要求术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。以下示例先展示未对齐的代码，然后是对齐的代码：1234private int x;// this is fineprivate Color color;// this tooprivate int x;// permitted, but future editsprivate Color color;// may leave it unalignedTip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)，这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。用小括号来限定组：推荐除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。具体结构枚举类枚举常量间用逗号隔开，换行可选。没有方法和文档的枚举类可写成数组初始化的格式：1private enum Suit&#123;CLUBS,HEARTS,SPADES,DIAMONDS&#125;由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。变量声明每次只声明一个变量不要使用组合声明，比如int a, b;。需要时才声明，并尽快进行初始化不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。数组数组初始化：可写成块状结构数组初始化可以写成块状结构，比如，下面的写法都是OK的：1234567891011121314new int[]&#123; 0,1,2,3&#125;new int[]&#123; 0, 1, 2, 3&#125;new int[]&#123; 0,1, 2,3&#125;new int[]&#123;0,1,2,3&#125;非C风格的数组声明中括号是类型的一部分：String[] args， 而非String args[]。switch语句术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。缩进与其它块状结构一致，switch块中的内容缩进为2个空格。每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。Fall-through：注释在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例：12345678910switch(input)&#123; case1: case2: prepareOneOrTwo();// fall through case3: handleOneTwoOrThree(); break; default: handleLargeNumber(input);&#125;default的情况要写出来每个switch语句都包含一个default语句组，即使它什么代码也不包含。注解(Annotations)注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：123@Override@Nullablepublic String getNameIfPresent()&#123;...&#125;例外：单个的注解可以和签名的第一行出现在同一行。例如：1@Override public int hashCode()&#123;...&#125;应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：1@Partial @Mock DataLoader loader;参数和局部变量注解没有特定规则。注释块注释风格块注释与其周围的代码在同一缩进级别。它们可以是/* ... */风格，也可以是// ...风格。对于多行的/* ... */注释，后续行必须从*开始，并且与前一行的*对齐。以下示例注释都是OK的。123456789101112/* * This is * okay. */ // And so // is this. /* Or you can * even do this. */注释不要封闭在由星号或其它字符绘制的框架里。Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用 /* ... */。Modifiers类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。1public protected private abstract static final transient volatile synchronized native strictfp命名约定对所有标识符都通用的规则标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。标识符类型的规则包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线。类名类名都以UpperCamelCase风格编写。类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。方法名方法名都以lowerCamelCase风格编写。方法名通常是动词或动词短语。下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test&lt;MethodUnderTest&gt;_&lt;state&gt;，例如testPop_emptyStack。并不存在唯一正确的方式来命名测试方法。常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时，考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。123456789101112131415// Constantsstatic final int NUMBER=5;static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of("Ed","Ann");static final Joiner COMMA_JOINER = Joiner.on(',');// because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = "non-final";final String nonStatic = "non-static";static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;"these","can","change"&#125;;这些名字通常是名词或名词短语。非常量字段名非常量字段名以lowerCamelCase风格编写。这些名字通常是名词或名词短语。参数名参数名以lowerCamelCase风格编写。参数应该避免用单个字符命名。局部变量名局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。类型变量名类型变量可用以下两种风格之一进行命名：单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。驼峰式命名法(CamelCase)驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。名字从散文形式(prose form)开始:把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：每个单词的第一个字母都大写，来得到大驼峰式命名。除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。最后将所有的单词连接起来得到一个标识符。示例：Prose formCorrectIncorrect“XML HTTP request”XmlHttpRequestXMLHTTPRequest“new customer ID”newCustomerIdnewCustomerID“inner stopwatch”innerStopwatchinnerStopWatch“supports IPv6 on iOS?”supportsIpv6OnIossupportsIPv6OnIOS“YouTube importer”YouTubeImporterYoutubeImporter加红号处表示可以，但不推荐。Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。编程实践@Override：能用则用只要是合法的，就把@Override注解给用上。捕获的异常：不能忽视除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。)如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。1234567try&#123; int i = Integer.parseInt(response); return handleNumericResponse(i);&#125;catch(NumberFormatException ok)&#123; // it's not numeric; that's fine, just continue&#125;return handleTextResponse(response);例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常，因此在这里就没有必要加注释。123456try&#123; emptyStack.pop(); fail();&#125;catch(NoSuchElementException expected)&#123;&#125;静态成员：使用类进行调用使用类名调用静态的类成员，而不是具体某个对象或表达式。1234FooaFoo=...;Foo.aStaticMethod();// goodaFoo.aStaticMethod();// badsomethingThatYieldsAFoo().aStaticMethod();// very badFinalizers: 禁用极少会去重写Object.finalize。Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解 Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。Javadoc格式一般形式Javadoc块的基本格式如下所示：12345/*** Multiple lines of Javadoc text are written here,* wrapped normally...*/public int method(String p1)&#123;...&#125;或者是以下单行形式：1/** An especially short bit of Javadoc. */基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。段落空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。除了第一个段落，每个段落第一个单词前都有标签&lt;p&gt;，并且它和第一个单词间没有空格。Javadoc标记标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。当描述无法在一行中容纳，连续行需要至少再缩进4个空格。摘要片段每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a...或This method returns...开头,它也不会是一个完整的祈使句，如Save the record...。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。Tip：一个常见的错误是把简单的Javadoc写成/** @return the customer ID */，这是不正确的。它应该写成/** Returns the customer ID. */。哪里需要使用Javadoc至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：例外：不言自明的方法对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName，就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。例外：重写如果一个方法重写了超类中的方法，那么Javadoc并非必需的。可选的Javadoc对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为，那么这个注释应该写成Javadoc，这样更统一更友好。后记本文档翻译自Google Java Style译者@HawsteinPDF 文档由 bestsort 自 Google Java 编程风格指南 整理而来]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java LinkList 简介]]></title>
    <url>%2F2019%2F08%2F21%2F821-3%2F</url>
    <content type="text"><![CDATA[本文转自JavaGuide简介LinkedList是一个实现了List接口和Deque接口的双端链表。 LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性; LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：1List list=Collections.synchronizedList(new LinkedList(...));## 内部结构分析 **如下图所示：** ![LinkedList内部结构](https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&h=481&f=jpeg&s=18502) 看完了图之后，我们再看LinkedList类中的一个**内部私有类Node**就很好理解了：1234567891011private static class Node&lt;E&gt; &#123; E item;//节点值 Node&lt;E&gt; next;//后继节点 Node&lt;E&gt; prev;//前驱节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125;这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。 ## LinkedList源码分析 ### 构造方法 **空构造方法：**12public LinkedList() &#123;&#125;**用已有的集合创建链表的构造方法：**1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125;### add方法 **add(E e)** 方法：将元素添加到链表尾部1234public boolean add(E e) &#123; linkLast(e);//这里就只调用了这一个方法 return true; &#125;1234567891011121314/** * 链接使e作为最后一个元素。 */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode;//新建节点 if (l == null) first = newNode; else l.next = newNode;//指向后继元素也就是指向下一个元素 size++; modCount++; &#125;**add(int index,E e)**：在指定位置添加元素12345678public void add(int index, E element) &#123; checkPositionIndex(index); //检查索引是否处于[0-size]之间 if (index == size)//添加在链表尾部 linkLast(element); else//添加在链表中间 linkBefore(element, node(index)); &#125;linkBefore方法需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了Node(index)去找到index对应的nodeaddAll(Collection c )：将集合插入到链表尾部123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125;addAll(int index, Collection c)： 将集合从指定位置开始插入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //1:检查index范围是否在size之内 checkPositionIndex(index); //2:toArray()方法把集合的数据存到对象数组中 Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; //3：得到插入位置的前驱节点和后继节点 Node&lt;E&gt; pred, succ; //如果插入位置为尾部，前驱节点为last，后继节点为null if (index == size) &#123; succ = null; pred = last; &#125; //否则，调用node()方法得到后继节点，再得到前驱节点 else &#123; succ = node(index); pred = succ.prev; &#125; // 4：遍历数据将数据插入 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; //创建新节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); //如果插入位置在链表头部 if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; //如果插入位置在尾部，重置last节点 if (succ == null) &#123; last = pred; &#125; //否则，将插入的链表与先前链表连接起来 else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125;上面可以看出addAll方法通常包括下面四个步骤：检查index范围是否在size之内toArray()方法把集合的数据存到对象数组中得到插入位置的前驱和后继节点遍历数据，将数据插入到指定位置addFirst(E e)： 将元素添加到链表头部123public void addFirst(E e) &#123; linkFirst(e); &#125;12345678910111213private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);//新建节点，以头节点为后继节点 first = newNode; //如果链表为空，last节点也指向该节点 if (f == null) last = newNode; //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素 else f.prev = newNode; size++; modCount++; &#125;addLast(E e)： 将元素添加到链表尾部，与 add(E e) 方法一样123public void addLast(E e) &#123; linkLast(e); &#125;根据位置取数据的方法get(int index)： 根据指定索引返回数据123456public E get(int index) &#123; //检查index范围是否在size之内 checkElementIndex(index); //调用Node(index)去找到index对应的node然后返回它的值 return node(index).item; &#125;获取头节点（index=0）数据方法:123456789101112131415161718public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; &#125;public E element() &#123; return getFirst(); &#125;public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125;public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125;区别：getFirst(),element(),peek(),peekFirst()这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中getFirst() 和element() 方法将会在链表为空时，抛出异常element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException获取尾节点（index=-1）数据方法:12345678910public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; &#125;public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item; &#125;两者区别：getLast() 方法在链表为空时，会抛出NoSuchElementException，而peekLast() 则不会，只是会返回 null。根据对象得到索引的方法int indexOf(Object o)： 从头遍历找12345678910111213141516171819public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; //从头遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; //从头遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125;int lastIndexOf(Object o)： 从尾遍历找12345678910111213141516171819public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; //从尾遍历 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; //从尾遍历 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1; &#125;检查链表是否包含某对象的方法：contains(Object o)： 检查对象o是否存在于链表中123public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125;删除方法remove() ,removeFirst(),pop(): 删除头节点123456789101112public E pop() &#123; return removeFirst(); &#125;public E remove() &#123; return removeFirst(); &#125;public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125;removeLast(),pollLast(): 删除尾节点12345678910public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125;public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l); &#125;区别： removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。remove(Object o): 删除指定元素12345678910111213141516171819202122232425public boolean remove(Object o) &#123; //如果删除对象为null if (o == null) &#123; //从头开始遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; //找到元素 if (x.item == null) &#123; //从链表中移除找到的元素 unlink(x); return true; &#125; &#125; &#125; else &#123; //从头开始遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; //找到元素 if (o.equals(x.item)) &#123; //从链表中移除找到的元素 unlink(x); return true; &#125; &#125; &#125; return false; &#125;当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。unlink(Nodex) 方法：123456789101112131415161718192021222324252627E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next;//得到后继节点 final Node&lt;E&gt; prev = x.prev;//得到前驱节点 //删除前驱指针 if (prev == null) &#123; first = next;//如果删除的节点是头节点,令头节点指向该节点的后继节点 &#125; else &#123; prev.next = next;//将前驱节点的后继节点指向后继节点 x.prev = null; &#125; //删除后继指针 if (next == null) &#123; last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点 &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125;remove(int index)：删除指定位置的元素123456public E remove(int index) &#123; //检查index范围 checkElementIndex(index); //将节点删除 return unlink(node(index)); &#125;LinkedList类常用方法测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package list;import java.util.Iterator;import java.util.LinkedList;public class LinkedListDemo &#123; public static void main(String[] srgs) &#123; //创建存放int类型的linkedList LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); /************************** linkedList的基本操作 ************************/ linkedList.addFirst(0); // 添加元素到列表开头 linkedList.add(1); // 在列表结尾添加元素 linkedList.add(2, 2); // 在指定位置添加元素 linkedList.addLast(3); // 添加元素到列表结尾 System.out.println("LinkedList（直接输出的）: " + linkedList); System.out.println("getFirst()获得第一个元素: " + linkedList.getFirst()); // 返回此列表的第一个元素 System.out.println("getLast()获得第最后一个元素: " + linkedList.getLast()); // 返回此列表的最后一个元素 System.out.println("removeFirst()删除第一个元素并返回: " + linkedList.removeFirst()); // 移除并返回此列表的第一个元素 System.out.println("removeLast()删除最后一个元素并返回: " + linkedList.removeLast()); // 移除并返回此列表的最后一个元素 System.out.println("After remove:" + linkedList); System.out.println("contains()方法判断列表是否包含1这个元素:" + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true System.out.println("该linkedList的大小 : " + linkedList.size()); // 返回此列表的元素个数 /************************** 位置访问操作 ************************/ System.out.println("-----------------------------------------"); linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素 System.out.println("After set(1, 3):" + linkedList); System.out.println("get(1)获得指定位置（这里为1）的元素: " + linkedList.get(1)); // 返回此列表中指定位置处的元素 /************************** Search操作 ************************/ System.out.println("-----------------------------------------"); linkedList.add(3); System.out.println("indexOf(3): " + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引 System.out.println("lastIndexOf(3): " + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引 /************************** Queue操作 ************************/ System.out.println("-----------------------------------------"); System.out.println("peek(): " + linkedList.peek()); // 获取但不移除此列表的头 System.out.println("element(): " + linkedList.element()); // 获取但不移除此列表的头 linkedList.poll(); // 获取并移除此列表的头 System.out.println("After poll():" + linkedList); linkedList.remove(); System.out.println("After remove():" + linkedList); // 获取并移除此列表的头 linkedList.offer(4); System.out.println("After offer(4):" + linkedList); // 将指定元素添加到此列表的末尾 /************************** Deque操作 ************************/ System.out.println("-----------------------------------------"); linkedList.offerFirst(2); // 在此列表的开头插入指定的元素 System.out.println("After offerFirst(2):" + linkedList); linkedList.offerLast(5); // 在此列表末尾插入指定的元素 System.out.println("After offerLast(5):" + linkedList); System.out.println("peekFirst(): " + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素 System.out.println("peekLast(): " + linkedList.peekLast()); // 获取但不移除此列表的第一个元素 linkedList.pollFirst(); // 获取并移除此列表的第一个元素 System.out.println("After pollFirst():" + linkedList); linkedList.pollLast(); // 获取并移除此列表的最后一个元素 System.out.println("After pollLast():" + linkedList); linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头） System.out.println("After push(2):" + linkedList); linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素） System.out.println("After pop():" + linkedList); linkedList.add(3); linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表） System.out.println("After removeFirstOccurrence(3):" + linkedList); linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从尾部到头部遍历列表） System.out.println("After removeFirstOccurrence(3):" + linkedList); /************************** 遍历操作 ************************/ System.out.println("-----------------------------------------"); linkedList.clear(); for (int i = 0; i &lt; 100000; i++) &#123; linkedList.add(i); &#125; // 迭代器遍历 long start = System.currentTimeMillis(); Iterator&lt;Integer&gt; iterator = linkedList.iterator(); while (iterator.hasNext()) &#123; iterator.next(); &#125; long end = System.currentTimeMillis(); System.out.println("Iterator：" + (end - start) + " ms"); // 顺序遍历(随机遍历) start = System.currentTimeMillis(); for (int i = 0; i &lt; linkedList.size(); i++) &#123; linkedList.get(i); &#125; end = System.currentTimeMillis(); System.out.println("for：" + (end - start) + " ms"); // 另一种for循环遍历 start = System.currentTimeMillis(); for (Integer i : linkedList) ; end = System.currentTimeMillis(); System.out.println("for2：" + (end - start) + " ms"); // 通过pollFirst()或pollLast()来遍历LinkedList LinkedList&lt;Integer&gt; temp1 = new LinkedList&lt;&gt;(); temp1.addAll(linkedList); start = System.currentTimeMillis(); while (temp1.size() != 0) &#123; temp1.pollFirst(); &#125; end = System.currentTimeMillis(); System.out.println("pollFirst()或pollLast()：" + (end - start) + " ms"); // 通过removeFirst()或removeLast()来遍历LinkedList LinkedList&lt;Integer&gt; temp2 = new LinkedList&lt;&gt;(); temp2.addAll(linkedList); start = System.currentTimeMillis(); while (temp2.size() != 0) &#123; temp2.removeFirst(); &#125; end = System.currentTimeMillis(); System.out.println("removeFirst()或removeLast()：" + (end - start) + " ms"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java HashMap 简介]]></title>
    <url>%2F2019%2F08%2F21%2F821-2%2F</url>
    <content type="text"><![CDATA[本文转自JavaGuideHashMap 简介HashMap 主要用来存放键值对，它基于哈希表的Map接口实现&lt;/font&gt;，是常用的Java集合之一。JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。底层数据结构分析JDK1.8之前JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。JDK 1.8 HashMap 的 hash 方法源码:JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。1234567 static final int hash(Object key) &#123; int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;对比一下 JDK1.7的 HashMap 的 hash 方法源码.12345678static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。JDK1.8之后相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。类的属性：12345678910111213141516171819202122232425262728public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 序列号 private static final long serialVersionUID = 362498820763181265L; // 默认的初始容量是16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认的填充因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于这个值时会转成红黑树 static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂次倍 transient Node&lt;k,v&gt;[] table; // 存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; // 加载因子 final float loadFactor;&#125;loadFactor加载因子loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。thresholdthreshold = capacity * loadFactor，当Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。Node节点类源码:123456789101112131415161718192021222324252627282930313233343536373839// 继承自 Map.Entry&lt;K,V&gt;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较 final K key;//键 V value;//值 // 指向下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; // 重写hashCode()方法 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 重写 equals() 方法 public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125;树节点类源码:12345678910111213141516static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // 父 TreeNode&lt;K,V&gt; left; // 左 TreeNode&lt;K,V&gt; right; // 右 TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; // 判断颜色 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // 返回根节点 final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125;HashMap源码分析构造方法123456789101112131415161718192021222324252627// 默认构造函数。public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; // 包含另一个“Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);//下面会分析到这个方法 &#125; // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125;putMapEntries方法：123456789101112131415161718192021222324final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; // 判断table是否已经初始化 if (table == null) &#123; // pre-size // 未初始化，s为m的实际元素个数 float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算得到的t大于阈值，则初始化阈值 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 已初始化，并且m元素个数大于阈值，进行扩容处理 else if (s &gt; threshold) resize(); // 将m中的所有元素添加至HashMap中 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125;put方法HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。对putVal方法添加元素的分析如下：①如果定位到的数组位置没有元素 就直接插入。②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table未初始化或者长度为0，进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素 else &#123; Node&lt;K,V&gt; e; K k; // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 将第一个元素赋值给e，用e来记录 e = p; // hash值不相等，即key不相等；为红黑树结点 else if (p instanceof TreeNode) // 放入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 为链表结点 else &#123; // 在链表最末插入结点 for (int binCount = 0; ; ++binCount) &#123; // 到达链表的尾部 if ((e = p.next) == null) &#123; // 在尾部插入新结点 p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 跳出循环 break; &#125; // 判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 相等，跳出循环 break; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 p = e; &#125; &#125; // 表示在桶中找到key值、hash值与插入元素相等的结点 if (e != null) &#123; // 记录e的value V oldValue = e.value; // onlyIfAbsent为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //用新值替换旧值 e.value = value; // 访问后回调 afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // 结构性修改 ++modCount; // 实际大小大于阈值则扩容 if (++size &gt; threshold) resize(); // 插入后回调 afterNodeInsertion(evict); return null;&#125;我们再来对比一下 JDK1.7 put方法的代码对于put方法的分析如下：①如果定位到的数组位置没有元素 就直接插入。②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。12345678910111213141516171819202122public V put(K key, V value) if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 先遍历 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); // 再插入 return null;&#125;get方法12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 数组元素相等 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一个节点 if ((e = first.next) != null) &#123; // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在链表中get do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125;resize方法进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125;HashMap常用方法测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package map;import java.util.Collection;import java.util.HashMap;import java.util.Set;public class HashMapDemo &#123; public static void main(String[] args) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 键不能重复，值可以重复 map.put("san", "张三"); map.put("si", "李四"); map.put("wu", "王五"); map.put("wang", "老王"); map.put("wang", "老王2");// 老王被覆盖 map.put("lao", "老王"); System.out.println("-------直接输出hashmap:-------"); System.out.println(map); /** * 遍历HashMap */ // 1.获取Map中的所有键 System.out.println("-------foreach获取Map中所有的键:------"); Set&lt;String&gt; keys = map.keySet(); for (String key : keys) &#123; System.out.print(key+" "); &#125; System.out.println();//换行 // 2.获取Map中所有值 System.out.println("-------foreach获取Map中所有的值:------"); Collection&lt;String&gt; values = map.values(); for (String value : values) &#123; System.out.print(value+" "); &#125; System.out.println();//换行 // 3.得到key的值的同时得到key所对应的值 System.out.println("-------得到key的值的同时得到key所对应的值:-------"); Set&lt;String&gt; keys2 = map.keySet(); for (String key : keys2) &#123; System.out.print(key + "：" + map.get(key)+" "); &#125; /** * 另外一种不常用的遍历方式 */ // 当我调用put(key,value)方法的时候，首先会把key和value封装到 // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取 // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来 // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了 Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet(); for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123; System.out.println(entry.getKey() + "--" + entry.getValue()); &#125; /** * HashMap其他常用方法 */ System.out.println("after map.size()："+map.size()); System.out.println("after map.isEmpty()："+map.isEmpty()); System.out.println(map.remove("san")); System.out.println("after map.remove()："+map); System.out.println("after map.get(si)："+map.get("si")); System.out.println("after map.containsKey(si)："+map.containsKey("si")); System.out.println("after containsValue(李四)："+map.containsValue("李四")); System.out.println(map.replace("si", "李四2")); System.out.println("after map.replace(si, 李四2):"+map); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java ArrayList 源码分析]]></title>
    <url>%2F2019%2F08%2F21%2F821-1%2F</url>
    <content type="text"><![CDATA[本文转自JavaGuide,并加入了自己的部分见解ArrayList简介ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为O（n）,求表长以及增加元素，取第 i 元素的时间复杂度为O（1）ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。ArrayList 实现了RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，能被克隆。ArrayList 实现java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。ArrayList核心源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * 空数组（用于空实例）。 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //用于默认大小空实例的共享空数组实例。 //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存ArrayList数据的数组 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList 所包含的元素个数 */ private int size; /** * 带初始容量参数的构造函数。（用户自己指定容量） */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; //创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; //创建空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; /** *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10 */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; // elementData = c.toArray(); //如果指定集合元素个数不为0 if ((size = elementData.length) != 0) &#123; // c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断， //这里用到了反射里面的getClass()方法 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 用空数组代替 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; /** * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125;//下面是ArrayList的扩容机制//ArrayList的扩容机制提高了性能，如果每次只扩充一个，//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。 /** * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量 * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; //得到最小扩容量 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取默认的容量和传入参数的较大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; //判断是否需要扩容 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); &#125; /** * 要分配的最大数组大小,至于为什么-8，原注释如下： * * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * ArrayList扩容的核心方法。 */ private void grow(int minCapacity) &#123; // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //再检查新容量是否超出了ArrayList所定义的最大容量， //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE， //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; //比较minCapacity和 MAX_ARRAY_SIZE private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** *返回此列表中的元素数。 */ public int size() &#123; return size; &#125; /** * 如果此列表不包含元素，则返回 true 。 */ public boolean isEmpty() &#123; //注意=和==的区别 return size == 0; &#125; /** * 如果此列表包含指定的元素，则返回true 。 */ public boolean contains(Object o) &#123; //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 return indexOf(o) &gt;= 0; &#125; /** *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 *这里表明 ArrayList 可存入 null 值 */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) //equals()方法比较 if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。. */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） */ public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // 这不应该发生，因为我们是可以克隆的 throw new InternalError(e); &#125; &#125; /** *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。 *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。 */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。 *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） */ @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // 新建一个运行时类型的数组，但是ArrayList数组的内容 return (T[]) Arrays.copyOf(elementData, size, a.getClass()); //调用System提供的arraycopy()方法实现数组之间的复制 System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // Positional Access Operations @SuppressWarnings("unchecked") E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 返回此列表中指定位置的元素。 */ public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; /** * 用指定的元素替换此列表中指定位置的元素。 */ public E set(int index, E element) &#123; //对index进行界限检查 rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; //返回原来在这个位置的元素 return oldValue; &#125; /** * 将指定的元素追加到此列表的末尾。 */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! //这里看到ArrayList添加元素的实质就相当于为数组赋值 elementData[size++] = e; return true; &#125; /** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work //从列表中删除的元素 return oldValue; &#125; /** * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。 *返回true，如果此列表包含指定的元素 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * 从列表中删除所有元素。 */ public void clear() &#123; modCount++; // 把数组中所有的元素的值设为null for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; /** * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; /** * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。 *将任何后续元素移动到左侧（减少其索引）。 */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; /** * 检查给定的索引是否在范围内。 */ private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * add和addAll使用的rangeCheck的一个版本 */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 返回IndexOutOfBoundsException细节信息 */ private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+size; &#125; /** * 从此列表中删除指定集合中包含的所有元素。 */ public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); //如果此列表被修改则返回true return batchRemove(c, false); &#125; /** * 仅保留此列表中包含在指定集合中的元素。 *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 */ public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; /** * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 *返回的列表迭代器是fail-fast 。 */ public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index); return new ListItr(index); &#125; /** *返回列表中的列表迭代器（按适当的顺序）。 *返回的列表迭代器是fail-fast 。 */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** *以正确的顺序返回该列表中的元素的迭代器。 *返回的迭代器是fail-fast 。 */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125;ArrayList源码分析System.arraycopy()和Arrays.copyOf()方法通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面add(int index, E element)方法就很巧妙的用到了arraycopy()方法让数组自己复制自己实现让index开始之后的所有成员后移一个位置:123456789101112131415/** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()方法实现数组自己复制自己 //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量； System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;又如toArray()方法中用到了copyOf()方法12345678910/** *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。 *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。 */public Object[] toArray() &#123;//elementData：要复制的数组；size：要复制的长度 return Arrays.copyOf(elementData, size);&#125;两者联系与区别联系：看两者源代码可以发现copyOf()内部调用了System.arraycopy()方法区别：arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置copyOf()是系统自动在内部新建一个数组，并返回该数组。ArrayList 核心扩容技术1234567891011121314151617181920212223242526272829303132333435363738//下面是ArrayList的扩容机制//ArrayList的扩容机制提高了性能，如果每次只扩充一个，//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。 /** * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量 * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; //得到最小扩容量 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取默认的容量和传入参数的较大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; //判断是否需要扩容,上面两个方法都要调用 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。 //这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1 if (minCapacity - elementData.length &gt; 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); &#125;12345678910111213141516171819202122/** * ArrayList扩容的核心方法。 */private void grow(int minCapacity) &#123; //elementData为保存ArrayList数据的数组 ///elementData.length求数组长度elementData.size是求数组中的元素个数 // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //再检查新容量是否超出了ArrayList所定义的最大容量， //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE， //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：移位运算符简介：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:&lt;&lt;(左移)、&gt;&gt;(带符号右移)和&gt;&gt;&gt;(无符号右移)。作用：对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源比如这里：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。另外需要注意的是：java 中的length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.java 中的length()方法是针对字 符串String说的,如果想看这个字符串的长度则用到 length()这个方法..java 中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!内部类1234(1)private class Itr implements Iterator&lt;E&gt; (2)private class ListItr extends Itr implements ListIterator&lt;E&gt; (3)private class SubList extends AbstractList&lt;E&gt; implements RandomAccess (4)static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt;ArrayList有四个内部类，其中的Itr是实现了Iterator接口，同时重写了里面的hasNext()， next()， remove() 等方法；其中的ListItr 继承 Itr，实现了ListIterator接口，同时重写了hasPrevious()， nextIndex()， previousIndex()， previous()， set(E e)， add(E e) 等方法，所以这也可以看出了 Iterator和ListIterator的区别: ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。 ArrayList经典Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package list;import java.util.ArrayList;import java.util.Iterator;public class ArrayListDemo &#123; public static void main(String[] srgs)&#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); System.out.printf("Before add:arrayList.size() = %d\n",arrayList.size()); arrayList.add(1); arrayList.add(3); arrayList.add(5); arrayList.add(7); arrayList.add(9); System.out.printf("After add:arrayList.size() = %d\n",arrayList.size()); System.out.println("Printing elements of arrayList"); // 三种遍历方式打印元素 // 第一种：通过迭代器遍历 System.out.print("通过迭代器遍历:"); Iterator&lt;Integer&gt; it = arrayList.iterator(); while(it.hasNext())&#123; System.out.print(it.next() + " "); &#125; System.out.println(); // 第二种：通过索引值遍历 System.out.print("通过索引值遍历:"); for(int i = 0; i &lt; arrayList.size(); i++)&#123; System.out.print(arrayList.get(i) + " "); &#125; System.out.println(); // 第三种：for循环遍历 System.out.print("for循环遍历:"); for(Integer number : arrayList)&#123; System.out.print(number + " "); &#125; // toArray用法 // 第一种方式(最常用) Integer[] integer = arrayList.toArray(new Integer[0]); // 第二种方式(容易理解) Integer[] integer1 = new Integer[arrayList.size()]; arrayList.toArray(integer1); // 抛出异常，java不支持向下转型 //Integer[] integer2 = new Integer[arrayList.size()]; //integer2 = arrayList.toArray(); System.out.println(); // 在指定位置添加元素 arrayList.add(2,2); // 删除指定位置上的元素 arrayList.remove(2); // 删除指定元素 arrayList.remove((Object)3); // 判断arrayList是否包含5 System.out.println("ArrayList contains 5 is: " + arrayList.contains(5)); // 清空ArrayList arrayList.clear(); // 判断ArrayList是否为空 System.out.println("ArrayList is empty: " + arrayList.isEmpty()); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么Java中只有值专递]]></title>
    <url>%2F2019%2F08%2F21%2F821%2F</url>
    <content type="text"><![CDATA[本文转自JavaGuide一 为什么 Java 中只有值传递？首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。下面通过 3 个例子来给大家说明example 1123456789101112131415161718public static void main(String[] args) &#123; int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println("num1 = " + num1); System.out.println("num2 = " + num2);&#125;public static void swap(int a, int b) &#123; int temp = a; a = b; b = temp; System.out.println("a = " + a); System.out.println("b = " + b);&#125;结果：1234a = 20b = 10num1 = 10num2 = 20解析：在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.example 21234567891011public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; System.out.println(arr[0]); change(arr); System.out.println(arr[0]);&#125;public static void change(int[] array) &#123; // 将数组的第一个元素变为0 array[0] = 0;&#125;结果：1210解析：array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。example 312345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Student s1 = new Student("小张"); Student s2 = new Student("小李"); Test.swap(s1, s2); System.out.println("s1:" + s1.getName()); System.out.println("s2:" + s2.getName()); &#125; public static void swap(Student x, Student y) &#123; Student temp = x; x = y; y = temp; System.out.println("x:" + x.getName()); System.out.println("y:" + y.getName()); &#125;&#125;结果：1234x:小李y:小张s1:小张s2:小李解析：交换之前：交换之后：通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝总结Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。下面再总结一下Java中方法参数的使用情况：一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。一个方法可以改变一个对象参数的状态。一个方法不能让对象参数引用一个新的对象。参考：《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节二 ==与equals(重要)== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。举个例子：1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String("ab"); // a 为一个引用 String b = new String("ab"); // b为另一个引用,对象的内容一样 String aa = "ab"; // 放在常量池中 String bb = "ab"; // 从常量池中查找 if (aa == bb) // true System.out.println("aa==bb"); if (a == b) // false，非同一对象 System.out.println("a==b"); if (a.equals(b)) // true System.out.println("aEQb"); if (42 == 42.0) &#123; // true System.out.println("true"); &#125; &#125;&#125;说明：String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。三 hashCode与equals（重要）面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”hashCode（）介绍hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。1234567891011121314151617/** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * &#123;@link java.util.HashMap&#125;. * &lt;p&gt; * As much as is reasonably practical, the hashCode method defined by * class &#123;@code Object&#125; does return distinct integers for distinct * objects. (This is typically implemented by converting the internal * address of the object into an integer, but this implementation * technique is not required by the * Java&amp;trade; programming language.) * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */public native int hashCode();散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）为什么要有hashCode我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。hashCode（）与equals（）的相关规定如果两个对象相等，则hashcode一定也是相同的两个对象相等,对两个对象分别调用equals方法都返回true两个对象有相同的hashcode值，它们也不一定是相等的因此，equals方法被覆盖过，则hashCode方法也必须被覆盖hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）为什么两个对象有相同的hashcode值，它们也不一定是相等的？在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http学习笔记(一)]]></title>
    <url>%2F2019%2F08%2F19%2F819%2F</url>
    <content type="text"><![CDATA[HTTP概念：Hyper Text Transfer Protocol 超文本传输协议概述: HTTP是一个客户端（用户）和服务端（网站）之间请求和应答的标准，通常使用TCP协议。通过使用网页浏览器、网络爬虫或者其它的工具，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。传输协议：定义了，客户端和服务器端通信时，发送数据的格式特点：基于TCP/IP的高级协议默认端口号:80基于请求/响应模型的:一次请求对应一次响应无状态的：每次请求之间相互独立，不能交互数据历史版本：1.0：每一次请求响应都会建立新的连接(多用于代理服务器)1.1：默认采用持久连接,同时支持以管道方式同时发送多个请求2.0:压缩 Header(HPACK算法)单一长连接多路复用缓存推送请求消息数据格式请求行请求方式 请求url 请求协议/版本GET /login.html HTTP/1.1请求方式：HTTP协议有7中请求方式，常用的有2种GET：请求参数在请求行中，在url后。请求的url长度有限制的不太安全POST：请求参数在请求体中请求的url长度没有限制的相对安全请求头：客户端浏览器告诉服务器一些信息请求头名称: 请求头值常见的请求头：1234567891011121314151617181920212223#浏览器接受的数据类型Accept: text/html,image/*#浏览器接受的编码格式Accept-Charset: ISO-8859-1#浏览器接受的数据压缩格式Accept-Encoding: gzip,compress#浏览器接受的语言Accept-Language: en-us,zh- #（必须的）当前请求访问的目标地址(主机:端口）Host: www.bestsort.cn:80 #浏览器最后的缓存时间If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT# 当前请求来自于哪里 Referer: http://www.bestsort.cn/index.html #浏览器类型User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36(KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36 # 浏览器保存的cookie信息Cookie:name=eric # 浏览器跟服务器连接状态。close: 连接关闭 keep-alive：保存连接。Connection: close/Keep-Alive # 请求发出的时间Date: Tue, 11 Jul 2000 18:23:51 GMT请求空行空行，就是用于分割POST请求的请求头，和请求体的。请求体(正文)：封装POST请求消息的请求参数的状态码1xx:消息——请求已被服务器接收，继续处理2xx:成功——请求已成功被服务器接收、理解、并接受3xx:重定向——需要后续操作才能完成这一请求4xx:请求错误——请求含有词法错误或者无法被执行5xx:服务器错误——服务器在处理某个正确请求时发生错误字符串格式：POST /login.html HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,-/-;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost/login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1username=zhangsan响应消息数据格式]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java BigInteger 和 BigDecimal 在 ACM 中的应用]]></title>
    <url>%2F2019%2F08%2F10%2F810%2F</url>
    <content type="text"><![CDATA[开头首先,有几点需要注意的名词大致对应关系(Java —&gt; C的对应关系,单纯针对没学过C++的同学,学过C++可无视)方法 —&gt; 函数成员变量 —&gt; 变量一个xxx对象 —&gt; 一个xxx结构体变量 + 处理这个变量的函数集合xxx的成员函数 —&gt; 可以对xxx结构体内的变量进行操作的一类函数在 ACM 中提交 Java 的类名必须是 Main,且不包含包名.一般来说 Java 提交的代码格式都是这样123456789//常用的工具类,包括输入等import java.util.*;import java.math.*;public class Main &#123; public static void main(String[] args) &#123; //blablabla... &#125;&#125;而大数处理就需要用到 java.math 中的 BigInteger类 和BigDecimal类. 其中,BigInteger用于处理大整数, BigDecimal 用于处理浮点数在 Java 中,你完全可以使用 C/C++ 的语法,但是要注意一点: bool类型在 Java 中是Boolean,而且不能用0,1一类的数值赋值,只能用 true/false.如下:12345public class Main &#123; public static void main(String[] args) &#123; Boolean flag = false; &#125;&#125;对于基本型变量(int,char,byte,float一类),在 Java 中是值传递的(对比 C/C++中的 = 号).但是对于对象却是用的引用传递(类似指针的一个东西)也就是说在对象中,对于对象的赋值最好不直接用 = 进行赋值,而是用自己写的方法(如BigInteger中的13-15行)进行赋值.因为在某个版本的库中如果返回的不是一个 new 的对象的话就相当于 C/C++ 中2个指针指向了同一处地址通用比较BigInteger 和 BigDecimal的数值比较都需要用到 compareTo 方法.需要注意的是,该方法返回的是 int 类型.也就是说不能用if(a.compareTo(b))的形式.(前面讲过int不能用于对Boolean赋值,所以不能将其隐式转换为Boolean)通常,我们都用以下语句进行判断1if(x.compareTo(y) &lt;op&gt; 0)//其中 &lt;op&gt; 是六个比较运算符之一,如 &gt;, &lt;, =。示例1234567891011121314151617import java.math.BigDecimal;public class Main &#123; public static void main(String[] args) &#123; BigDecimal a = new BigDecimal("1.1111111112"); BigDecimal b = new BigDecimal("1.1111111111"); if(a.compareTo(b) &gt; 0)&#123; System.out.println("a &gt; b"); &#125; else if (a.compareTo(b) == 0)&#123; System.out.println("a==b"); &#125; else &#123; System.out.println("a &lt; b"); &#125; &#125;&#125;BigInteger12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @ClassName @&#123;Name&#125; * @Description BigInteger的简单使用 * @Author bestsort * @Date 19-8-10 上午8:11 * @Version 1.0 */import java.math.*;import java.util.*;public class Main &#123; public static BigInteger get(BigInteger num)&#123; return num; &#125; public static void main(String[] args) &#123; //单个大数,记得初始化为null BigInteger a = null; BigInteger b = null; //自定义数值, new 一个 BigInteger 对象并初始化为1 System.out.println("-----自定义数值初始化-----"); BigInteger c = new BigInteger("1"); BigInteger d = BigInteger.valueOf(1); System.out.println(c); System.out.println(d); //BigInteger 静态成员,不可修改(可大致对比 C/C++ 中的全局变量+ const,使用时不用新 new 一个BigInteger对象) System.out.println("-----内置数如下-----"); System.out.println(BigInteger.ZERO); System.out.println(BigInteger.ONE); System.out.println(BigInteger.TWO); System.out.println(BigInteger.TEN); //控制台读入 Scanner in = new Scanner(System.in); //当输入不为EOF的时候持续读入,ctrl + D 结束输入 while (in.hasNext())&#123; a =in.nextBigInteger(); b = in.nextBigInteger(); &#125; //加 BigInteger res = a.add(b); //在 Java 中,可以用 '+' 拼接字符串.不是字符串的对象会自动调用 toString 方法将其转为字符串 System.out.println("加法结果是" + res); //减 res = a.subtract(b); System.out.println("减法结果是"+res); //乘 res = a.multiply(b); System.out.println("乘法结果是"+res); //除 ,会略去小数位(相当于整数除法),不建议使用 res = a.divide(res); System.out.println("除法结果是"+res); System.out.println("用 get 赋值"); BigInteger buf = new BigInteger("23"); a = get(buf); System.out.println("赋值后a的值:"+ a); //改一下 buf 的值后再看一下 a 的值 buf = buf.add(res); System.out.println("更改buf后a的值:"+a); System.out.println("buf的值" + buf); //讲 a 转成 int int va = a.intValue(); System.out.println(va); &#125;&#125;BigDecimal1234567891011121314151617181920212223242526272829303132333435/** * @ClassName Main * @Description TODO * @Author bestsort * @Date 19-8-10 上午9:59 * @Version 1.0 */package domain;import java.math.BigDecimal;import java.math.RoundingMode;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; //两种创建方法,不推荐第一种,可能会出现精度问题 BigDecimal a = BigDecimal.valueOf(0.555); String val = "12.21321321312"; BigDecimal b = new BigDecimal(val); //加减乘和BigInteger一样,不赘述了.主要说说除法 /*BigDecimal 在执行除法的时候需要手动指定精度和舍入 *不然当除不尽的时候会抛出异常 * * 2 表示精确到小数点后第20位,RoundingMode.HALF_DOWN表示多余的位置四舍五入 * 此外还有其他舍入模式可参考 http://itmyhome.com/java-api/ 的BigDecimal部分 * */ BigDecimal res = a.divide(b,20, RoundingMode.HALF_DOWN); BigDecimal s = new BigDecimal(0.005); System.out.println(s.divide(BigDecimal.ONE,2,RoundingMode.HALF_DOWN)); System.out.println(res); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deepin 优化指南]]></title>
    <url>%2F2019%2F08%2F08%2F890%2F</url>
    <content type="text"><![CDATA[最近把本子里的 win10 给拆了装上了 deepin。不得不说 deepin 特效全开真的很帅，可以点这里查看演示 不过装的时候还是费心费力了一番。不过好在 Linux 下装开发工具非常便利，时间上大概和 win10 打成平手（虽然当初装 win10 很快但是各种开发环境就差不多搞掉了我一个下午时间）这里把安装 deepin 的一些坑说一下。 不过在这之前，，可以看一下深度操作系统新手指引（FAQ） ，这里面能解决很多问题笔记本 WiFi 模块失效命令行执行sudo vim /etc/modprobe.d/ideapad.conf,然后在第一行按 i 输入以下内容1blacklist ideapad_laptop按 ESC 再输入wq 保存并退出。然后执行sudo modprobe -r ideapad_laptop。不出意外的话 WiFi 模块就能正常工作了当然，这只是针对 联想R720 的机器，其他的可以用 lsmod 查看是否有ideapad_laptop这个模块安装VSCode后，默认打开变为VSCode装了VSCode后，你会发现所有的在文件夹内打开都成了在VSCode内打开。这时候，需要执行xdg-mime default dde-file-manager.desktop inode/directory.部分快捷命令无法使用这里因为 Deepin 将其注释掉了，重新添加即可12345678echo 'alias tailf="tail -f -n"' &gt;&gt; /etc/bash.bashrcecho 'alias ls="ls --color=auto"' &gt;&gt; /etc/bash.bashrcecho 'alias ll="ls -alF"' &gt;&gt; /etc/bash.bashrcecho 'alias grep="grep --color=auto"' &gt;&gt; /etc/bash.bashrcecho 'alias egrep="grep --color=auto"' &gt;&gt; /etc/bash.bashrcecho 'export TERM="xterm-256color"' &gt;&gt; /etc/bash.bashrcecho '[[ $&#123;TMUX&#125; != "" ]] &amp;&amp; export TERM="screen-256color"' &gt;&gt; /etc/bash.bashrcsource /etc/bash.bashrc官方软件下载太慢官方的服务器估计跟育碧一样都是土豆做的，网速极慢，永远跑不到带宽峰值。这时候就可以把官方源换成镜像源了，这里我用的是清华大学的源sudo vim /etc/apt/sources.list然后将里面的内容改成如下123456## Generated by deepin-installer##deb [by-hash=force] http://packages.deepin.com/deepin lion main contrib non-free#deb-src http://packages.deepin.com/deepin lion main contrib non-free## Generated by deepin-installerdeb [by-hash=force] http://mirrors.tuna.tsinghua.edu.cn/deepin lion main contrib non-free#deb-src http://mirrors.ustc.edu.cn/deepin panda main contrib non-free至于是 lion 还是 panda 根据自己官方源的链接修改这里有个比较坑的就是，深度的软件清华大学的源里好像没有，反正得把官方源打开才能更新深度系列的软件将 home 目录挂载到机械硬盘因为我是 SSD + 机械硬盘，所以系统仍在SSD里了，这里我想把我的数据和系统盘分开.假设新增磁盘的设备文件名为 /dev/vdb 大小为100GB。1sudo fdisk -l 查看新增的的磁盘1、对新增磁盘进行分区1sudo fdisk /dev/vdb按提示操作 p打印 n新增 d 删除 w操作生效 q退出操作后 w1sudo partprobe 强制让内核重新找一次分区表（更新分区表）这里我们新增一个分区 /dev/vdb1 大小为40GB2、分区格式化1sudo mkfs -t ext4 /dev/vdb1 格式化为ext4格式3、将新硬盘临时挂载在一个目录下12345678#cd /mnt/#mkdir home#mount /dev/vdb1 /mnt/home 挂载到/mnt/home#df -h 查看#cp -a /home/* /mnt/home/ 把home下的东西拷到挂载的目录下，备份#rm -rf /home/* 把home下的东西删干净#umount /dev/vdb1 卸载硬盘#df -h 查看4、设置开机挂载1sudo vim /etc/fstab末尾增加一行/dev/vdb1 /home ext4 defaults 1 2保存退出1234#df -h 查看 /home是否被挂载#mount -a 挂载/etc/fstab 中未挂载的分区#df -h 查看当然，如果你硬盘直接被手动格式化并且文件系统为ext4了的话,直接从第三步执行即可显卡可能出现的问题这个问题很奇怪，我重装了3次都没有复现这个 BUG…在 deepin 中有一个显卡驱动管理器，如果是 I+N 双显卡的话最好切换为使用Prime方案,但是这软件容易抽风，我的就找不到Prime方案…所以我手动装的驱动.先去官网下载显卡对应的驱动.放在主目录即可.然后是禁用开源的 nouveau（bug超多的NVIDA驱动）.sudo vim /etc/modprobe.d/blacklist.conf然后在里面加上一行blacklist nouveau。再执行sudo update-initramfs -u.重启电脑，如果执行lsmod | grep nouveau没有输出则代表 nouveau 已被禁用sudo telinit 3进入命令行界面，假设刚刚下载的驱动为xxxxx.run执行12sudo chmod a+x xxxxx.runsudo sh ./xxxxx.run -no-opengl-files一路 YES 即可.需注意提示内容，如果显示无法安装 KMDS（好像是这个，忘了）的话，重新安装一遍，然后在安装KMDS那里选择 No 即可最后的最后经过这几天的折腾,说实话不推荐使用 Deepin. 除了 UI 炫酷 + 一些工具好用以外 Bug 也不少.还是推荐在 Ubuntu18.04 上安装 Deepin桌面环境好一点.]]></content>
      <categories>
        <category>VPS玩机</category>
      </categories>
      <tags>
        <tag>Deppin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记 --事务]]></title>
    <url>%2F2019%2F08%2F06%2F86%2F</url>
    <content type="text"><![CDATA[事务特性事务主要是用于处理并发和从错误状态回滚到正常状态的一个操作,对于事务,有个很经典的例子:A 打算给 B 转 200元, 则在数据库中应该进行的操作应该是下面这样:A 账户余额-200元;B 账户余额+200元;但是如果这两条是分别执行的话, 万一 1 和 2 之间出现了什么问题(网络波动啦,临时工写的代码出Bug了啥的),那是不是 A 就白白扣了200元,而这多扣的 200 就离奇失踪了?在这种情况下,就需要事务了.事务可以把这两个操作打包执行,也就是一荣俱荣,一损俱损.如果给 B 账户余额+200失败,则A账户余额-200也就默认失败.换句话说,事务是一个整体,而这也就是事务的原子性(Atomicity)当然事务肯定不止这一个特性,实际上,事务特性共有4个,分别是原子性,一致性,隔离性,持久性,一般都把这四个特性简称为ACID.这些特性描述如下:原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。使用事务SQL国际标准使用START TRANSACTION(或者是BEGIN)开始一个事务。COMMIT语句使事务成功完成。ROLLBACK语句结束事务(回滚)，放弃从START TRANSACTION开始的一切变更。若autocommit被START TRANSACTION的使用禁止，在事务结束时autocommit会重新激活。当然还有一些其他的,比如可以设置标记节点:SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；ROLLBACK TO identifier 把事务回滚到标记点；12345678910--被BEGIN TRANSACTION 和 COMMIT 包裹的 SQL语句 具有ACID特性 BEGIN;CREATE TABLE IF NOT EXISTS `test1`( id int, num int);INSERT INTO `test1` VALUES(1,2);SELECT * FROM `test1`;COMMIT;隔离级别在讲事务的隔离级别之前,我们需要先了解一下不考虑事务的隔离性可能会出现的异常脏读(Dirty Read):当一个事务读取另一个事务尚未提交的修改时，产生脏读。不可重复读(Nonrepeatable Read):一个事务对同一行数据重复读取两次，但是却得到了不同的结果(在查询间隔中查询内容被另一个事务修改并提交了)幻读(Phantom Reads):事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。丢失修改(Lost Update):当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。而为了兼顾并发效率和异常控制,在SQL标准规范中,提供了四种隔离级别.分别是序列化,可重复读,读已提交,读未提交,详情如下:Serializable (序列化)：可避免脏读、不可重复读、幻读的发生。Repeatable read (可重复读)：可避免脏读、不可重复读的发生。Read committed (读已提交)：可避免脏读的发生。Read uncommitted (读未提交)：最低级别，任何情况都无法保证。换成表格如下(Y表示能避免,N表示不能避免):隔离级别名级别号脏读不可重复读幻读备注Read uncommitted(读未提交)0NNNRead committed (读已提交)1YNN大多数数据库默认的隔离级别Repeatable read(可重复读)2YYNInnoDB默认级别Serializable(序列化)3YYY以上就是级别详情,需要注意的是:隔离级别越高,效率越低.在 MySQL 中,可以使用select @@tx_isolation;查询当前事务的隔离级别,可以用12set [glogal | session] transaction isolation level Read uncommitted/Read committed/Repeatable read/Serializable;set transaction_isolation='read-uncommitted/read-committed/repeatable-read/rerializable';在开启事务前设置事务的四种隔离级别.事务隔离的实现事务隔离可以借助于锁实现. 这里只是大致思路，MySQL具体实现参照[MySQL 5.7 Reference Manual]Read Uncommited事务在读数据时候未对数据加锁事务在修改数据的时候只对数据增加行级共享锁Read Committed事务对当前被读取的数据加行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁事务在更新某数据的瞬间，必须对其加行级排他锁，直到事务结束才释放Repeatable Read事务在读取某数据的瞬间，必须先对其加行级共享锁，直到事务结束才释放事务在更新某数据的时候，必须先对其加行级排他锁，直到事务结束才释放Serializable事务在读取数据时，必须先对其加表级共享锁，直到事务结束才释放事务在更新数据时，必须先对其加表级排他锁，直到事务结束才释放]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记 --注解]]></title>
    <url>%2F2019%2F08%2F05%2F85%2F</url>
    <content type="text"><![CDATA[注解概念：说明程序的。给计算机看的注释：用文字描述程序的。给程序员看的定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。概念描述：JDK1.5之后的新特性说明程序的使用注解：@注解名称作用分类：编写文档：通过代码里标识的注解生成文档【生成文档doc文档】代码分析：通过代码里标识的注解对代码进行分析【使用反射】编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】JDK中预定义的一些注解@Override ：检测被该注解注解的方法是否是继承自父类(接口)的@SuppressWarnings：压制警告一般传递参数all @SuppressWarnings(&quot;all&quot;)内置注解Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中作用在代码的注解@Deprecated：该注解注解的内容，表示已过时@Override - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。@SuppressWarnings - 指示编译器去忽略注解中声明的警告。一般传递参数all @SuppressWarnings(&quot;all&quot;)元注解(元注解的作用就是负责注解其他注解)@Retention - 标识这个注解怎么保存，是只在代码中，还是编入 class 文件中，或者是在运行时可以通过反射访问。@Documented - 标记这些注解是否包含在用户文档中。@Target - 标记这个注解应该是哪种 Java 成员。@Inherited - 标记这个注解是继承于哪个注解类 (默认 注解并没有继承于任何子类)从 Java 7 开始，额外添加了 3 个注解:@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。实例123456789public class Test &#123; private String str; // @Override注解toString()方法。 @Override public String toString() &#123; return "类Test 的 toString 方法被覆写成该方法"; &#125;&#125;自定义注解格式：元注解12345public @interface 注解名称&#123; int age(); //定义一个名为age,数据类型为int的属性 String sex() default "未知";//定义一个默认值为"未知",数据类型为 String 的属性. &#125;本质：注解本质上就是一个接口，该接口默认继承 Annotation 接口public interface 注解名称 extends java.lang.annotation.Annotation {}属性：接口中的抽象方法要求：属性的返回值类型有下列取值基本数据类型String枚举注解以上类型的数组定义了属性，在使用时需要给属性赋值如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略元注解：用于描述注解的注解@Target：描述注解能够作用的位置ElementType取值：TYPE：可以作用于类上METHOD：可以作用于方法上FIELD：可以作用于成员变量上@Retention：描述注解被保留的阶段@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到@Documented：描述注解是否被抽取到api文档中@Inherited：描述注解是否被子类继承在程序使用(解析)注解：获取注解中定义的属性值获取注解定义的位置的对象 （Class，Method,Field）获取指定的注解getAnnotation(Class)//其实就是在内存中生成了一个该注解接口的子类实现对象12345678public class ProImpl implements Pro&#123; public String className()&#123; return "cn.itcast.annotation.Demo1"; &#125; public String methodName()&#123; return "show"; &#125;&#125;调用注解中的抽象方法获取配置的属性值]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分 --不一样的详解]]></title>
    <url>%2F2019%2F07%2F20%2F720%2F</url>
    <content type="text"><![CDATA[欢迎转载,转载请注明来自 bestsort的博客 并保留该超链接算了算自己大大小小也看了不下十几篇关于树链剖分的博客了吧,但是总感觉差强人意,基本上都是一上来就告诉读者我们来先背几个概念,然后就是 轻儿子重儿子重边重链 什么的一股脑全堆上来.但是个人感觉这种方式对初学者并不友好! 笔者不才,打算自己根据对树链剖分的理解重新写一篇真正适合入门的详解这里,笔者打算以 What-How-Why(黄金圈法则) 的方式进行讲解.先知道树链剖分是什么,它有什么用,再去了解它怎么实现,具体原理是什么What树链剖分是什么树链剖分就是将树分割成多条链，然后利用数据结构（线段树、树状数组等）来维护这些链。实际上,这些链是一条条平躺着放在数组里面的How映射的规则上文中说过树链剖分是把树分割成多条链,并将其映射到一维数组当然分割是要讲道理滴!自然要遵循某些规则这里的规则很简单,那就是在一维区间中,对于任意树上结点 x, 则 x 的所有子孙结点都在以 x 为起点的一段连续区间内(当然,树链还有一些其他的约束条件,我们放到后面再说)很难理解?比如说 我有下图这颗树)我们可以构造出下面这些区间,都满足上面的规则.(注意是任意结点 x 都满足规则)12345678#分别对应 [ABDCEF],[BD],[CEF]ABDCEF#[ACEFBD],[CEF],[BD]ACEFBD#[ACFEBD],[CFE],[BD]ACFEBD也就是说映射到最后的结果是:对于任意节点 x, x 和它的子树在区间内一定连续的对于这个规则,我们不难想到,其实就是一个 DFS 的事情(想不通的可以看一下二叉树的前中后序遍历出来的结果).Ok, 现在我们知道了,要用 DFS 将树映射成一维区间.可是遍历顺序有没有影响?有的!而正是因为分割规则的不同,才有长链剖分和重链剖分这两种说法,本文只讲重链剖分.当然不是说长链剖分就没用,两者在不同的场合都有各自的优势,这里不赘述了回到上文,遍历顺序是对最终的复杂度有影响的.这里举一个具体的例子,如下图:有点懒,不想写了….具体的待补充题目链接 先放代码占坑,过几天有空再写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220 #include &lt;bits/stdc++.h&gt;using namespace std;#define mem(a, b) memset(a, b, sizeof a)#define IN freopen("in.txt", "r", stdin)#define DEBUG(a) cout &lt;&lt; (a) &lt;&lt; endltypedef long long ll;int dir8[8][2] = &#123; &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;&#125;;int dir4[4][2] = &#123;1, 0, 0, 1, -1, 0, 0, -1&#125;;const int INF = 0x3f3f3f3f;int mod = 1e9 + 7;const int maxn = 1e6 + 10;struct edge&#123; int next, to; /* data */&#125; e[maxn];int cnt;int head[maxn];void addEdge(int u, int v)&#123; e[++cnt] = &#123;head[u], v&#125;; head[u] = cnt;&#125;struct node&#123; int l, r, flag, w; int dis() &#123; return r - l + 1; &#125; int mid() &#123; return (r + l) / 2; &#125; /* data */&#125; a[maxn];int rt;int cn;int w[maxn];int bufW[maxn];int id[maxn],fa[maxn],top[maxn], son[maxn], dep[maxn], sz[maxn];void dfs1(int u, int f, int deep)&#123; dep[u] = deep; sz[u] = 1; fa[u] = f; int maxSon = -1; for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (v == f) continue; dfs1(v, u, deep + 1); sz[u] += sz[v]; if (sz[v] &gt; maxSon) &#123; son[u] = v; maxSon = sz[v]; &#125; &#125;&#125;void dfs2(int u, int ttop)&#123; id[u] = ++cn; w[cn] = bufW[u]; top[u] = ttop; if (!son[u]) return; dfs2(son[u], ttop); for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (v == fa[u] || v == son[u]) continue; dfs2(v, v); &#125;&#125;void build(int k, int l, int r)&#123; a[k] = &#123;l, r, 0, 0&#125;; if (a[k].l == a[k].r) &#123; a[k].w = w[r]; return; &#125; build(k &lt;&lt; 1, l, (r + l) / 2); build(k &lt;&lt; 1 | 1, (r + l) / 2 + 1, r); a[k].w = a[k &lt;&lt; 1].w + a[k &lt;&lt; 1 | 1].w; a[k].w %= mod;&#125;void down(int k)&#123; a[k &lt;&lt; 1].w += a[k &lt;&lt; 1].dis() * a[k].flag; a[k &lt;&lt; 1 | 1].w += a[k &lt;&lt; 1 | 1].dis() * a[k].flag; a[k &lt;&lt; 1].flag += a[k].flag; a[k &lt;&lt; 1 | 1].flag += a[k].flag; a[k].flag = 0;&#125;void update(int k, int l, int r, int val)&#123; if (a[k].l &gt;= l &amp;&amp; a[k].r &lt;= r) &#123; a[k].w += val * a[k].dis(); a[k].flag += val; return; &#125; if (a[k].flag) down(k); if (a[k].mid() &gt;= l) update(k &lt;&lt; 1, l, r, val); if (a[k].mid() &lt; r) update(k &lt;&lt; 1|1, l, r, val); a[k].w = a[k &lt;&lt; 1].w + a[k &lt;&lt; 1 | 1].w; a[k].w %= mod;&#125;int query(int k, int l, int r)&#123; if (a[k].l &gt;= l &amp;&amp; a[k].r &lt;= r) return a[k].w; int res = 0; if (a[k].flag) down(k); if (a[k].mid() &gt;= l) res += query(k &lt;&lt; 1, l, r); if (a[k].mid() &lt; r) res += query(k &lt;&lt; 1 | 1, l, r); return res % mod;&#125;void updateRange(int p1,int p2,int val)&#123; while (top[p1] != top[p2]) &#123; if(dep[top[p1]] &lt; dep[top[p2]]) swap(p1,p2); update(1,id[top[p1]],id[p1],val); p1 = fa[top[p1]]; &#125; if(dep[p1] &gt; dep[p2]) swap(p1,p2); update(1,id[p1],id[p2],val);&#125;int queryRange(int p1,int p2)&#123; int ans = 0; while (top[p1]!=top[p2]) &#123; if(dep[top[p1]] &lt; dep[top[p2]]) swap(p1,p2); ans += query(1,id[top[p1]],id[p1]); ans %= mod; p1 = fa[top[p1]]; &#125; if(dep[p1] &gt; dep[p2]) swap(p1,p2); return (ans + query(1,id[p1],id[p2]))%mod;&#125;void updateSon(int p,int val)&#123; update(1,id[p],id[p]+sz[p]-1,val);&#125;int querySon(int p)&#123; return query(1,id[p],id[p]+sz[p]-1)%mod; &#125;int main()&#123; //IN; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n,k,m,rt; cin &gt;&gt; n &gt;&gt; m &gt;&gt; rt &gt;&gt; mod; for(int i=1;i&lt;=n;i++) cin &gt;&gt; bufW[i]; int u,v; for(int i=1;i&lt;n;i++)&#123; cin &gt;&gt; u &gt;&gt; v; addEdge(u,v); addEdge(v,u); &#125; dfs1(rt,0,1); dfs2(rt,rt); build(1,1,n); int l, r, w; while (m--) &#123; // debug(n); cin &gt;&gt; k; if (k == 1) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; w; updateRange(l, r, w); &#125; else if (k == 2) &#123; cin &gt;&gt; l &gt;&gt; r; DEBUG(queryRange(l, r)); &#125; else if (k == 3) &#123; cin &gt;&gt; l &gt;&gt; w; updateSon(l, w); &#125; else &#123; cin &gt;&gt; l; DEBUG(querySon(l)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[母函数]]></title>
    <url>%2F2019%2F07%2F19%2F719-1%2F</url>
    <content type="text"><![CDATA[浅谈母函数母函数真是迷人……定义母函数是一个无穷级数：我们把系数提取出来，这个系数序列与母函数存在一一对应的关系，存在双射：$\vec{g} \leftrightarrow G(x)$.举个例子，有母函数$G(x)=1+x+x^2+x^3\cdots$，则与之对应的系数表达就是$1,1,1,1\cdots$.基本运算加减$F(x)+G(x) \leftrightarrow f_0+g_0,f_1+g_1,f_2+g_2\cdots$$F(x)-G(x) \leftrightarrow f_0-g_0,f_1-g_1,f_2-g_2\cdots$数乘$c*G(x) \leftrightarrow c*g_0,c*g_1,c*g_2\cdots$乘幂$x^k*G(x)\leftrightarrow0,0\cdots,0,g_0,g_1\cdots$（前面放上$k$个$0$）卷积$F(x) \times G(x)$，跑FFT做多项式乘法即可。用处这里介绍最简单的用途。你有一些水果，只能拿3的倍数个苹果，只能拿质数个草莓。问对于每个$0&lt;i&lt;=n$，有多少种方案使得恰好拿$i$个水果。我们不妨先造出两个布尔数组，来储存“能不能拿”。苹果：[0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1...]草莓：[0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0...]考虑母函数。我们尝试用$x^k$的系数来表示取$k$个物品的方案数。那么上面的两个布尔数组生成了两个母函数：苹果：$A(x)=x^3+x^6+x^9\cdots$草莓：$B(x)=x^2+x^3+x^5+x^7\cdots$我们把它们乘起来，就会发现一个奇妙的事情：乘积的结果，$x^k$的系数正好表示了取$k$个物品的方案数。为什么会这样？考虑$x^5$的系数。$x^5$可以由$x^0x^5,x^1x^4,x^2x^3,x^3x^2\cdots$来构成，这正好映射了“0个苹果5个草莓、1个苹果4个草莓……”的选取方式。结合FFT，我们就可以在$O(n \log n)$的时间复杂度内求出$0&lt;i&lt;=n$的答案。直接输出卷积即可。高级运算：求导母函数可以求导。效果是把系数左移一位，然后乘上次数。$G(x)\space \space \leftrightarrow \space g_0,g_1,g_2,g_3\cdots$$G’(x)\space \leftrightarrow \space g_1,2g_2,3g_3\cdots$闭形式考虑母函数$1,1,1\cdots$，对其进行等比数列求和：$\displaystyle 1+x+x^2+x^3\cdots = \frac{1}{1-x}$我们称$\frac{1}{1-x}$为母函数$1,1,1\cdots$的闭形式。注意，这里忽略了收敛问题。但是这没有影响，因为我们需要使用的是系数，与$x$的取值始终无关。对母函数的操作等价于对闭形式的操作。例如，我们对$1,1,1\cdots$求导：$\displaystyle G(x)=\frac{1}{1-x}$$\displaystyle G’(x)=\frac{1}{(1-x)^2}$又$G’(x) \leftrightarrow 1,2,3\cdots$（之前已经算出过）故有结论：$\displaystyle \frac{1}{(1-x)^2} \leftrightarrow 1,2,3\cdots$.例题论文题。明明这次又要出去旅游了，和上次不同的是，他这次要去宇宙探险！我们暂且不讨论他有多么NC，他又幻想了他应该带一些什么东西。理所当然的，你当然要帮他计算携带N件物品的方案数。他这次又准备带一些受欢迎的食物，如：蜜桃多啦，鸡块啦，承德汉堡等等。当然，他又有一些稀奇古怪的限制：每种食物的限制如下：最多带 1 个汉堡 巧克力的块数是 5 的倍数 最多带 4 瓶矿泉水 薯片的包数是一个偶数 最多带 3 罐牛奶 糖果的个数是 4 的倍数注意，这里我们懒得考虑明明对于带的食物该怎么搭配着吃，也认为每种食物都是以‘个’为单位（反正是幻想嘛），只要总数加起来是$n$就算一种方案。因此，对于给出的$n$,你需要计算出方案数，并对$10007$取模。$n=10^{100}$，$k=3$。我们考虑为每个限制生成自己的母函数。像前面的例子一样，$0$代表可选择，$1$代表不可选择。汉堡：$1,1,0,0,0,0\cdots \leftrightarrow 1+x$(只能带$0$或$1$个)巧克力：$1,0,0,0,0,1,0,0,\cdots \leftrightarrow \frac{1}{1-x^5}$($5$的倍数)矿泉水：$1,1,1,1,1,0,0\cdots \leftrightarrow \frac{1-x^5}{1-x}$(最多$4$瓶)薯片：$1,0,1,0,1\cdots \leftrightarrow \frac{1}{1-x^2}$(偶数个)牛奶：$1,1,1,1,0,0\cdots \leftrightarrow \frac{1-x^4}{1-x}$(最多$3$罐)糖果：$1,0,0,0,1,0\cdots \leftrightarrow \frac{1}{1-x^4 }$($4$的倍数)直接卷起来，最后结果化简为$\displaystyle \frac{1}{(1-x)^3} = (\frac{1}{1-x})^3\leftrightarrow 1,1,1,1,1\cdots^3$。容易用二项式定理把它重新搞成系数形式：$1+C^2_3x+C^2_4x^2+C^2_5x^3\cdots$题目需要求的是$x^n$的系数，直接输出$C_{n+2}^2$即得解。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>母函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 实现多地部署及优化访问速度]]></title>
    <url>%2F2019%2F07%2F19%2F719%2F</url>
    <content type="text"><![CDATA[这几天因为服务器快过期了,就想着把博客从 WordPress 迁移到 Hexo 上来.一是因为 1M 的小水管跑 WordPress 加载速度有点点慢,再就是因为就我个人来讲更习惯 Hexo 这种本地写作再 Push 的方式(主要是以后万一还要迁移的话导出方便,不想 WordPress 都不支持 Markdown, 还得自己手动装插件,而且插件还有不兼容的地方)但是 Hexo 主体文件是部署在本地的,而我写作的环境有多个(一台装着 Ubuntu 的电脑, 还有一台笔记本). 所以就需要两边相互同步,这样才方便这里我们需要用到 GitHub 或者是其他的代码托管服务.笔者这里选择了 GitHub 和 腾讯开发者平台 来托管我的代码.GitHub 放静态网页其实不是最优选择,一是因为百度不爬取 GitHub pages, 二是因为 GitHub 在国外,虽然可以通过*修改Hosts提升访问速度, 但是修改了自己Hosts的毕竟是很少很少一部分. 所以笔者建议 GitHub 只用于代码托管(因为其他的代码托管服务说不定什么时候就崩了,部署在 GitHub 上总是不会错的)先是去网上查了一下,结果发现大多数采用的方案都是在一个 git 仓库里开两个分支. 一个放静态网页, 一个放源码. 但是这样其实是很不安全的! 在 Hexo 中我们为了方便会加一些插件,而某些插件会用到第三方平台.比如笔者博客中的评论功能( Power by Valine ) 就用到了 LeanCloud 的服务. 将评论内容, 访问量等信息存储在容器里,而这个容器的 Token 是万万不能给别人的. 而网上的通用方案因为仓库公开, 所以任何人都能看到你在里面设置的 Token, 这样是不行的, 下面笔者将给出自己的方案前置已成功安装 Hexo 和 npm已成功安装 git 并添加进环境变量中已成功将自己的公钥添加进 GitHub(可用ssh -T git@github.com测试)多地部署首先,我们要去 GitHub 创建两个 repository ,其中一个命名为 xxxx.github.io 并设为 Public, 如下图所示(没有帐号的请自行学习注册帐号并学习 GitHub 的使用)这里需要注意的是,笔者已经创建过名为 bestsort.github.io 的 repo 了,所以再创建会报该 repo 已存在(记得勾选 Initialize this repository with a README 初始化)这个仓库就是别人以后访问你网页时候所使用到的仓库了我们还需要一个仓库存源码,再新建一个权限为 Private 的仓库,以后我们要重新部署就从这个仓库里 Clone 下来.这里我的私有仓库命名的是 my-blog ,所以我们在本地进入放置 Hexo 的地方,执行 git remote set-url origin https://github.com/bestsort/my-blog.git 这里记得将链接中的 bestsort 替换为你自己的 GitHub 用户名,将 my-blog 替换为你放博客的私有仓库名然后我们打开 Hexo 的配置文件 ~/_config.yml 注意这里是全局配置文件,不是主题配置文件.将 deploy 配置如下:配置里面的仓库名填刚才创建的 公共仓库 的名称这里笔者由于为了提升国内访问速度,所以在 腾讯开发者平台 也创建了一个仓库,就是下面的第二个 type12345678deploy:#这里记得替换掉链接中的用户名和仓库名- type: git repo: git@github.com:bestsort/bestsort.github.io.git branch: master- type: git repo: git@git.dev.tencent.com:bestsort/bestsort.git branch: coding-pages至此,多地部署已经设置完成.每次更改或者创建新文章后,需执行以下命令:12345hexo ghexo sgit add .git commit -m '提交备注'git push因为是多地部署,所以每次修改前最好是执行 git pull 命令拉取远程仓库在新环境中部署执行 git remote set-url origin https://github.com/bestsort/my-blog.git 老样子,替换用户名仓库名然后再执行npm install 即可写作了]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写Java的时候碰到的一些坑]]></title>
    <url>%2F2019%2F06%2F22%2F788%2F</url>
    <content type="text"><![CDATA[一般来讲Calendar转为java.sql.Date需要先转为java.util.Date,不过可以获取时间戳然后用时间戳去构造.如:Calendar date = Calendar.getInstance();Date date1 = new Date(date.getTimeInMillis());List 相关实现里,remove 是一个很大的坑.类似于 C++ 进行删除后迭代器指针的问题,个人觉得最稳妥的方法还是另开一个 List 然后将不用删除的元素添加进新的 List 里去.虽然会造成内存的浪费,但是这确实是最稳妥最不会出错的方法调用 python 的时候,如果用的是另开进程重定向输入输出流的方式,记得调用参数中的 python 版本.Windows 下一般只有3.x可以命令行直接用python启动,但是由于历史原因Ubuntu内置的是 Python2.7 如果直接键入 python 会默认进入python2,需要改软链接或者键入python3指令调用其它语言用IO流截获输出的时候，注意输出的字符编码格式，比如 Liunx 下是UTF-8， Windows 下 是GBK,如果不转换编码，在两个平台上的输出结果大概率会不一样]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019年第十届蓝桥杯B组国赛(c/c++)总结]]></title>
    <url>%2F2019%2F05%2F27%2F777%2F</url>
    <content type="text"><![CDATA[这次蓝桥怎么说呢，大题感觉挺难的..填空题还好,有点脑筋急转弯的感觉填空$2019^2, x^2, y^2$ 构成等差数列(x&lt;y),求解最小的公差 直接暴力就行了可惜这个题没注意 x&lt;y 直接交了个2019上去求有多少对素数 (a,b) 使得 $a + b == 2019 (a&lt;b)$ 因为2019必定由一个奇数和一个偶数组成,所以只有2,2017这一组$s_i$ 表示因子个数为 i 的最小的数,求$s_100$ 也是一道直接暴力的题gh给出一个 7*7 的矩形，将其分成两部分，求有多少种方法使得靠右的那部分按 x = y 翻转后再和左边部分拼接出来还是 7*7的矩形 其实不难看出必须是等腰直角三角形才满足条件,所以总共 7 种方法一个5*5的格子，从左上角沿着边走，要求最多走12步，路径不能重叠，必须回到起点.求有多少种走法 dfs从左上角走格子即可,最多12步,也就是5格,我这里用string来记录每一步的位置,把走过的路全插入到 set 里,最后set的大小是101,因为正反都可以走,所以答案是202编程给出两个串 s, t 求 s 串修改(只修改，不能添加 or 删除字母)多少次可以找到 t 这个子序列pos从0开始 第一重循环i 从 0 到t.size() 第二重循环j从i到t.size(). 用26个数组分别记录’a-z’的下标,遍历t串的时候,如果有当前字母,则pos等于 当前字母中第一个&gt;pos的位置,否则pos++在一个排列中，每存在一个 (s[i]&gt;s[i-1] &amp;&amp; s[i]&gt;[i+1])||(s[i]&lt;s[i-1] &amp;&amp; s[i]&lt;[i+1]) 则这个排列的 value+1 ,最后让求在 1-n 的全排列中,value 为 k-1 的排列有多少个这个真不会了,全排列函数暴力了n&lt;=13时候的情况交上去了异形魔方:第一层为 12 个字母，第二层为 8 个字母，第三层为 4 个字母,每次可以将这三层都横向转动一次,或者竖着转动一列如果第一层,第二层，第三层分别为$s[0][0],s[1][0],s[2][0]$，则竖着转动后变为 $s[1][0],s[2][0],s[3][0]$ .给出 12+8+4 个字母(共12个R,8个G,4个B).求是否能将魔方归位。单纯dfs时间复杂度太高,于是我加了个自己都不知道正确性的剪枝上去剪到1e6左右了 策略是:设当前列混乱度为3,如果某一位要求的字母种类和此位置上的字母一致的话混乱度-1,当竖着转动当前列的时候,如果混乱度会增大且增大后==3则不转动 (我也不知道对不对)2种操作，插入 or 查询。每次可以修改某一点的值或者查询区间$[l,r]$中第八大的数主席树裸题，可惜我记不住板子.概率题，没看记不清了…]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统习题答案详解]]></title>
    <url>%2F2019%2F05%2F15%2F771%2F</url>
    <content type="text"><![CDATA[第二章五.名词解释进程:进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动;线程:线程是进程中可独立执行的子任务,是系统独立调度和分派的基本单位;原语:原语是操作系统内核中由若干条机器指令构成用于完成特定功能的一个过程,该过程在执行时是不可分割的,即呈原子特征,它是机器指令的延伸;进程的互斥与同步:进程互斥:对某个系统资源,一个进程正在使用它,另外一个想使用它的进程必须等待,而不能同时使用进程同步:合作进程在独自并发执行过程中在某些确定的时序点上”你等我,我也等你”的同步约束;信号量:也称信号灯,是表示某类资源实体与进程队列有关的整型变量,其值只能通过P.V操作来改变;临界资源:一次仅允许一个进程使用的资源;死锁:两个或多个进程在执行过程中,因争夺资源而造成的一种相互等待的现象;六.简答题操作系统为什么引入进程这一概念 在单道程序系统中,内存每次仅存在一个程序,该程序运行时独占系统的全部资源但实际上它只会顺序地使用其中的一部分,造成了系统资源的浪费,这种情况随着处理机和内存性能的提高会愈发突出.于是就引入了进程这一概念,使得多个程序能够同时进入内存并共享资源,提高系统资源的利用率操作系统提供上锁原语,试问采用什么措施可以保证该原语操作执行时不会被打断? 通过CLI指令关闭中断简述进程与程序的主要区别进程是程序的基本执行实体进程有生命周期,程序没有一个进程只能对应一个程序,但是一个程序可以对应多个进程;进程是动态的,程序是静态的;进程有哪些基本状态,它们是如何变化的? 有就绪,执行,阻塞三种基本状态,部分系统还引入了挂起状态临界区的使用原则是什么 “空则让进,忙则等待,等待有限,等则让权”;在生产者-消费者问题中,如果对调生产者进程中的两个P操作,则可能会发生什么情况? 答:可能会形成死锁.当生产者抢先执行,使得缓冲池全满后,由于先执行P(mutex)操作后执行P(empty)操作,会使后续消费者和生产者进程在P(mutex) 这一步相互阻塞,形成死锁;]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019年山东省第十届ACM省赛总结]]></title>
    <url>%2F2019%2F05%2F13%2F764%2F</url>
    <content type="text"><![CDATA[Day 1今天很早就醒了，本来5:40出发的，结果在做梦的时候梦到了要去一个车站，顿时反应过来要去烟台站，于是乎瞬间惊醒… 一看时间:才4:50… 不过醒都醒了，也就只有起来咯 遂起身，呼朋之。 到了济大门口志愿者小姐姐就来接我们了，一路上领着我们东奔西跑的，济大是真的大。。。。从进门口到会场走了有将近半小时吧可能，得亏有小姐姐才没有迷路。 疯狂点赞志愿者们 领了资料后发现衣服是白色的，质感也挺好。个人觉得这是我参加比赛一来最好的衣服了，完全可以当成日常穿着。热身赛:热身赛没什么好说的，前三题都是原题。第四个题就emmmm可能是为了压测？24个老婆里面随机选 12 个对应人名(最后听说不是人名是画师名，真的是满满的恶意…)，我们队里又没有二刺螈，不配拥有d题 晚上我们学校的队员们基本上都去芙蓉街 / 音乐广场玩了，我自己是真的真的太困了(早上 4:50 起 就回酒店了，哪都没去 本来晚上 7:00 出去想体验一下八食堂三楼的饭菜，结果发现人家都准备收摊了QAQDay 2正式赛:侥幸混了个铜尾，以比铁首少一分钟罚时的微弱优势 本来都以为要打铁了 最后志愿者小姐姐来通知领奖队伍的时候才反应过来原来还混了个铜 虽然还是很不甘心 这5个题真的都很简单… 偏偏C题我的解法是平移 k-1 次，最后一次循环找最大 然而因为太久没写代码(队里一般都是我出思路，然后让更稳的 T 来写代码)，没有及时发现坑点，硬是耗费了 3h + 12发WA 在这个题上，虽然最后还是有个牌，不过真的觉得很遗憾，因为其 他题目不是不会，而是根本没时间看了赛后本来打算赛完就走的，结果感觉 18:10 的车赛完就走有点太早了，就去礼堂看完了铜牌滚榜。主持人居然说出来我们队名（ 龘䶛䨻䆉 ）的正确读音了，点个赞!后来是等铜奖领完才走的（蒟蒻学校只有铜牌） 在公交车上，我们目睹了天从 蓝灰色 -&gt; 灰色 -&gt; 深灰色 -&gt; 暴雨 的演变 然后就被雨淋的妈都不认识了。。。 到车站的时候，鞋子裤子基本上都全湿了end赛后才知道 H 题 $10^9nlog(n)$的时间复杂度都能过,只要不每次 sort 随便暴力…真的是，无 Fuck 说 最后的最后，虽然自己觉得这是自己参加比赛以来最菜的一场，不过参赛体验却是最好的一场。 点赞济南大学]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用网站链接]]></title>
    <url>%2F2019%2F05%2F08%2F745%2F</url>
    <content type="text"><![CDATA[ACM算法学习 / 刷题HDUCodeforces(大型网游现场(逃 )POJVirtual Judge(可以抓其他 OJ 的题来做)洛谷(题目配套题解很详细,学习算法比较方便)VisuAlgo(可视化算法学习)技巧OI WIKI(虽然写的 OI,但是对 ACM 也很有用的技巧)前端这个我不会~只是搭博客的时候发现的一些比较有用的网站CodePen阿里巴巴矢量图标库服务器商国外主机测评国内阿里云国外HostUSPnZHost(这个听说风评不大好)Vultr]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用OSS和CDN实现WordPress的动静分离]]></title>
    <url>%2F2019%2F05%2F08%2F735%2F</url>
    <content type="text"><![CDATA[使用 OSS 和 CDN 完成 WordPress 网站动静分离什么是 OSSOSS 是阿里家的云存储服务（腾讯家的对象存储叫 COS），你可以简单的把它看成一个云端文件管理系统。不同的是，对象没有层级结构（这点和 Liunx 的文件不大一样）。什么是 CDNCDN 全名内容分发网络，是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络，换句话讲，你可以把它当成一个超大的局域网，每当用户请求某一资源时，CDN 会优先从最近节点返回请求内容给用户，不会占用 Web服务器 的带宽，达到快速加载的效果。此外，CDN 还能在一定程度上防 DDoS 攻击（如果 CDN 存在被 DDoS 攻击的情况。CDN 整个系统就能够将被攻击的流量分散开，节省站点服务器的压力以及节点压力）什么是动静分离在刚搭建好 WordPress 后，我们的媒体文件（图片，视频，音频等）都是存放在服务器本地的。每当用户访问的时候，就会从服务器中调出来显示到网页上。但是总所周知，媒体文件占用空间通常都是比较大的，而国内的个人服务器带宽又比较低。在这种情况下，访问页面就容易造成堵塞 —-在阿里云学生机 1M 带宽的限制下，平均1个3,400+KB的网页需要3秒钟才能下载完成。当同时访问网页的 ip 变多了之后，明显的卡顿会大幅降低浏览体验。而且媒体文件都在 而动静分离，顾名思义就是将静态资源和动态页面分离开来的做法，通过将媒体文件（或者其他静态资源）储存到各类云存储服务器中去（比如说阿里云的对象存储 OSS）。这样用户访问网页时，动态资源还是从 Web服务器 获取，而静态资源就直接通过距离用户最近的 CDN 节点就近获得文件，减少 Web服务器 负载，同时也能显著提升页面加载速度。将静态资源上传到 OSS 中没买 OSS资源包 的话记得先买一个 OSS资源包（9￥/年） 或者选择 按量付费。然后新建 bucket： 这里需要注意的是 bucket 的地域记得和 ECS服务器 的地域一致（这样可以走内网，不浪费流量）。 然后回到 WordPress 安装好 阿里云OSS 这个插件。 这里其实时很方便的，因为 WordPress 有 阿里云OSS 这个插件，能一键配置。 Access Key 在下图这个位置查看。 进入 WordPress 的 阿里云OSS 这个插件，按要求填好后（记得 Bucket 域名填内网域名） 填好后如果没有错误的话，在媒体库里就能看见所有的媒体文件链接都变成了 阿里云bucket 的链接，这时候就表示我们的 bucket 设置好了。使用 CDN 提速网站当然，只有 OSS 是不够的，这只代表我们把数据放到了云端.实时访问的时候还是从 OSS --&gt; 服务器 --&gt; 用户，由于 OSS 文件访问比本地慢，所以这样反而会降低速度。我们还需要 CDN 来进行加速，改成 OSS --&gt; CDN服务器 --&gt; 用户 的形式。 幸运的是：各大服务商早就极大程度上简化了这个过程，这里以阿里云为例。 我们在刚刚的 bucket 页面，单击域名管理 然后绑定一个二级域名，这里不是网站主域名，随便绑定一个不会用到的二级域名即可。 然后我们返回到 阿里云OSS插件 页面，把 bucket域名 改成此域名即可。如下图 到此，我们所有的操作就搞定了，在网站页面按 F12 调出控制台，在 Sources 栏目下就能看见我们的静态资源是从刚才设置的 CDN域名 处调用的]]></content>
      <categories>
        <category>VPS玩机</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分层图最短路 算法详解与模板]]></title>
    <url>%2F2019%2F05%2F07%2F703%2F</url>
    <content type="text"><![CDATA[转载注明出自bestsort.cn,谢谢合作分层图最短路应用场景分层图最短路在最短路的基础上,增加了一个条件:可将 n 条边的权值变为 0. 比如说下图: 那么最短路肯定是如下图 但是如果我们能把一条边的权值变为 0 的话,最短路应该是下面这个样子 而分层图就是用来解决这类问题的. 仔细回想下最短路的 floyd 算法,每次对于一个点 k ,用$dis[i][j] = min(dis[i][j],dis[i][k]+dis[k][j])$来择优选择.这里的分层图也是一样的道理,每次对 此条边免费 和 此条边不免费 进行 DP,最终结果便是最优解. 设会有 K 次免费机会,则 dis的状态转移方程为: $dis[i][j]=min(dis[father][j-1],dis[father][j]+w)$ 其中, $father$ 表示节点$i$的父亲节点,$w$ 表示节点 $i$ 到 $j$ 的边权.当 $j-1&gt;=k$ 时,$dis[father][j]=INF$ ($INF$为无穷大,通常用0x3f3f3f3f表示) 事实上，这个 DP 就相当于把每个结点拆分成了 $k+1$ 个结点，每个新结点代表使用不同多次免费通行后到达的原图结点。换句话说，就是每个结点 $u[i]$ 表示使用 i 次免费通行权限后到达 $u$ 结点。 在代码实现里面,核心代码只不过在最短路的基础上修改了几行用于 DP,代码本身并不难.这里代码中的最短路部分采用的算法是 **Dijkstra+堆优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;list&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;limits&gt;#include &lt;cmath&gt;#define IN freopen("in.txt","r",stdin);using namespace std;typedef long long int ll;const int maxn = 1e5+10;const int INF = 0x3f3f3f3f;struct State&#123; // 优先队列的结点结构体 int v, w, cnt; // cnt 表示已经使用多少次免费通行权限 State() &#123;&#125; State(int v, int w, int cnt) : v(v), w(w), cnt(cnt) &#123;&#125; bool operator&lt;(const State &amp;rhs) const &#123; return w &gt; rhs.w; &#125;&#125;;struct node&#123; int v; int w; int next; /* data */&#125;edge[maxn];priority_queue&lt;State&gt;pq;int n,t,m,k,u,v,w,s;int cnt;bool vis[maxn][20];int dis[maxn][20];int head[maxn];void add(int u,int v,int w)&#123; //链式前向星存边 edge[cnt] = &#123;v,w,head[u]&#125;; head[u] = cnt++;&#125;void dijkstra()&#123; memset(dis, 0x3f, sizeof(dis)); dis[s][0] = 0; pq.push(State(s, 0, 0)); // 到起点不需要使用免费通行权，距离为零 while (!pq.empty()) &#123; State top = pq.top(); pq.pop(); int u = top.v; int nowCnt = top.cnt; if (vis[u][nowCnt]) continue; vis[u][nowCnt] = true; for (int i = head[u]; ~i; i = edge[i].next) &#123; int v = edge[i].v, w = edge[i].w; if (nowCnt &lt; k &amp;&amp; dis[v][nowCnt + 1] &gt; dis[u][nowCnt]) &#123; // 可以免费通行 dis[v][nowCnt + 1] = dis[u][nowCnt]; pq.push(State(v, dis[v][nowCnt + 1], nowCnt + 1)); &#125; if (dis[v][nowCnt] &gt; dis[u][nowCnt] + w) &#123; // 不可以免费通行 dis[v][nowCnt] = dis[u][nowCnt] + w; pq.push(State(v, dis[v][nowCnt], nowCnt)); &#125; &#125; &#125;&#125;int main()&#123; //IN; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); memset(head,-1,sizeof (head)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; cin &gt;&gt; s &gt;&gt; t; while (m--) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); add(v, u, w); &#125; int ans = INF; dijkstra(); for (int i = 0; i &lt;= k; ++i) ans = min(ans, dis[t][i]); // 对到达终点的所有情况取最优值 cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式总结]]></title>
    <url>%2F2019%2F05%2F04%2F648%2F</url>
    <content type="text"><![CDATA[本文由作者通过《Head First设计模式》以及其他网络资料二次总结而来转载注明出自bestsort.cn,谢谢合作设计模式六大原则单一职责原则一个类应该仅有一个引起它变化的原因，即不要让一个类承担过多的职责，以此降低耦合性。开闭原则（Open Close Principle）类、函数、模块应该是可以扩展的，但是不可以修改，即对扩展开放，修改封闭。里氏替换原则(Liskov Substitution Principle)所有引用基类的地方都能透明地替换为子类对象，即可以在定义时尽量使用基类对象，等到运行时再确定其子类类型，用子类对象来替换父类对象。依赖倒置（Dependence Inversion Principle）高层、底层模块、模块间和细节都应该依赖于抽象，即通过接口或抽象类产生依赖关系。迪米特原则（Demeter Principle）一个软件实体应该尽可能少地与其它实体发生相互作用，即最少知识原则。接口隔离原则（Interface Segregation Principle）一个类对另一个类的依赖应该建立在最小的接口上。设计模式总览以下表格数据引用自Wiki-设计模式创建型模式(五种)名称译名描述&lt;设计模式&gt;中提及&lt;代码大全&gt;中提及Abstract factory抽象工厂模式为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。YYBuilder生成器/建造模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。YNFactory method工厂方法模式定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的初始化下放到子类。YY原型模式Prototype用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。YNSingleton单例模式确保一个类只有一个实例，并提供对该实例的全局访问。YY结构型模式(七种)名称译名描述&lt;设计模式&gt;中提及&lt;代码大全&gt;中提及Adapter, Wrapper, or Translator适配器模式将某个类的接口转换成客户端期望的另一个接口表示。适配器模式可以消除由于接口不匹配所造成的类兼容性问题。YYBridge桥接模式将一个抽象与实现解耦，以便两者可以独立的变化。YYComposite组合模式把多个对象组成树状结构来表示局部与整体，这样用户可以一样的对待单个对象和对象的组合。YYDecorator修饰器模式向某个对象动态地添加更多的功能。修饰模式是除类继承外另一种扩展功能的方法。YYFacade外观模式为子系统中的一组接口提供一个一致的界面， 外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。YYFlyweight享元模式通过共享以便有效的支持大量小颗粒对象。YNProxy代理模式为其他对象提供一个代理以控制对这个对象的访问。YN行为型模式(十一种)名称译名描述&lt;设计模式&gt;中提及&lt;代码大全&gt;中提及Chain of responsibility责任链为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。YNCommand命令将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。YNInterpreter解释器给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。YNIterator迭代器提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。YYMediator中介者包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。YNMemento备忘录备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。NYObserver观察者模式在对象间定义一个一对多的联系性，由此当一个对象改变了状态，所有其他相关的对象会被通知并且自动刷新。YYState状态模式让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能获取的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。YNStrategy策略模式定义一个算法的系列，将其各个分装，并且使他们有交互性。策略模式使得算法在用户使用的时候能独立的改变。YYTemplate method模板方法模板方法模式准备一个抽象类，将部分逻辑以具体方法及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先构建一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。YYVisitor访问者封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。YN策略模式策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户把变化处的代码取出并封装起来，好让其他部分不受到影响针对接口编程，而不是针对结果多用组合，少用继承观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新可观察者用一个共同的接口来更新观察者可观察者和观察者以松耦合结合(可以不知道细节，只知道接口可从被观察者处拉/推数据(一般都为推有多个观察者时，不可依赖特定的通知次序java.util等包有观察者模式的实现装饰者模式动态地将责任附加到对象上。若要拓展功能，装饰者提供比继承更加有弹性的替代方案类应该对扩展开放，对修改关闭(开放-关闭原则过度使用装饰者会让程序变的很复杂装饰者可以在被装饰者的前/后加上自己的行为，甚至取代装饰者类反映出被装饰的组件类型除了继承，装饰者也可以扩展行为可以用$∞$个装饰者包装一个组件工厂模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[建立自己的 BLOG（4）— 搭建 WordPress]]></title>
    <url>%2F2019%2F04%2F30%2F543%2F</url>
    <content type="text"><![CDATA[[ ] 租用一台服务器(VPS)[ ] ssh登陆并进行相关设置[ ] 搭建 LAMP / LNMP 环境[x] 搭建WordPress额外项[ ]使用 OSS对象储存 让网站动静分离[ ]部署私人网盘到二级域名添加虚拟主机（Vhost）lnmp vhost add 参考如下配置 然后回车，显示成功信息后 Vhost 就添加好了，可以用 lnmp vhost list 查看已存在的虚拟主机了 安装 WordPress下载wordpress最新的中文版本并安装 注意把bestsort.xyz改成自己的主域名wget https://cn.wordpress.org/latest-zh_CN.tar.gz #解压 tar -zxvf latest-zh_CN.tar.gz #将其移动到网站目录下 mv wordpress/* /home/wwwroot/bestsort.xyz #修改所属用户和权限 chown -R www /home/wwwroot/bestsort.xyz chmod 755 -R /home/wwwroot/bestsort.xyz 最后修改所属用户和权限的时候会报错changing permissions of ‘/home/wwwroot/bestsort.xyz/.user.ini’: Operation not permitted不用理会即可，这是因为 .user.ini 被锁定了，不能更改和删除，由于是搭建 wordpress 所以不推荐用 chattr 去解锁进入网站到这一步，已经可以通过访问 bestsort.xyz 进入 wordpress 配置界面了。记得要先解析域名到 ip。域名生效是有时间间隔的，这里可以用 ip检测工具 检测域名是否解析成功。输入自己域名后如果自己所在地运营商能成功解析 ip 则表示可以自己通过域名访问了。 注意国内主机未经备案无法访问域名，只能通过IP访问网页 这里我们访问 bestsort.xyz,会显示以下界面 点击开始 输入刚才设置的数据库用户名，密码 点击安装，进入网站设置界面 登陆后就能看见自己的网站了 当然这还是一个很简陋的网站。不过已经搭起来了，剩下的主题，插件就可以自己弄了设置httpshttp 相对与 https 来讲，不够安全，而且搜索引擎对 http 页面会降权处理，浏览器在浏览 http 页面的时候也会显示红色的不安全标识，所以我们要启用 https 访问申请SSL证书详情参考 这里由于我的域名是在阿里云申请的，所以使用阿里云的 API。点击这里查看 AccessKeyexport Ali_Key=&quot;Your AccessKey ID&quot; export Ali_Secret=&quot;Your Access Key Secret&quot; lnmp dnsssl ali 显示以下内容表示 SSL证书 安装成功 这时候我们就可以通过 https://+你的域名 来访问网站了,网址左边会显示 安全的字样或者一个小绿锁，点开能看到证书详情 301转发当然，光有证书是不够的，你会发现使用 www+域名,域名,https://+域名都能访问到自己的网页，而且显示的网址格式不一样。为了安全，我们得把所有请求都重定向到 https 上来#如果没有 vim 需要先安装 vim vim /user/local/nginx/conf/vhost/bestsort.xyz 配置里添加标红内容 然后 esc,wq回车 保存并退出，重启 lnmp:lnmp restart，这样无论是输入上面哪一种域名都会直接跳转到 https 了。 需要注意的是, wordpress 还需要去管理员面板-&gt;设置-&gt;常规将两个 URL 链接改成https://网址 的形式,保证全站启用 https]]></content>
      <categories>
        <category>VPS玩机</category>
      </categories>
      <tags>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己的 BLOG（3）— 搭建 LAMP / LNMP 环境]]></title>
    <url>%2F2019%2F04%2F29%2F524%2F</url>
    <content type="text"><![CDATA[[ ] 租用一台服务器(VPS)[ ] ssh登陆并进行相关设置[x] 搭建 LAMP / LNMP 环境[ ] 搭建WordPressLNMP一键搭建下载这里我们使用 LNMP1.5 一键包来搭建 LNMP 环境. 先选择下面任意一条命令输入 这里由于我用的 Vultr 的机器,带宽较高,就直接把源码一起下载下来#完整版,文件较大(580M+,包含源码文件,安装时间 30min 左右) wget http://soft.vpser.net/lnmp/lnmp1.5.tar.gz #下载版,文件较小(140K+,不含源码安装包文件，仅有安装脚本及配置文件,安装时间 45min 左右 ) wget http://soft.vpser.net/lnmp/lnmp1.5-full.tar.gz 注意,如果是下载的下载版,把下文中的 lnmp1.5-full 替换为 lnmp1.5 即可安装tar -zxvf lnmp1.5-full.tar.gz cd lnmp1.5-full ./install.sh 按顺序输入并执行上面三条语句就能看到以下界面了 这里是数据库版本,我选的是 MySQL 5.5,按2,回车.然后让输入 MySQL 的 root 用户密码,和是否安装 InnoDB 数据库存储引擎.Y或者n都可以,不重要.接下来是 php 的版本.这里我选择 PHP7.1,然后让选择 PHP 的内存分配器,这里我选 TCMalloc . 然后 按回车就会自动安装了 最后显示这个就代表安装成功了,ctrl + c 退出即可 删除虚拟主机在删除前，需要对 .user.ini 解锁，然后删除虚拟主机，再删除网站目录就可以了chattr -i /home/wwwroot/bestsort.xyz lnmp vhost del #输入后在提示框内输入自己的主域名即可 rm -rf /home/wwwroot/bestsort.xyz 插件推荐All In One WP Security(安全插件)Table of Contents Plus（为你的文章添加目录）WP Editor.md（markdown 编辑器插件，喜欢 markdown 的可以试下）WP Fastest Cache（缓存）Yoast SEO（很好用的SEO工具）WP Statistics（站点统计）常见问题配置文件目录MySQL 密码重置PHP 安装拓展模块]]></content>
      <categories>
        <category>VPS玩机</category>
      </categories>
      <tags>
        <tag>LNMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路 Dijkstra 算法详解与模板]]></title>
    <url>%2F2019%2F04%2F28%2F495%2F</url>
    <content type="text"><![CDATA[图解1Dijkstra 使用的是贪心的思想，先假设所有顶点之间都没有边相连，然后每次从输入的边中选取一条权值最小的边并连接该边所对应的两个顶点，直到最后所有的顶点都被连通为止（即所有的顶点都能通过某一路径走到指定的点),如下图 以顶点（1）为起点，点（1）连通有（6），（3），（2）三个点，权值分别为14,9,7（其他点赋值为无穷大）; 所以选择权值最小的7,并连接（1,2）这条边（这里是通过并查集把两个点并入同一个祖先实现的） 然后再次遍历存权值的数组，找出下一个没被使用过且权值最小的边，并入集合中，这样一直循环n-1次，遍历了n-1个顶点之后，dis[j]就为从起点a-&gt;j的最短距离。 算法时间复杂度为O(n^2) (可以用堆或者优先队列优化达到更低的时间复杂度，可是我不会= =…..)图解2GIF图解如下： 所以每次需要执行的就是- -&gt;找一条没有被标记且权值最小的边 -&gt;将该边所连的顶点标记 -&gt;将记录距离的数组更新 -&gt;重复第一步 需要注意的是，一开始设距离为无穷大，如果一圈找完后还是存在距离=无穷大，那么说明剩下的顶点与集合内的顶点均不连通. 起点以左下角的红点 目标是右上角的绿点 中间灰色的倒L型为障碍物 蓝色空圈表示”暂定“，用以搜索下一步；已经填充颜色的表示探访过，图中颜色以红到绿，越绿表示离起点越远。所有节点都被均匀的探索。代码(朴素版)代码初学时可能看着比较难以理解，但是自己试着抄一下，每一行每一行的看下来会发现还是很好理解的 本份代码无任何优化,时间复杂度$O(n^2)$,空间复杂度$O(n^2)$ 已通过 HDU2544 完成了正确性验证 以下是代码模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define IN freopen("in.txt","r",stdin)using namespace std;const int maxn = 1e3 + 10;const int INF = 0x3f3f3f3f;const int inf = 0x3f;typedef long long ll;int n, m;int dis[maxn]; ///a到各点的距离bool vis[maxn]; ///标记该点是否已经使用int map[maxn][maxn];void dijkstra(int a)&#123; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dis[i] = map[a][i]; dis[a] = 0; vis[a] = true; for (int i = 1; i &lt;= n; i++) &#123; int Min = INF, Np = a; for (int j = 1; j &lt;= n; j++) if (!vis[j] &amp;&amp; dis[j] &lt; Min) &#123; Np = j; Min = dis[j]; &#125; if (Np == a) return; vis[Np] = true; for (int j = 1; j &lt;= n; j++) if (dis[j] &gt; (dis[Np] + map[Np][j])) dis[j] = dis[Np] + map[Np][j]; &#125;&#125;void init(int n)&#123; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=n;j++) map[i][j] = INF; memset(vis, 0, sizeof(vis)); memset(dis,0x3f,sizeof(dis));&#125;int main()&#123; // IN; int a, b, c; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m)) &#123; init(n); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; map[a][b] = map[b][a] = min(map[a][b],c); //本题有重边,所以得取最小 &#125; dijkstra(1); cout &lt;&lt; dis[n] &lt;&lt; endl; &#125; return 0;&#125;代码(堆优化版本)其实我们可以观察到, Dijkstra 算法 找最小权值的边 比较耗时，大部分的时间都花在了查找下一个使用的顶点上，因此需要使用合适的数据结构进行优化。如果说我现在可以选择的边权(如果该边连接的两个点一个已经被选择过,另一个点未被选择,则说这条边是可选择的)有${4,6,2,3,6}$,那么一定是选择最短边所连接的点进行更新.这样,通过每次选择最短边进行更新,可以避免大量无谓的时间消耗.其中,$m$表示边数,$n$表示点数 本份代码通过 链式前向星 和 二叉堆 将 Dijkstra 的空间复杂度优化到了 $O(E)$, 时间复杂度优化到了$O((E+V)logV)$.其中,$E$表示边数,$V$表示点数 已通过 HDU2544 完成了正确性验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;list&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;cmath&gt;#define IN freopen("in.txt", "r", stdin);using namespace std;typedef long long int ll;const int maxn = 1e4 + 10;const int INF = 0x3f3f3f3f;int n, m;int head[maxn];int cnt;struct edge&#123; int next; int v; int w;&#125; e[maxn];void addEdge(int u, int v, int w)&#123; e[++cnt] = &#123;head[u] ,v, w&#125;; head[u] = cnt;&#125;struct node&#123; int dis, id; bool operator&lt;(const node &amp;a) const &#123; return dis &gt; a.dis; &#125;&#125;;int dis[maxn];bool vis[maxn];void Dijkstra(int s)&#123; node buf; dis[s] = 0; priority_queue&lt;node&gt; q; q.push(&#123;0, s&#125;); while (!q.empty()) &#123; buf = q.top(); q.pop(); if (vis[buf.id]) continue; vis[buf.id] = true; for (int i = head[buf.id]; i; i = e[i].next) &#123; int v = e[i].v; int w = e[i].w; if (buf.dis + w &lt; dis[v]) &#123; dis[v] = buf.dis + w; q.push(&#123;dis[v], v&#125;); &#125; &#125; &#125;&#125;void init(int n)&#123; cnt = 0; fill(dis, dis + n + 5, INF); fill(vis, vis + n + 5, 0); memset(head, 0, sizeof(head)); memset(e, 0, sizeof(e));&#125;int main()&#123; // IN; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m)) &#123; init(n); int u, v, w; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addEdge(u, v, w); addEdge(v, u, w); &#125; Dijkstra(1); cout &lt;&lt; dis[n] &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树 数据结构详解与模板]]></title>
    <url>%2F2019%2F04%2F28%2F482%2F</url>
    <content type="text"><![CDATA[转载注明出自bestsort.cn,谢谢合作线段树线段树是一个查询和修改复杂度都为log(n)的数据结构。主要用于数组的单点修改&amp;&amp;单点查询&amp;&amp;区间求和&amp;&amp;区间修改. 另外一个拥有类似功能的是树状数组，但是树状数组最常用的是单点修改&amp;&amp;区间求和. 线段树完全涵盖树状数组所有功能和树状数组的区别和联系1.两者在复杂度上同级, 但是树状数组的常数明显优于线段树, 其编程复杂度也远小于线段树. 2.树状数组的作用被线段树完全涵盖, 凡是可以使用树状数组解决的问题, 使用线段树一定可以解决, 但是线段树能够解决的问题树状数组未必能够解决. 说了这么多，其实线段树就是个二叉树而已，只不过叶子节点记录的是区间之间的和而已 先给一份样图 其中,矩形内的是区间之和,区间外的是数组下标(线段树用数组存数据).不难看出,线段树的左孩子=根节点下标_2,右孩子=根节点下标_2+1,而左右孩子则是根节点将区间二分的结果. 先给出线段树的结构体定义然后咱们再仔细讲讲各种(sao)操作struct node { int l,r,w,flag; } a[maxn&lt;&lt;2]; //4倍空间 结构体里有个延迟标记的东西,咱们下面再说这个问题 需要注意的是如果是n个数,那么线段树需要开4n的空间.理论上是2n-1的空间，但是你递归建立的时候当前节点为r,那么左右孩子分别是2_r,2_r+1,此时编译器并不知道递归已结束，因为你的结束条件是在递归之前的，所以编译器会认为下标访问出错，也就是空间开小了，应该再开大2倍。有时候可能你发现开2，3倍的空间也可以AC，那只是因为测试数据并没有那么大。 至于为什么开4倍,我从网上摘抄了一部分(反正我是看不懂首先线段树是一棵二叉树，最底层有n个叶子节点（n为区间大小） 那么由此可知，此二叉树的高度为,可证然后通过等比数列求和求得二叉树的节点个数，具体公式为，（x为树的层数，为树的高度+1） 化简可得,整理之后即为$4n$（近似计算忽略掉-1） 证毕线段树的基础操作主要有5个： 建树、单点查询、单点修改、区间查询、区间修改。建树会建二叉树的话这一条也就没什么说的了 主要就是递归建树而已 其中,k为根节点,l,r分别为左右区间 输入n个数将其建立为线段树只需要调用 build(1,1,n)即可 递归过程应该都能看懂(看不懂回去学二叉树去1234567891011void build(int k,int l,int r) &#123; a[k].l = l,a[k].r = r; if(a[k].l == a[k].r) &#123; scanf("%d",&amp;a[k].w); //cin &gt;&gt; a[k].w; return; &#125; build(k*2,l,(l+r)/2); //左 build(k*2+1,(l+r)/2+1, r);//右 a[k].w += a[k*2].w+a[k*2+1].w;//求和&#125;延迟标记这里咱们开始用到上面的变量flag了 上面说了,线段树是支持区间修改的,比如说开始那张图,咱把[1,5]都加上3,总不能把[1,5],[1,3],[4,5],[1,2],[3,3],[4,4],[5,5],[1,1],[2,2]都修改了啊,这样从第二层一直到第四层那我还要这个线段树干嘛,时间早爆炸了. 这时候,精髓部分来了,诶咱就只修改a[2]这个地方,也就是[1,5],下面的暂时用不上,就不管它.然后让flag=3. 如果下一次需要用到这一部分数据的话,将flag下传,这样查询哪一部分咱就算哪一部分的和,其他的就不管 要将[1,5]这部分+3但是不查询他的话,那么[1,5]的左右孩子也就没有更改的必要了 这个flag就是延迟标记,有了它,我们就只需要将修改过的区域标记,等到查询此部分的时候再向下修改就行了 以线段树区间1-10,初值全为0,[1,5]全部+3为例: 可以看出,[1,5]的子区间内的区间和是不对的(修改后不应该为0~) 没关系,我们只需要修改[1,5]和包含[1,5]的区间的内容即可,然后我们让flag = 3,[1,5]的子区间暂时不用管 (黑色数字代表区间和,红色代表flag的值) 如果接下来查询[1,3]或者[1,5]的其他子区间,我们再向下计算区间和,对于查询[1,3]而言,图是这样子的: 结论已经呼之欲出了: 如果查询的区域有延迟标记flag,就将标记下传,并且左右孩子的和+=flag(左右孩子区间内所存的数) 比如说[1,5]的左孩子区间为1-3,则为3\(3-1+1) = 3*3 具体操作如下123456789101112131415161718192021222324252627282930void down(int k) &#123; a[k*2].flag += a[k].flag; //标记下传 a[k*2+1].flag += a[k].flag; a[k*2].w += a[k].flag*(a[k*2].r-a[k*2].l+1); //标记求和 a[k*2+1].w += a[k].flag *(a[k*2+1].r-a[k*2+1].l+1); a[k].flag = 0; //下传之后清空当前节点的标记&#125;``` ---## 区间查询有了延迟标记的基础我们就可以进行区间求和了 也是比较简单的过程,会二分应该就能看懂```cppvoid askinterval(int k,int x,int y) &#123; if(a[k].l&gt;=x &amp;&amp; a[k].r&lt;=y) &#123; ans += a[k].w; ///ans为全局变量,记得每次查询令ans = 0; return; &#125; if(a[k].flag) down(k); int buf = (a[k].l+a[k].r)/2; if(x &lt;= buf) askinterval(k*2,x,y); ///递归查左子树 if(y &gt; buf) askinterval(k*2+1,x,y); ///递归查右子树&#125;区间修改区间修改和上面的区间查询代码基本相同,自行研究咯~123456789101112131415void changeinterval(int k,int x,int y,int z) &#123; if(a[k].l&gt;=x &amp;&amp;a[k].r&lt;=y) &#123; a[k].w += (a[k].r-a[k].l+1)*z; a[k].flag += z; return; &#125; if(a[k].flag) down(k); int buf = (a[k].l+a[k].r)/2; if(x &lt;= buf) changeinterval(k*2,x,y,z); if(y &gt; buf) changeinterval(k*2+1,x,y,z); a[k].w = a[k*2].w + a[k*2+1].w;&#125;单点查询其实单点查询完全可以使用上面区间查询的函数,反正都是一样的~ 不过毕竟是模板嘛,还是贴一份代码12345678910111213void askinterval(int k,int x) &#123; if(a[k].l==x &amp;&amp; a[k].r==x) &#123; ans = a[k].w; return; &#125; if(a[k].flag) down(k); int buf = (a[k].l+a[k].r)/2; if(x &lt;= buf) askinterval(k*2,x); if(y &gt; buf) askinterval(k*2+1,x);&#125;单点修改同样,单点修改也可以使用区间修改的代码,只需要让x和y一样就行.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111void changeinterval(int k,int x,int z) &#123; if(a[k].l==x &amp;&amp;a[k].r==x) &#123; a[k].w += (a[k].r-a[k].l+1)*z; a[k].flag += z; return; &#125; if(a[k].flag) down(k); int buf = (a[k].l+a[k].r)/2; if(x &lt;= buf) changeinterval(k*2,x,z); if(y &gt; buf) changeinterval(k*2+1,x,z); a[k].w = a[k*2].w + a[k*2+1].w;&#125;``` 老规矩,最后一道例题 [Hdu1754 I Hate It](http://acm.hdu.edu.cn/showproblem.php?pid=1754 "Hdu1754 I Hate It") 解题代码如下:```cpp#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;vector&gt;#define For(a,b) for(ll a=0;a&lt;b;a++)#define mem(a,b) memset(a,b,sizeof(a))#define _mem(a,b) memset(a,0,(b+1)&lt;&lt;2)#define lowbit(a) ((a)&amp;-(a))#define IO do&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);&#125;while(0)using namespace std;typedef long long ll;const ll maxn = 2*1e5+5;const ll INF = 0x3f3f3f3f;struct node &#123; ll l,r,w,flag;&#125; a[maxn&lt;&lt;2]; //4倍空间ll c[maxn];ll cnt;void build(ll k,ll l,ll r) &#123; a[k].l = l,a[k].r = r; if(a[k].l == a[k].r) &#123; scanf("%lld",&amp;a[k].w); //cin &gt;&gt; a[k].w; return; &#125; build(k*2, l, (l+r)/2); build(k*2+1, (l+r)/2+1, r); a[k].w = max(a[k*2].w,a[k*2+1].w);&#125;void changellerval(ll k,ll x,ll z) &#123; if(a[k].l==x &amp;&amp;a[k].r==x) &#123; a[k].w = z; return; &#125; ll buf = (a[k].l+a[k].r)/2; if(x &lt;= buf) changellerval(k*2,x,z); if(x &gt; buf) changellerval(k*2+1,x,z); a[k].w = max(a[k*2].w, a[k*2+1].w);&#125;ll ans;void askllerval(ll k,ll x,ll y) &#123; if(a[k].l&gt;=x &amp;&amp; a[k].r&lt;=y) &#123; ans = max(a[k].w,ans); return; &#125; ll buf = (a[k].l+a[k].r)/2; if(x &lt;= buf) askllerval(k*2,x,y); if(y &gt; buf) askllerval(k*2+1,x,y);&#125;int main() &#123; //IO; char buf; ll n,m; ll x,y,z; while(cin &gt;&gt; n &gt;&gt; m) &#123; build(1,1,n); For(i,m) &#123; getchar(); scanf("%c",&amp;buf); //cin &gt;&gt; buf; if(buf == 'Q') &#123; scanf("%lld%lld",&amp;x,&amp;y); //cin &gt;&gt; x &gt;&gt; y; ans = 0; askllerval(1,x,y); printf("%lldn",ans); //cout &lt;&lt; ans &lt;&lt; endl; &#125; else &#123; scanf("%lld%lld",&amp;x,&amp;z); //cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; changellerval(1,x,z); &#125; &#125; &#125; return 0;&#125;线段树模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//最好是全局开long long#include &lt;bits/stdc++.h&gt;using namespace std;#define mem(a, b) memset(a, b, sizeof a)#define IN freopen("in.txt", "r", stdin)#define DEBUG(a) cout &lt;&lt; (a) &lt;&lt; endltypedef long long ll;int dir8[8][2] = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;&#125;;int dir4[4][2] = &#123;1, 0, 0, 1, -1, 0, 0, -1&#125;;const int INF = 0x3f3f3f3f;int mod = 1e9 + 7;const int maxn = 1e5 + 10;struct node&#123; int l, r, w, flag; int dis() &#123; return r - l + 1; &#125; int mid() &#123; return (r + l) / 2; &#125;&#125; a[maxn * 4];void build(int k, int l, int r)&#123; //当前节点的区间 a[k] = &#123;l, r, 0, 0&#125;; if (l == r) &#123; cin &gt;&gt; a[k].w; return; &#125; build(k &lt;&lt; 1, l, a[k].mid()); build(k &lt;&lt; 1 | 1, a[k].mid() + 1, r); a[k].w = a[k &lt;&lt; 1].w + a[k &lt;&lt; 1 | 1].w;&#125;void down(int k)&#123; a[k &lt;&lt; 1].w += a[k &lt;&lt; 1].dis() * a[k].flag; a[k &lt;&lt; 1 | 1].w += a[k &lt;&lt; 1 | 1].dis() * a[k].flag; a[k &lt;&lt; 1].flag += a[k].flag; a[k &lt;&lt; 1 | 1].flag += a[k].flag; a[k].flag = 0;&#125;void update(int k, int l, int r, int w)&#123; // 要更新的总区间.(l,r)不变 if (a[k].l &gt;= l &amp;&amp; a[k].r &lt;= r) &#123; a[k].w += w * a[k].dis(); a[k].flag += w; return; &#125; if (a[k].flag) down(k); if (a[k].mid() &gt;= l) update(k &lt;&lt; 1, l, r, w); if (a[k].mid() &lt; r) update(k &lt;&lt; 1 | 1, l, r, w); a[k].w = a[k &lt;&lt; 1].w + a[k &lt;&lt; 1 | 1].w;&#125;int query(int k, int l, int r)&#123; if (a[k].l &gt;= l &amp;&amp; a[k].r &lt;= r) return a[k].w; if (a[k].flag) down(k); int sum = 0; if (a[k].mid() &gt;= l) sum += query(k &lt;&lt; 1, l, r); if (a[k].mid() &lt; r) sum += query(k &lt;&lt; 1 | 1, l, r); a[k].w = a[k &lt;&lt; 1].w + a[k &lt;&lt; 1 | 1].w; return sum;&#125;int main()&#123; //IN; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; build(1, 1, n); while (m--) &#123; int func; int l, r, w; cin &gt;&gt; func; if (func == 1) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; w; update(1, l, r, w); &#125; else if (func == 2) &#123; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(1, l, r) &lt;&lt; endl; &#125; /* code */ &#125; return 0;&#125;最后线段树重要的其实不是它本身,而是以后学习其他相关算法的基石,区间查询 / 修改这个特性使得线段树能够和 树链剖分 或者其他数据结构联动,从而达到解题的目的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2159 FATE(二维背包、带限制条件的背包问题)]]></title>
    <url>%2F2019%2F04%2F28%2F480%2F</url>
    <content type="text"><![CDATA[题目传送门 题意很明显，就不细说了 我们这里可以把剩下的忍耐度看作背包容量，然后价值就是杀了怪所得的经验 用第二维表示杀了q只怪，这样就能用dp[j][q]表示已消耗j点忍耐度,杀了q只怪时的经验值 状态转移方程 a[i]表示杀死i怪物所获得的经验 b[i]表示杀死i怪物所消耗的忍耐值 对于第i个怪物： （1）杀：此时我们消耗点忍耐度，同时击杀怪物数+1,并且获得a[i]点经验 （2）不杀：此时我们忍耐度不变，击杀怪物数不变，由于空间已经优化到二维，所以有dp[j][q]=dp[j][q] 综合即为上述状态转移方程 代码如下：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define For(a,b) for(int a=0;a&lt;b;a++)#define mem(a,b) memset(a,b,sizeof(a))using namespace std;typedef long long ll;const int maxn = 1e2+10;const int INF = 0x3f3f3f3f;const int inf = 0x3f;const double EPS = 1e-7;const int MOD = 1e9+7;int dp[maxn][maxn];int a[maxn];int b[maxn];int n,m,k,s;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s)&#123; mem(dp,0); For(i,k) cin &gt;&gt; a[i+1] &gt;&gt; b[i+1]; for(int i=1;i&lt;=k;i++) for(int j=b[i];j&lt;=m;j++) for(int q=1;q&lt;=s;q++) dp[j][q] = max(dp[j][q],dp[j-b[i]][q-1]+a[i]); int ans = -1; for(int j=1;j&lt;=m;j++) //从小-&gt;大寻找，满足所需经验就break if(dp[j][s]&gt;=n)&#123; ans = m-j; break; &#125; cout &lt;&lt; ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01背包第K大值的求法 ----附例题hdu2639 Bone Collector II]]></title>
    <url>%2F2019%2F04%2F28%2F478%2F</url>
    <content type="text"><![CDATA[转载注明出自bestsort.cn,谢谢合作对于求次优解、第 K 优解类的问题,如果相应的最优解问题能写出状态转移方程、用动态规划解决,那么求次优解往往可以相同的复杂度解决,第 K 优解则比求最优解的复杂度上多一个系数 K。其基本思想是将每个状态都表示成有序队列,将状态转移方程中的 max/min 转化成有序队列的合并。这里仍然以 01 背包为例讲解一下。 首先看 01 背包求最优解的状态转移方程:f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。 如果要求第 K 优解,那么状态 f[i][v]就应该是一个大小为 K 的数组 f[i][v][1..K]。其中f[i][v][k]表示前 i 个物品、背包大小为 v 时,第 k 优解的值。“f[i][v]是一个大小为 K 的数组”这一句,熟悉 C 语言的同学可能比较好理解,或者也可以简单地理解为在原来的方程中加了一维。显然 f[i][v][1..K]这 K 个数是由大到小排列的（背包容量越大，对应装的东西越多，价值越高）,所以我们把它认为是一个有序队列。然后原方程就可以解释为:f[i][v]这个有序队列是由 f[i-1][v]和 f[i-1][v-c[i]]+w[i]这两个有序队列合并得到的。有序队列 f[i-1][v]即 f[i-1][v][1..K],f[i-1][v-c[i]]+w[i]则理解为在 f[i-1][v-c[i]][1..K]的每个数上加上 w[i]后得到的有序队列。合并这两个有序队列并将结果(的前 K 项)储存到 f[i][v][1..K]中的复杂度是 O(K)。最后的答案是f[N][V][K]。总的复杂度是 O(NVK)。为什么这个方法正确呢?实际上,一个正确的状态转移方程的求解过程遍历了所有可用的策略,也就覆盖了问题的所有方案。只不过由于是求最优解,所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为 K 的数组,并在这个数组中有序的保存该状态可取到的&gt;前 K 个最优值。那么,对于任两个状态的 max 运算等价于两个由大到小的有序队列的合并。另外还要注意题目对于“第 K 优解”的定义,将策略不同但权值相同的两个方&gt;案是看作同一个解还是不同的解。如果是前者,则维护有序队列时要保证队列里的数没有重复的。 ———————-摘自《算法九讲》而我们知道，对于01背包，我们能使用滚动数组将f数组从二维优化到一维，同理对与第K大这个问题也是能优化掉一维的。所以只需要两个缓存数组，分别存下上一件物品的状态，然后合并到f[j][q]中即可，其中，j为背包容量，q为第q大值（物品件数那一维被优化掉） 例题链接 t组数据，给出n,m,k（分别为物品数，背包容量，要求的第K大） 接下来2*n行，先输入价值，后输入占据的容量 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define For(a,b) for(int a=0;a&lt;b;a++)#define mem(a,b) memset(a,b,sizeof(a))using namespace std;typedef long long ll;const int maxn = 1005;const int INF = 0x3f3f3f3f;const int inf = 0x3f;int v[maxn]; ///nint w[maxn]; ///mint a[maxn];int b[maxn];int dp[maxn][35];///n\mint main() &#123; int t,n,m; int k; int x,y,z; cin &gt;&gt; t ; while(t--)&#123; cin &gt;&gt; n &gt;&gt;m &gt;&gt;k; mem(dp,0); For(i,n) cin &gt;&gt; v[i]; For(i,n) cin &gt;&gt; w[i];/*-------------------------------01背包第K大主代码----------------------------------*/ For(i,n) for(int j=m;j&gt;=w[i];j--)&#123; For(q,k)&#123; //多一重循环，存上一层的状态 a[q] = dp[j][q]; b[q] = dp[j-w[i]][q]+v[i]; &#125; a[k] = b[k] = -1; //只求到第K大就行了，这里设置上界为K x = y = z = 0; while((x&lt;k||y&lt;k)&amp;&amp;z&lt;k)&#123; //开始合并 a[x]&gt;b[y]?dp[j][z]=a[x++]:dp[j][z]=b[y++]; //合并a[x]和b[y]中小的那一个 if(z==0||dp[j][z-1]!=dp[j][z])//确保数组中没有重复的数字 z++; &#125; &#125; cout &lt;&lt; dp[m][k-1] &lt;&lt; endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ STL标准模板库（pair set vector string stack queue map 使用详解）]]></title>
    <url>%2F2019%2F04%2F28%2F461%2F</url>
    <content type="text"><![CDATA[pair位于头文件&lt;iostream&gt;中用来表示一个二元组或元素对使用pair定义一个pair对象表示一个平面面坐标点:pair&lt;double, double&gt; p; cin &gt;&gt; p.first &gt;&gt; p.second; pair模版类需要两个参数:首元素的数据类型和尾元素的数据类型。pair模版类对象有两个成 员:first和second,分别表示首元素和尾元素。 向上述q中存入数据需要用到q.make_pair(first,second); 对pair排序默认先为first，后second，如果需要先对second排序，需要设一个比较函数int cmp(pair&lt;int ,int &gt; a,pair&lt;int,int&gt;b){ return a.second &gt; b.second; } set使用set123456789101112131415161718192021/*set底层实现：红黑树时间复杂度： 插入/查询：log（n）*/set&lt;int&gt; s;set&lt;double&gt; ss;set的基本操作:s.begin() //返回指向第一个元素的迭代器s.clear() //清除所有元素s.count() //返回某个值元素的个数s.empty() //如果集合为空,返回true(真)s.end() //返回指向最后一个元素之后的迭代器,不是最后一个元素s.erase() //删除集合中的元素s.find() //返回一个指向被查找到元素的迭代器s.insert() //在集合中插入元素s.lower_bound() //返回指向大于(或等于)某值的第一个元素的迭代器s.size() //集合中元素的数目s.swap() //交换两个集合变量s.upper_bound() //返回大于某个值元素的迭代器vectorvector的基本操作:12345678910111213141516171819202122/*vector底层实现：数组时间复杂度： 查询： 下标查询O(1) 值查询O（n） 插入O（n）数据量较大时尽量不要使用vector，vector每一次内存不够之后都会申请双倍内存，然后将当前vector内所有内容拷贝新空间中*/#include&lt;vector&gt;vector &lt;int&gt; s;s[i] // 直接以下标方式访问容器中的元素s.front() // 返回首元素s.back() // 返回尾元素s.push_back(x) // 向表尾插入元素xs.size() // 返回表长s.empty() // 表为空时,返回真,否则返回假s.pop_back() // 删除表尾元素s.begin() // 返回指向首元素的随机存取迭代器s.end() // 返回指向尾元素的下一个位置的随机存取迭代器s.clear() // 删除容器中的所有元素s.swap(v) // 将s与另一个vector对象进行交换stringstring 可以赋值给char，但是char不能赋值给string string使用：1234567891011121314151617#include&lt;string&gt;string s;cin &gt;&gt; s;s += "sada";s.find("sa"); /*从左-&gt;右查找子串返回子串首字母的下标。c11中可以定义auto 变量接收c11以下编译标准需定义迭代器接收返回值查找不到返回npos(string中的宏定义)判定指定子串是否存在:if(s.find("sa")!=string::npos) *******下同*/s.rfind("sa"); //从右-&gt;左查找字串，if(s[0] == 'a') cout &lt;&lt;"s[0] == a"&lt;&lt;endllstack1234567891011121314/*stack底层实现：deque*/#include&lt;stack&gt;stack&lt;int&gt; s;a = 1;s.push(1) //入栈;s.pop() //出栈;int Top = s.top() //访问栈顶if(s.empty()==0) //判空，为空时返回1 cout &lt;&lt; “非空” &lt;&lt;endl;cout &lt;&lt; s.size() &lt;&lt;endl;//访问栈中元素个数;queue下列表格中带*表示括号内无内容 否则括号内需要填要操作的元素 比如：name.pop()name.push(1)DateType为任意数据类型名字普通队列双端队列优先队列头文件#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;queue&gt;声明queue&lt;DateType&gt; namedeque&lt;DateType&gt; namepriority_queue &lt;DateType&gt; name（默认 从小到大排序）取出队首的值name.front（）name.front(),name.back()name.top()弹出元素（删掉，不取值）name.pop ()name.pop_back ()-&gt; 弹出队尾 name.pop_front ()-&gt; 弹出队首name.pop ()存入元素name.push()name.push_back ()-&gt; 存入队尾 name.push_front ()-&gt; 存入队首name.push()求队列中元素个数name.size ()name.size ()name.size ()其中，优先队列还能够自定义优先级 这时我们可以传入一个比较函数struct cmp{ bool operator ()(int &amp;a,int &amp;b){ return a&lt;b; } }; priority_queue&lt;int, vector&lt;int&gt;,cmp &gt; Queue; 其中 第二个参数为容器类型 第三个参数为比较函数mapmap为一个映射，相当于python中的字典 可以将map看作是由Key标识元素的元素集合,这类容器器也被称为“关联容器”,可以通过一个Key值来快速决定一个元素,因此非常适合于需要按照Key值查找元素的容器1234567891011121314151617181920212223#include &lt;map&gt;/*set底层实现：红黑树时间复杂度： 插入/查询：log（n）*/map &lt;int,int &gt;m;m[key] = value;// [key]操作是map很有特色的操作,如果在map中存在键值为key的元素对, 则返回该元素对的值域部分,否则将会创建一个键值为key的元素对,值域为默认值。所以可以用该操作向map中插入元素对或修改已经存在的元素对的值域部分。//其实还有一种调用类函数insert的插入方法，但是既然map重载了[]运算符//就只介绍了最简单的这一种int i = m[key];// 要注意的是,当与该键值相匹配的元素对不不存在时,会创建键值为key(当另一个元素是整形时,m[key]=0)的元素对。map&lt;string, int&gt;::iterator it = m.find(key); // 如果map中存在与key相匹配的键值时,find操作将返回指向该元素对的迭代器,否则,返回的迭代器等于map的end()(参⻅见vector中提到的begin()和end()操作)。//c11中可以用auto it = m.find(key);m.erase(key);// 删除与指定key键值相匹配的元素对,并返回被删除的元素的个数。m.size();// 返回元素个数m.empty();// 判断是否为空m.clear();// 清空所有元素]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ algorithm算法库 acm常用函数统计]]></title>
    <url>%2F2019%2F04%2F28%2F458%2F</url>
    <content type="text"><![CDATA[转载注明出自bestsort.cn,谢谢合作函数统计字符串相关substr()substr 方法将返回一个包含从 start 到最后（不包含 end ）的子字符串的字符串。string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = “567”string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = “56789”求gcd__gcd(a,b).(两个下划线开头)int a=34,b=4; cout &lt;&lt; __gcd(a,b)&lt;&lt;endl; 注：部分oj可能不支持调用__gcd;求全排列求数组a的上一个排列prev_permutation（a，a+a.size（））int a[] = {1,4,2,3};prev_permutation(a,a+4); for(int i=0;i&lt;4;i++) cout &lt;&lt; a[i] &lt;&lt; endl; return 0; 求数组a的下一个排列next_permutation(a,a+.size())int a[] = {1,4,2,3};next_permutation(a,a+4); for(int i=0;i&lt;4;i++) cout &lt;&lt; a[i] &lt;&lt; endl; return 0; 二分此类目下两个函数都是返回的地址，所以要求下标则需要减去初始地址a - 查找大于或等于x的第一个位置 lower_bound（a,a+a.size(),x）int a[] = {1,3,5,7,9,11}; cout &lt;&lt; a[lower_bound(a,a+6,7)-a] &lt;&lt; endl; -查找第一个大于x的数字的位置upper_bound(a,a+a.size(),x)。用法同上初始化将a数组中前n项填充数字x：fill（a,a+n,x）cstring中，将a数组前n个内容初始化为bmemset（a，b，n&lt;&lt;2），b只能0，-1，0x3f，初始化的结果分别为0，-1，0x3f3f3f3f(无穷大)，用于做题时推荐写memset(a,b,(n+3)&lt;&lt;2)防止出错其他翻转a[x]-a[y]之间的内容：reverse（a+x,a+y）翻转区间[x，y)交换a，b的值`swap（a，b）x转化为二进制中1的个数__builtin_popcount(x)]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeblocks使用指南]]></title>
    <url>%2F2019%2F04%2F28%2F439%2F</url>
    <content type="text"><![CDATA[目录创建c/c++项目左上角File-&gt;new-&gt;project，然后在弹出的对话框中找到Console application点击Go,然后不断Next,中间的除了项目名和项目地址其他默认即可。! 然后在左侧工程目录中点开main文件即可Coding了。（不小心关闭左侧工程目录栏的可以按Shift+F2展开目录） 调试任选一行按F5设置断点，然后F4直接运行到断点处（第8行红点），或者按F7进行单步调试，调试信息可以在顶部菜单栏的Debug-&gt;Debugging windows中查看，或者点下图这个小虫子按钮 栏目中有监视，寄存器，反汇编，调用堆栈，内存等，看一个单词基本就知道什么意思了（计算机组成原理用，写程序只需会Debug即可），这里说一下怎样Debug 点开顶部菜单栏的Debug-&gt;Debugging windows-&gt;Watches,里面会显示当前函数体内的变量如下： 当然Watches界面不止这点功能，你还能通过手动输入查看你想查看的所有信息，如下图 codeblocks快捷键带*表示可以用于多行代码、按住Ctrl，滚动鼠标滚轮，放大或缩小字体。Ctrl+Shift+C注释掉当前行或选中部分*Ctrl+Shift+X解除注释*Tab：缩进当前行或选中块*Shift+Tab：减少缩进*Ctrl+Z：撤销Ctrl+Shift+Z/Ctrl+Y：反悔撤销。Ctrl+C：复制。Ctrl+V：粘贴。Ctrl+X：剪切。Ctrl+A：全选。F9：编译并运行当前代码（如果编译错误会提示错误而不会运行）F5：当前行设置断点F4：运行到断点Shift+F11:全屏F7：下一行代码Shift + F7：进入下一行代码（进入函数等等）Ctrl + C：终止正在运行的程序Ctrl + Z：终止输入F2：开/关下方日志栏Shift+F2：开/关左边目录*]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[划分树 详解及模板]]></title>
    <url>%2F2019%2F04%2F28%2F435%2F</url>
    <content type="text"><![CDATA[划分树的目的：求区间内第K大数。对于此类问题，暴力的话直接对区间进行sort，但是时间复杂度很高，如果q次查询的话嘛，时间复杂度$O(q_n_log(n))$ 为了降低时间复杂度，我们采取将数组构造成树的形式，这样,时间复杂度能降到$log(n)$,但是空间复杂度为$n*log(n)$. 建树规则为：小于等于中位数的放在左子树，大于中位数的放在右子树，以$1-9$的随机数组为例，建树方式如下： 这样，我们查询的时候只需要对构造好的树像线段树一样，不断向下递归到指定区间即可 需要注意的是以下几点划分树的构造需要平衡左右子树的元素个数，也就是说，如果是$[1,1,1,1,1,1,1,1]$$（8个1）$这样的数组，进入左右子树的元素都得是4个，这样才能避免极端数据卡时间的情况。 为了处理这种特殊情况，我们在还没有进行划分之前，先假设中值左边的数据都小于中值。 即 设置一个flag标记，令$flag= mid - l + 1$,其中$flag$为区间内元素个数的一半，$l$为区间左端点，$mid - l + 1$即为区间内元素的一半（因为区间$[l,r]$包含了$l和r$两个端点）。 如果当前的数小于中值,就使$flag$减一. 如果结果如我们假设的那样，那么$flag$最后一定等于1，否则，就说明中值的数量不唯一。那么在下面进行的时候，如果还剩$flag$&gt;1，就先把中值放在左子树，直到$flag$为0，如果仍还有中值，就把剩下的放进右子树。建树是分层的，所以我们要用二维数组去存储，第一维只需要20就够了，因为100000的数据量的话，它的层数为$log(n)$。划分的数永远存放在它的下一层,因为当前层的数据是由上一层划分来的（小于等于放入左子树，大于放入右子树）为了查找，我们还需要设一个二维数组$cnt$，其中，$cnt[i][j]$ 存的是 第 i 层，当前划分区间$[l,r]$里进入左子树的个数.这样，当我们查询的时候，就能根据$cnt$数组提供的信息判断当前查询的区间是在下一个左区间还是右区间。附上建树+查询的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#define _mid(a,b) ((a+b)/2)using namespace std;typedef long long ll;const int maxn = 1e5+10;const int INF = 0x3f3f3f3f;int sorted[maxn];int cnt[20][maxn];int tree[20][maxn];void build(int l,int r,int k)&#123; if(r==l) //如果区间内只有一个数，返回 return; int mid = _mid(l,r),flag = mid-l+1;//求出flag for(int i=l;i&lt;=r;i++) if(tree[k][i] &lt; sorted[mid]) //sorted代表排序好了的数组 flag -- ; int bufl = l,bufr = mid+1; for(int i=l;i&lt;=r;i++)&#123; cnt[k][i] = (i==l)?0:cnt[k][i-1]; //初始化 if(tree[k][i]&lt;sorted[mid] || tree[k][i]==sorted[mid]&amp;&amp;flag&gt;0)&#123;//如果有多个中值 tree[k+1][bufl++] = tree[k][i]; cnt[k][i]++; //进入左子树 if(tree[k][i] == sorted[mid]) flag--; &#125; else //进入右子树 tree[k+1][bufr++] = tree[k][i]; &#125; build(l,mid,k+1); build(mid+1,r,k+1);&#125;int ask(int k,int sl,int sr,int l,int r,int x)&#123; if(sl==sr) return tree[k][sl]; int cntl; cntl = (l==sl)?0:cnt[k][l-1]; //是否和查询区间重合 int cntl2r = cnt[k][r]-cntl; //计算l到r有cntl2r个数进入左子树 if(cntl2r &gt;= x) //如果大于当前查询的k则进入左子树（因为左子树中最大的数大于第k大的数） return ask(k+1,sl,_mid(sl,sr),sl+cntl,sl+cnt[k][r]-1,x); else&#123; //否则进入右子树 int lr = _mid(sl,sr) + 1 + (l-sl-cntl); return ask(k+1,_mid(sl,sr)+1,sr,lr,lr+r-l-cntl2r,x-cntl2r); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>划分树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher算法详解及模板(求解最长回文串)]]></title>
    <url>%2F2019%2F04%2F28%2F424%2F</url>
    <content type="text"><![CDATA[Manacher用于求解最长回文子串。所谓回文串，便是&quot;abccba&quot;或是斗鸡山上山鸡斗这一类的，你会发现从左到右和从右到左读都是同样的内容。而最长回文子串便是求出给定串中最长的那一个回文串。 在没了解Manacher之前，我们可以直接暴力枚举，时间复杂度$O(n^3)$，也可以用聪明一点的方法，每次枚举一个点，比较它左右距离相同的点是否相同，时间复杂度$O(n^2)$。 不过 Manacher时间复杂度为$O(n)$ 用过中心检测法（就是上面说的$O(n^2)$的算法）的都知道对于奇数回文串和偶数回文串的处理是不同的，奇数回文串有$2n+1$个字符，所以中心字符一定只有一个。而同理，对于偶数回文串，中心字符有2个。这样1个和2个的情况不好处理，所以我们将给出的串统一转化为奇数回文串。我们将每一个字符的左边和右边都添加一个字符（这个字符是输入中所没有的）。一般都为#。比如说abc和abcd这两个串转化后就为#a#b#c#和#a#b#c#d#。长度分别为$7$和$9$这样无论奇偶都能被转换成奇数回文串了. 其实在我看来,Manacher就是优化后的中心检测法,和KMP算法类似,Manacher的思想也是避免”匹配”失败后的下标回退转载注明出自bestsort.cn,谢谢合作下面正式开始分析算法 首先,我们需要了解一个叫做回文半径的东西 如上图,P点为中心点,ABCDEDCBA构成一个回文串,那么$r$的长度就是该回文串的回文半径 我们都知道,中心检测法是依次枚举每一个点的回文半径,取所有回文半径的最大值.当当前字符满足回文条件的时候,检测下一个字符,否则返回当前半径长度,然后回文半径长度回退为1开始检测下一点.但是这个回退是可以避免的 这里用图解的形式解释一下: 先设之前已经匹配好了的最大回文半径长为$R$,然后设当前点的回文半径为$r$,其中,$r$的起点一定大于$R$的起点(因为处理$r$的时候$R$已经处理好了) 那么$R$和$r$的关系一定有如下3种情况 1.r右端点&lt;=R右端点&amp;&amp;r左端点&gt;=R中心点,如图示这种情况 我们这里先给出$r$段关于$R$中心点所对称的线段$r_1$ 因为$r$和$r_1$是关于$R$中心点对称的，所以$r$的回文半径一定等于$r_1$ 对于此种情况,可以从图中看出来$r$的回文半径一定小于$R$的回文半径,因为图中以蓝色竖线为起点包含的字符数小于以黑色竖线为起点所包含的字符数.所以这种情况下,回文半径最大值仍为$R$. 2.右端点&lt; R右端点&amp;&amp;r左端点&lt; R中心点，如下图 还是和1一样，我们先画出关于R中心点对称的$r_1$ 我们在这副图中也能找到对称的线段,如下图 红色和红色对对称，蓝色和蓝色对称，所以，$r$和$r_1$仍然关于$R$中心点对称，也就是$r$的回文半径依旧等于$r_1$的回文半径. 3.r右端点&gt;R右端点** 还是和上面一样处理成下图 靠下的$蓝色虚线+蓝色实线+黄色实线=之前的r$ 有了上面的基础，我们现在唯一需要查询的就是黄线部分了，这里将回文半径由$R$继续扩大就好到此,原理说完了,我们来看看代码怎么写的吧先放上伪码12345678910111213141516/*String:加'#'处理后的回文串MaxR:最长回文半径flag:最长回文半径对应的中心点下标cnt[i]:以i为中心对应的回文半径length:String长度*/ for i to length if MaxR &gt; i: //如果当前点被最长回文半径包含 cnt[i]=min(cnt[2*flag-i],MaxR-i) //取情况1和情况2中较小的（防止超出MaxR范围） else: cnt[i]=1 while(String[i+cnt[i]] == String[i-cnt[i]]): cnt[i]++; if i+cnt[i] &gt; MaxR: MaxR=i+cnt[i],flag=i;下面上正式代码123456789101112131415161718192021222324252627int cnt[maxn];void Manacher(char s[],int len) &#123;//原字符串和串长 int l = 0; String[l++] = '$'; // 0下标存储为其他字符,防止越界 String[l++] = '#'; for (int i = 0; i &lt; len; i++) &#123; String[l++] = s[i]; String[l++] = '#'; &#125; String[l] = 0; // 空字符 int MaxR = 0; int flag = 0; for (int i = 0; i &lt; l; i++) &#123; cnt[i] = MaxR &gt; i ? min(cnt[2 * flag - i], MaxR - i) : 1;//2*flag-i是i点关于flag的对称点 while (String[i + cnt[i]] == String[i - cnt[i]]) cnt[i]++; if (i + cnt[i] &gt; MaxR) &#123; MaxR = i + cnt[i]; flag = i; &#125; &#125;&#125;/** String: $ # a # b # a # a # b # a # 0* cnt: 1 1 2 1 4 1 2 7 2 1 4 1 2 1 * cnt 即每个点的回文半径*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tire树（字典树）数据结构详解（图解）及模板]]></title>
    <url>%2F2019%2F04%2F28%2F418%2F</url>
    <content type="text"><![CDATA[了解这个数据结构之前我们需要了解它能被用来做什么字典树又称单词查找树，Tire树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。说到底,字典树就是用来查询公共前缀的一个工具,延伸的话可以用来进行串匹配,词频统计等,也是学AC自动机的前置技能. 所谓的字典树,其实就是一个n叉树我们对于每个字母,如果有公共前缀的,我们找到它的前缀,在后面不同的部分建立不同的子节点,比如说apple,appear,appxy 三个不同的单词,公共前缀为app,所以建树如下: 如果下面有一个单词为apzl的话,建树如下 也就是只注意前缀相同的部分,后面即使有一样的字母也重新建立子节点那么问题来了,单词的第一个字母不止A啊,应该怎么办? 其实不难,学过二分图的应该能想出来:设置一个超级源点,我们在第一个字母上面再设一个超级源点,这样计算的时候不考虑他就行了,这样第一层就可以和下面的子节点一样建立了 如图所示(ps:此图有误,apply应该为appxy) 又是喜(sang)闻(xin)乐(bing)见(kuang)的代码环节了 个人由于ACM的原因,就只放数组实现的板子了,(反正懂原理了指针版的也挺简单的) 由于数组不能动态开内存,所以我们就得采用模拟的形式了,这里其实用了一点并查集的思想,各位客官看下图 由于不能动态分配内存,同时字典树又是比较耗费空间的,所以我们的内存分配尽可能大,开一个二维数组tire[maxn][26],然后tire[i][j] = k 代表编号为i的节点的第j个孩子是编号为k的节点,这里的j通常指当前位的字母A-Z然后关于编号,我们这里的存树方式是:如果要生成新节点,则编号++,否则编号不动,所以如上图,APPLY的对应编号应该为1,2,3,4,10,11; 同时有:tire[1][&#39;A&#39;-&#39;A&#39;] = 2; tire[2][&#39;P&#39;-&#39;A&#39;] = 3; tire[3][&#39;P&#39;-&#39;A&#39;] = 10; tire[10][&#39;X&#39;-&#39;A&#39;] = 11; tire[11][&#39;Y&#39;-&#39;A&#39;] = 0; 这样,查找的时候利用并查集的思想不断向下查找即可 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*头文件可以忽略,只是一些常用的宏*/#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;#define _mem(a,b) memset(a,0,(b+3)&lt;&lt;2)#define fori(a) for(int i=0;i&lt;a;i++)#define forj(a) for(int j=0;j&lt;a;j++)#define ifor(a) for(int i=1;i&lt;=a;i++)#define jfor(a) for(int j=1;j&lt;=a;j++)#define mem(a,b) memset(a,b,sizeof(a))#define IN freopen("in.txt","r",stdin)#define OUT freopen("out.txt","w",stdout)#define IO do&#123;\ ios::sync_with_stdio(false);\ cin.tie(0);\ cout.tie(0);&#125;while(0)#define mp(a,b) make_pair(a,b);using namespace std;typedef long long ll;const int maxn = 1e5;const int INF = 0x3f3f3f3f;const int inf = 0x3f;const double EPS = 1e-7;const double Pi = acos(-1);const int MOD = 1e9+7;int Tire[maxn][26];char str[2000005];bool v[maxn];string s;int cnt = 1;//建树,每输入一个单词到s里面就调用_insert()就好void _insert()&#123; int root = 0; fori(s.size())&#123; int next = s[i] - 'A'; if(!Tire[root][next]) Tire[root][next] = ++cnt; root = Tire[root][next]; &#125; v[root] = true;//这里用了一个标记数组表示该点存在一个完整的单词,比如说`app`和`apple` //在最后一个`p`的位置就会被标记true&#125;//查找最长公共前缀int _find(char bufs[],int leng)&#123; int root = 0; int cns = 0; int next; int res = 0; fori(leng)&#123; next = bufs[i] - 'A'; if(Tire[root][next] == 0) break; root = Tire[root][next]; cns++; if(v[root]) res = cns; &#125; return res;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 流 文件操作（输入输出流）]]></title>
    <url>%2F2019%2F04%2F28%2F412%2F</url>
    <content type="text"><![CDATA[到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。 本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型：数据类型描述ofstream该数据类型表示输出文件流，用于创建文件并向文件写入信息。ifstream该数据类型表示输入文件流，用于从文件读取信息。fstream该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 &lt;iostream&gt; 和&lt;fstream&gt;。打开文件 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。模式标志描述ios::app追加模式。所有写入都追加到文件末尾。ios::ate文件打开后定位到文件末尾。ios::in打开文件用于读取。ios::out打开文件用于写入。ios::trunc如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：ofstream outfile;outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：fstream afile;afile.open(&quot;file.dat&quot;, ios::out | ios::in );关闭文件 当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。- void close();写入文件 在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 读取文件 在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 读取 &amp; 写入实例 下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上： 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;int main ()&#123; char data[100]; // 以写模式打开文件 ofstream outfile; outfile.open("afile.dat"); cout &lt;&lt; "Writing to the file" &lt;&lt; endl; cout &lt;&lt; "Enter your name: "; cin.getline(data, 100); // 向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; "Enter your age: "; cin &gt;&gt; data; cin.ignore(); // 再次向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 outfile.close(); // 以读模式打开文件 ifstream infile; infile.open("afile.dat"); cout &lt;&lt; "Reading from the file" &lt;&lt; endl; infile &gt;&gt; data; // 在屏幕上写入数据 cout &lt;&lt; data &lt;&lt; endl; // 再次从文件读取数据，并显示它 infile &gt;&gt; data; cout &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 infile.close(); return 0;&#125;当上面的代码被编译和执行时，它会产生下列输入和输出：$./a.out Writing to the file Enter your name: Zara Enter your age: 9 Reading from the file Zara 9 上面的实例中使用了 cin 对象的附加函数，比如getline()函数从外部读取一行，ignore()函数会忽略掉之前读语句留下的多余字符。 文件位置指针 istream 和ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（&quot;seek get&quot;）和关于 ostream 的 seekp（&quot;seek put&quot;）。 seekg和seekp的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。 文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例： // 定位到 fileObject 的第 n 个字节（假设是 ios::beg） - fileObject.seekg( n ); // 把文件的读指针从 fileObject 当前位置向后移 n 个字节 - fileObject.seekg( n, ios::cur ); // 把文件的读指针从 fileObject 末尾往回移 n 个字节 - fileObject.seekg( n, ios::end ); // 定位到 fileObject 的末尾 - fileObject.seekg( 0, ios::end );该文章转自菜鸟教程]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机 算法详解(图解)及模板]]></title>
    <url>%2F2019%2F04%2F28%2F402%2F</url>
    <content type="text"><![CDATA[要学AC自动机需要自备两个前置技能:KMP和trie树(其实个人感觉不会kmp也行,失配指针的概念并不难) 其中,KMP是用于一对一的字符串匹配,而trie虽然能用于多模式匹配,但是每次匹配失败都需要进行回溯,如果模式串很长的话会很浪费时间,所以AC自动机应运而生,如同Manacher一样,AC自动机利用某些操作阻止了模式串匹配阶段的回溯,将时间复杂度优化到了$O(n)$(n)为文本串长度转载注明出自bestsort.cn,谢谢合作下面开始用图学习ac自动机吧(个人比较喜欢放图,能用一张图解决的绝不叨叨) 首先给定模式串&quot;ash&quot;,&quot;shex&quot;,&quot;bcd&quot;,&quot;sha&quot;,然后我们根据模式串建立如下trie树: 然后我们再了解下一步: ac自动机,就是在tire树的基础上,增加一个fail指针,如果当前点匹配失败,则将指针转移到fail指针指向的地方,这样就不用回溯,而可以路匹配下去了.(当前模式串后缀和fail指针指向的模式串部分前缀相同,如abce和bcd,我们找到c发现下一个要找的不是e,就跳到bcd中的c处,看看此处的下一个字符(d)是不是应该找的那一个) 一般,fail指针的构建都是用bfs实现的 首先每个模式串的首字母肯定是指向根节点的(一个字母你瞎指什么指,指了也是头字母有什么用嘛) 现在第一层bfs遍历完了,开始第二层 (根节点为第0层)第二层a的子节点为s,但是我们还是要从a-z遍历,如果不存在这个子节点我们就让他指向根节点(如下图红色的a) 当我们遍历到s的时候,由于存在s这个节点,我们就让他的fail指针指向他父亲节点(a)的fail指针指向的那个节点(根)的具有相同字母的子节点(第一层的s),也就是这样 按照相同规律构建第二层后,到了第三层的h点,还是按照上面的规则,我们找到h的父亲节点(s)fail指针指向的那个位置(第一层的s)然后指向它所指向的相同字母根-&gt;s-&gt;h的这个链的h节点,如下图 完全构造好后的树 然后匹配就很简单了,这里以ashe为例 我们先用ash匹配,到h了发现:诶这里ash是一个完整的模式串,好的ans++,然后找下一个e,可是ash后面没字母了啊,我们就跳到hfail指针指向的那个h继续找,还是没有?再跳,结果当前的h指向的是根节点,又从根节点找,然而还是没有找到e,程序END 过程如下图 注：经指出，最后一张图存在错误，最后的 h 应该指向 h 的下一节点 e，再由 e 指向根节点 喜闻乐见模板系列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;queue&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 2*1e6+9;int trie[maxn][26]; //字典树int cntword[maxn]; //记录该单词出现次数int fail[maxn]; //失败时的回溯指针int cnt = 0;void insertWords(string s)&#123; int root = 0; for(int i=0;i&lt;s.size();i++)&#123; int next = s[i] - 'a'; if(!trie[root][next]) trie[root][next] = ++cnt; root = trie[root][next]; &#125; cntword[root]++; //当前节点单词数+1&#125;void getFail()&#123; queue &lt;int&gt;q; for(int i=0;i&lt;26;i++)&#123; //将第二层所有出现了的字母扔进队列 if(trie[0][i])&#123; fail[trie[0][i]] = 0; q.push(trie[0][i]); &#125; &#125;//fail[now] -&gt;当前节点now的失败指针指向的地方////tire[now][i] -&gt; 下一个字母为i+'a'的节点的下标为tire[now][i] while(!q.empty())&#123; int now = q.front(); q.pop(); for(int i=0;i&lt;26;i++)&#123; //查询26个字母 if(trie[now][i])&#123; //如果有这个子节点为字母i+'a',则//让这个节点的失败指针指向(((他父亲节点)的失败指针所指向的那个节点)的下一个节点) //有点绕,为了方便理解特意加了括号 fail[trie[now][i]] = trie[fail[now]][i]; q.push(trie[now][i]); &#125; else//否则就让当前节点的这个子节点 //指向当前节点fail指针的这个子节点 trie[now][i] = trie[fail[now]][i]; &#125; &#125;&#125;int query(string s)&#123; int now = 0,ans = 0; for(int i=0;i&lt;s.size();i++)&#123; //遍历文本串 now = trie[now][s[i]-'a']; //从s[i]点开始寻找 for(int j=now;j &amp;&amp; cntword[j]!=-1;j=fail[j])&#123; //一直向下寻找,直到匹配失败(失败指针指向根或者当前节点已找过). ans += cntword[j]; cntword[j] = -1; //将遍历国后的节点标记,防止重复计算 &#125; &#125; return ans;&#125;int main() &#123; int n; string s; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; s ; insertWords(s); &#125; fail[0] = 0; getFail(); cin &gt;&gt; s ; cout &lt;&lt; query(s) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第k短路 算法详解（图解）与模板（A* 算法）]]></title>
    <url>%2F2019%2F04%2F28%2F396%2F</url>
    <content type="text"><![CDATA[A是一种启发式搜索，根据目标地点和当前点的距离和估计要走的步数来决策下一步走哪个方向。而这两个参数，一般用$g(x)$和$h(x)$，其中$g(x)$为$x$点到目标点的实际距离。 所以最终的我们要走哪个点取决于$g(x)+h(x)$，取可选点中$g(x)+h(x)$最优的那个点走。 *而k短路，就是终点第K次被找到的时候。 随便从网上扒了一份图，根据图来详细了解下 这份图因为在博客园出现过，在简书也出现过，且都未标注原创是谁，所以这里我直接拿来用了，如有侵权，请回复，我会删除此文现在来看看图，现在我们要从$A$点走到$B$点，假设我们可走8个方向（$↑，↓，←，→，↖，↗，↙，↘$）。（后文均用箭头代指方向） 先求出实际花费（就是↑，↓，←，→，↖，↗，↙，↘8个点到$B$点的最短路，用Dijkstra或者SPFA等常用最短路算法跑一遍就行了） 尊重原图，这里设每走一格花费为10，所以走第一步的$g$如下： ↑：50(表示从$A$向上走一步再走到$B$的最短路长为50，注意这里的50是从$A$-&gt;$A↑$到$B$的最短路，不是从$A↑$到$B$的最短路。下同) ↓：50 ←：50 →：30 ↖：60 ↗：40 ↙：60 ↘：40 上图中左下角为到B点的估算值$h（x）$, 右下角为 实际距离。左上角为二者之和。最短路问题，走过了该点就不再走第二次了，所以我们把$A，C$点标记，不再进入这2个点。然后再根据$C$点的可行路径，在所有可走范围内再次寻找加权和最小的那点，这里我们用优先队列实现这个不断BFS搜寻可行路，并且不断取出加权和最小的点的过程 最终结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 1e3+5;const int INF = 0x3f3f3f3f;int s,t,k;bool vis[maxn]; //标记该点是否已经经过int dis[maxn]; //从起点实际到终点的路径，为上文中的g（x）struct node&#123; int v,c; node(int _v=0,int _c=0) : v(_v),c(_c) &#123;&#125;; //构造 node()&#123;&#125;; bool operator &lt; (const node &amp; buf) const&#123; return c+ dis[v] &gt; buf.c + dis[buf.v]; &#125;&#125;;struct edge&#123; int v,cost; edge(int _v=0,int _c=0) : v(_v),cost(_c)&#123;&#125;;&#125;;vector &lt;edge&gt; e[maxn],reve[maxn]; //反向存图,这样从终点找一次单源最短路即可求出dispriority_queue&lt;node&gt; q;void dijkstra(int n,int s)&#123; //dijkstra+队列优化求出dis数组的内容 mem(vis,false); mem(dis,0x3f); while(!q.empty()) q.pop(); dis[s] = 0; q.push(node(s,0)); while(!q.empty())&#123; node tmp = q.top(); q.pop(); int u = tmp.v; if(vis[u]) continue; vis[u] = true; fori(e[u].size())&#123; int v = e[u][i].v; int cost = e[u][i].cost; if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + cost)&#123; dis[v] = dis[u] + cost; q.push(node(v,dis[v])); &#125; &#125; &#125;&#125;int aStar(int s)&#123; //S为起点 while(!q.empty()) q.pop(); q.push(node(s,0)); k--; while(!q.empty())&#123; node pre = q.top(); q.pop(); int u = pre.v; if(u == t)&#123; //到达终点 if(k) k--; //不是第K次就继续找 else return pre.c; &#125; for(int i=0;i&lt;reve[u].size();i++)&#123; //将当前点所有能经过的点扔进优先队列 int v = reve[u][i].v; int c = reve[u][i].cost; //这里的h（x）我们取通过这条边的实际花费 q.push(node(v,pre.c+c)); &#125; &#125; return -1; //找不到K短路&#125;void addedge(int u,int v,int w)&#123; reve[u].pb(edge(v,w)); //反向存图 e[v].pb(edge(u,w)); //正向存图&#125;int main() &#123; IO; int n,m,u,v,w; while(cin&gt;&gt;n &gt;&gt; m)&#123; fori(n+2)&#123; e[i].clear(); reve[i].clear(); &#125; fori(m)&#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addedge(u,v,w); &#125; cin &gt;&gt; s &gt;&gt; t &gt;&gt; k; dijkstra(n,t); if(dis[s] == INF) cout &lt;&lt; -1 &lt;&lt; endl; else&#123; if(s == t) k ++; ///如果起点==终点不能算上dis = 0 的这一点 cout &lt;&lt; aStar(s) &lt;&lt; endl;; &#125; &#125; return 0;&#125;A的时间复杂度取决于h（x）函数的选择，在网上并未找到具体的分析，不过需要注意的是，如果图为n元环，A算法的时间花费将会是指数级的（摘自wiki），一般遇到这类问题的时候，都是采用可持久化可并堆进行优化，具体怎么优化。。。。。蒟蒻博主还未学习学会了再来贴上代码和分析~~~]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1070A Find a Number(BFS) 2018-2019 ICPC, NEERC, Southern Subregional Contest Problem A]]></title>
    <url>%2F2019%2F04%2F28%2F392%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given two positive integers d and s. Find minimal positive integer n which is divisible by d and has sum of digits equal to s.InputThe first line contains two positive integers d and s$(1≤d≤500,1≤s≤5000)$ separated by space.OutputPrint the required number or -1 if it doesn’t exist.Sample InputInput13 50Output699998Input61 2Output1000000000000000000000000000001Input15 50Output -1这道题是看了别人后的代码才写的，看到代码后没想到居然是个BFS（果然还是自己太菜啊） 就是让你求一个数，这个数能被$s$整除，且每位数相加$=d$。 看了别人ac的代码后发现其实很简单,运用同余定理就行了。。。。QAQ我怎么这么菜思路 先根据位数进行BFS，如果$位数和&gt;s$就不入队，剩下的每次入队前都$mod$ $d$就好了（控制数字大小别超$int$。然后当余数等于$0$（正好被$d$整除了），位数和等于$s$的时候就是答案代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;queue&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;#define lowbit(a) (a&amp;(-a))#define _mid(a,b) ((a+b)/2)#define _mem(a,b) memset(a,0,(b+3)&lt;&lt;2)#define fori(a) for(int i=0;i&lt;a;i++)#define forj(a) for(int j=0;j&lt;a;j++)#define ifor(a) for(int i=1;i&lt;=a;i++)#define jfor(a) for(int j=1;j&lt;=a;j++)#define mem(a,b) memset(a,b,sizeof(a))#define IN freopen("in.txt","r",stdin)#define OUT freopen("out.txt","w",stdout)#define IO do&#123;\ ios::sync_with_stdio(false);\ cin.tie(0);\ cout.tie(0);&#125;while(0)#define mp(a,b) make_pair(a,b)#define pb(a) push_back(a)#define debug(a) cout &lt;&lt;(a) &lt;&lt; endlusing namespace std;struct node&#123; int mod; int bit; string s; node()&#123;&#125;; node(int m,int b,string ss)&#123;mod=m,bit=b,s=ss;&#125;&#125;;bool v[501][5001];string bfs(int d,int s)&#123; queue&lt;node&gt;q; q.push(node(0,0,"")); v[0][0] = true; while(!q.empty())&#123; node buf = q.front(); q.pop(); if(buf.bit &lt;= s)&#123; if(buf.mod == 0&amp;&amp;buf.bit==s) return buf.s; fori(10)&#123; int bmod = (buf.mod*10+i)%d; int bbit = buf.bit+i; if(!v[bmod][bbit])&#123; v[bmod][bbit] = true; q.push(node(bmod,bbit,buf.s+(char)(i+'0'))); &#125; &#125; &#125; &#125; return "-1";&#125;int main() &#123; int s,d; cin &gt;&gt; d&gt;&gt; s; cout &lt;&lt; bfs(d,s) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018ACM/ICPC 亚洲区域赛(青岛) 赛后总结]]></title>
    <url>%2F2019%2F04%2F28%2F387%2F</url>
    <content type="text"><![CDATA[人生第一场区域赛结束了,作为弱校中的弱校的蒟蒻,虽然难以接受事实,但是确实被百分之八十的队给吊锤了,虽然作为17级已经做好了被吊锤的心理准备,但是真的被吊锤还是不开心的啊喂!! 归根结底还是自己太菜了,不然也不会当个打铁匠第一天日常我们是周五出发的,而且到的时候比较早,刚刚4点左右.路上zhh提议去五四广场,但是到的时候天还没黑下来(听说五四广场夜景好看到炸),就去栈桥逛了逛,风景真的好看 火烧云简直美炸 晚上去了五四广场,夜景也是极好的,可惜手机夜拍太差一拍就糊了QAQ…….第二天日常我和lf直接一觉睡到10点….赶公交车一路下去比老板慢10分钟到学校… 果然别人的大学才是真大学,站在大门前感觉都不一样 出校右拐还有摩天轮!!!!!第三天日常吃到了青岛大虾?ICPC群2大目标,栈桥吃虾get√可惜有点少志愿者小姐姐挺好看碰见了烟大的ACMer,虽然就在我们隔壁但是人家好强啊QAQ…..路上myy一直要送,抱歉老板我们五保一保不住啊热身赛出了前俩签到,C题发生了很多有趣的事情,我也是第一次知道一个题能考整个计科的课程2333333 然后就出现了下面这种结果 右上角(忘记队名了)开局不到一半时间就收工走人了,C不会zhh还想写D(其实D根本不会),推了一会儿放弃了.过了不久C不让交了(有个队随机250+??)然后玩了会数独活泛下思维?最后实在太无聊了就拉着旁边的血小板走了(第一次问他们还不走,结果我们刚走不久血小板人就跑光了,哼辣鸡人类) 整个热身赛过程挺欢乐的,有一个队问what do you think about ig的时候后台君居然回了一句ig jia you2333333正式赛正式赛的前一天晚上又做梦了……梦见A是一道矩阵快速幂递推,然后先开A,B,后开的F,然后就醒了….. 上来拿到题zhh说好像真的是大数+矩阵差点没吓我一跳,还以为这把稳了……结果自己太天真 敲了10分钟K,结果$pc^2$上面交成A了…直接WA5发,然后对着空气调试30分钟….结果还是看榜的时候才发现 WTF????怎么交的A??? 交K对了后被队友狂锤.. 然后我开C,zhh和lf搞另外一道签到,结果加黑的…..加黑的in order….两个人都没给我说,还说…..sort就好了,sort就好了 结果错了n发然后我看题面看到那个in order的时候……..sad. C充分体现了我们队的英语水平,3个人都只能翻译出大概意思…..然后根据返回结果疯狂试错…. 最终打铁收场,队牌都没拿就跑路了,太难受了总结太菜了太菜了太菜了第一次区域赛,正式赛挺紧张的其实.毕竟没这种大赛经历,但是自己的错犯的…..有点幼稚..居然交错题!?不是发生在我身上我真的不信….看到了qianqian和烟大18级OI大佬,回来得努力了青岛大虾真好吃]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this和super的用法总结]]></title>
    <url>%2F2019%2F04%2F27%2F385%2F</url>
    <content type="text"><![CDATA[这几天看到类在继承时会用到this和super，这里就做了一点总结，与各位共同交流，有错误请各位指正~thisthis是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this的用法在java中大体可以分为3种：普通的直接引用这种就不用讲了，this相当于是指向当前对象本身。形参与成员名字重名，用this来区分：123456789101112131415161718192021222324252627282930313233class Person &#123; private int age = 10; public Person()&#123; System.out.println("初始化年龄："+age);&#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125;public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println("Harrys age is "+Harry.GetAge(12)); &#125;&#125;初始化年龄：10运行结果： Harry&#39;s age is 12 可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。引用构造函数这个和super放在一起讲，见下面。supersuper可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super也有三种用法：普通的直接引用与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。子类中的成员变量或方法与父类中的成员变量或方法同名1234567891011121314151617181920212223242526272829303132333435363738394041class Country &#123; String name; void value() &#123; name = "China"; &#125;&#125; class City extends Country &#123; String name; void value() &#123; name = "Shanghai"; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125;Shanghai运行结果： China 可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。引用构造函数super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt("父类·无参数构造方法： "+"A Person."); &#125;//构造方法(1) Person(String name) &#123; prt("父类·含一个参数的构造方法： "+"A person's name is " + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt("子类·调用父类”无参数构造方法“： "+"A chinese coder."); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt("子类·调用父类”含一个参数的构造方法“： "+"his name is " + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt("子类：调用子类具有相同形参的构造方法：his age is " + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese("codersai"); cn = new Chinese("codersai", 18); &#125; &#125;父类·无参数构造方法： A Person.运行结果： 子类·调用父类”无参数构造方法： A chinese coder. 父类·含一个参数的构造方法： A person&#39;s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 父类·含一个参数的构造方法： A person&#39;s name is codersai 子类·调用父类”含一个参数的构造方法“： his name is codersai 子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。 例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。super和this的异同：super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名,super.成员函数据名（实参）this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。super()和this()类似,区别是:super()从子类中调用父类的构造方法this()在同一类内调用其它方法。super()和this()均需放在构造方法内第一行。尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。本文转自https://www.cnblogs.com/hasse/p/5023392.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java抽象类与接口的区别]]></title>
    <url>%2F2019%2F04%2F27%2F383%2F</url>
    <content type="text"><![CDATA[很多常见的面试题都会出诸如抽象类和接口有什么区别，什么情况下会使用抽象类和什么情况你会使用接口这样的问题。本文我们将仔细讨论这些话题。 在讨论它们之间的不同点之前，我们先看看抽象类、接口各自的特性。抽象类抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板。以JDK中的GenericServlet为例：1234567891011121314151617181920212223public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123; // abstract method abstract void service(ServletRequest req, ServletResponse res); void init() &#123; // Its implementation &#125; // other method related to Servlet&#125;public class HttpServlet extends GenericServlet &#123; void service(ServletRequest req, ServletResponse res) &#123; // implementation &#125; protected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; // Implementation &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) &#123; // Implementation &#125; // some other methods related to HttpServlet&#125;当HttpServlet类继承GenericServlet时，它提供了service方法的实现：接口接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。以Externalizable接口为例：1234567891011121314151617181920public interface Externalizable extends Serializable &#123; void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;&#125;public class Employee implements Externalizable &#123; int employeeId; String employeeName; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; employeeId = in.readInt(); employeeName = (String) in.readObject(); &#125; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeInt(employeeId); out.writeObject(employeeName); &#125;&#125;当你实现这个接口时，你就需要实现上面的两个方法：抽象类和接口的对比参数抽象类接口默认的方法实现它可以有默认的方法实现接口完全是抽象的。它根本不存在方法的实现实现子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现构造器抽象类可以有构造器接口不能有构造器与正常Java类的区别除了你不能实例化抽象类之外，它和普通Java类没有任何区别接口是完全不同的类型访问修饰符|抽象方法可以有public、protected和default这些修饰符|接口方法默认修饰符是public。你不可以使用其它修饰符。||main方法|抽象方法可以有main方法并且我们可以运行它|接口没有main方法，因此我们不能运行它。多继承|抽象方法可以继承一个类和实现多个接口|接口只可以继承一个或多个其它接口速度|它比接口速度要快|接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。|什么时候使用抽象类和接口如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类Java8中的默认方法和静态方法Oracle已经开始尝试向接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。现在，我们可以为接口提供默认实现的方法了并且不用强制子类来实现它。这类内容我将在下篇博客进行阐述。原文链接： javacodegeeks翻译： ImportNew.com - jessenpan译文链接： http://www.importnew.com/12399.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（组合游戏）SG函数与SG定理详解]]></title>
    <url>%2F2019%2F04%2F27%2F378%2F</url>
    <content type="text"><![CDATA[转载请注明转自bestsort.cn好了，进入主题，说一下SG函数和SG定理吧什么是组合游戏在竞赛中，组合游戏的题目一般有以下特点题目描述一般为$A$,$B$ 2人做游戏2.$A$ $B$交替进行某种游戏规定的操作，每操作一次，选手可以在有限的操作（操作必须合法）集合中任选一种。对于游戏的任何一种可能的局面，合法的操作集合只取决于这个局面本身，不取决于其它因素（跟选手，以前的所有操作无关）如果当前选手无法进行合法的操作，则为负举个例子现在有一个数0,小明小红2人每次可以轮流在当前数加 1~3，谁先凑到21谁就赢 这个描述就符合上面的条件： - 小明小红（满足1） - 每次轮流在当前数上加1～3（满足2） - 当前能进行的操作只取决于这个数本身（也就是这个局面），如果这个数为20,可操作的集合为+{1}，如果为12,可操作的集合为+{1,2,3}（满足3） - 如果数字已经为21了,则不可能往上在加数字，可操作集合为$\Phi$，当前选手为负（满足4）必胜点和必败点的概念必败点(P点) 前一个(previous player)选手将取胜的点称为必败点必胜点(N点) 下一个(next player)选手将取胜的点称为必胜点比如现在数字已经为18了，那么当前操作人只要给数字+3则必胜，我们就把在此位置称为必胜点（正常操作情况下，别杠说都18偏要+2。。。。）必胜点和必败点的性质：所有的终结点都是必败点从任何必胜点操作，至少有一种方式进入必败点无论如何操作， 从必败点都只能进入必胜点.Sprague-Grundy(SG)定理游戏和的SG函数等于各个游戏SG函数的Nim和。这样就可以将每一个子游戏分而治之，从而简化了问题。而Bouton定理就是Sprague-Grundy定理在Nim游戏中的直接应用，因为单堆的Nim游戏 SG函数满足 SG(x) = x。Nim和 ： 各个数相异或的结果SG函数先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 对于任意状态 x ， 定义 SG(x) = mex(S),其中 $S$是 $x$ 后继状态的$SG$函数值的集合。如 x 有三个后继状态分别为 $SG(a),SG(b),SG(c)$，那么$SG(x) = mex${$SG(a$,$SG(b)$,$SG(c))$}。 这样 集合$S$ 的终态必然是空集，所以SG函数的终态为 $SG(x) = 0$,当且仅当 x 为必败点P时。取石子问题 有1堆n个的石子，每次只能取{ 1, 3, 4 }个石子，先取完石子者胜利，那么各个数的SG值为多少？SG[0]=0，f[]={1,3,4}x=1 时，可以取走1 - f{1}个石子，剩余{0}个，所以 SG[1] = mex{ SG[0] }= mex{0} = 1;x=2 时，可以取走2 - f{1}个石子，剩余{1}个，所以 SG[2] = mex{ SG[1] }= mex{1} = 0;x=3 时，可以取走3 - f{1,3}个石子，剩余{2,0}个，所以 SG[3] = mex{SG[2],SG[0]} = mex{0,0} =1;x=4 时，可以取走4- f{1,3,4}个石子，剩余{3,1,0}个，所以 SG[4] = mex{SG[3],SG[1],SG[0]} = mex{1,1,0} = 2;x=5 时，可以取走5 - f{1,3,4}个石子，剩余{4,2,1}个，所以SG[5] = mex{SG[4],SG[2],SG[1]} =mex{2,0,1} = 3;以此类推….. x 0 1 2 3 4 5 6 7 8…. SG[x] 0 1 0 1 2 3 2 0 1….由上述实例我们就可以得到SG函数值求解步骤，那么计算1~n的SG函数值步骤如下：1、使用 数组f 将 可改变当前状态 的方式记录下来。2、然后我们使用 另一个数组 将当前状态x 的后继状态标记。3、最后模拟mex运算，也就是我们在标记值中 搜索 未被标记值 的最小值，将其赋值给SG(x)。4、我们不断的重复 2 - 3 的步骤，就完成了 计算1~n 的函数值。模板如下：12345678910111213141516171819//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理//SG[]:0~n的SG函数值//S[]:为x后继状态的集合int f[N],SG[MAXN],S[MAXN];void getSG(int n)&#123; int i,j; memset(SG,0,sizeof(SG)); //因为SG[0]始终等于0，所以i从1开始 for(i = 1; i &lt;= n; i++)&#123; //每一次都要将上一状态 的 后继集合 重置 memset(S,0,sizeof(S)); for(j = 0; f[j] &lt;= i &amp;&amp; j &lt;= N; j++) S[SG[i-f[j]]] = 1; //将后继状态的SG函数值进行标记 for(j = 0;; j++) if(!S[j])&#123; //查询当前后继状态SG值中最小的非零值 SG[i] = j; break; &#125; &#125;&#125;其实不难发现，Nim游戏就是一个很典型的用SG定理解决的问题，因为Nim游戏在一堆n个石子中可以取1-n个石子，所以单独这一堆石子的SG值为$mex（n-1,n-2,n-3,…,n-n） = n$，根据SG定理，每一堆石子总数相互异或即为答案本文是参考其他博文+自己理解，整理而来，现附上参考博文链接：https://blog.csdn.net/luomingjun12315/article/details/45555495https://blog.csdn.net/SM_545/article/details/77340690]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>SG函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVALive 7832 Dictionary Game解题报告（字典树+树上删边游戏）]]></title>
    <url>%2F2019%2F04%2F27%2F376%2F</url>
    <content type="text"><![CDATA[questionWe all know the famous game scrabble, where we want to make words using tiles. We will play a game with words. But it is reverse of scrabble. Here instead of making words we want to destroy them. It is a two player game. The game starts with a dictionary of words. At each move, the current player chooses a word of his choice (not necessarily from the dictionary). The constraints for choosing the word is, it must match the prefix of any (one or more) of the current dictionary words. When a player chooses a word as its move, all the dictionary words that has a prefix equal to the chosen word, are split into two parts:The matched part without the last character of the chosen word.The unmatched part starting from the last character of the chosen word. We remove all the unmatched part from the dictionary and keep only the matched part in the dictionary. The words that don’t have matched prefix with the chosen word are kept intact in the dictionary. In this situation the next player makes its move in the same fashion. If the chosen word is of length 1, then all the dictionary words starting with that character will be removed. For example, if we have a dictionary consisting the following words:bangladeshbangalorebandbandanaNow if the first player chooses the word “bang” then after the move the dictionary will become: ban ban band bandana A player loses, when it cannot make a valid move. Given the dictionary of words, who will win if both players played optimally? To make it more interesting, can you find out who will win if you update the dictionary by adding new words?Formally, you will be given few operations where you need to add a new word to the dictionary. After adding you need to calculate the winner between player 1 and 2 for the current dictionary. These added words are permanent. Means each of these added words will remain in the dictionary for that particular test case.InputFirst line consists of an integer T , which is the number of test cases (T ≤ 10).Each case will start with an integer N (0 &lt; N ≤ 50000), the number of words in the dictionary. Next N lines will contain dictionary words DW. Length of each DW will be less than or equal to 40.Next line will contain an integer number Q, the number of operations (0 &lt; Q ≤ 50000).Next Q lines will contain query words QW. Each QW is the word that you now want to add to the current dictionary. Let’s call these “Query words”. Length of each QW will be less than or equal to 40. All the dictionary words and query words will only consist of lower case letters. OutputFor each query word QW, you have to find out who will win, if you add QW to the current dictionary. First print the case number, then for each query print ‘1’ or ‘2’ based on whether player 1 or 2 will win.Sample Input24bangladesh bangalore band bandana 2 egg apple 1 orange 2 cat tigerSample OutputCase 1: 2 1Case 2: 1 2直接根据输入建立字典树，然后树上删边求sg即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define OUT freopen("out.txt","w",stdout)#define mem(a,b) memset(a,b,sizeof (a))#define DEBUG(a) cout &lt;&lt; (a) &lt;&lt; endl#define lowbit(a) ((a)&amp;(-a))#define IN freopen("in.txt","r",stdin)#define IO ios::sync_with_stdio(false);\ cin.tie(0);\ cout.tie(0);using namespace std;typedef long long ll;const int maxn = 5e6+10;const int PI = acos(-1);const int MOD = 1e9+7;const int INF = 0x3f3f3f3f;struct tire&#123; int son[26]; int f;&#125;a[maxn];int sg[maxn];int tot;string s;int _insert()&#123; int root = 0; for(int i=0;i&lt;s.size();i++)&#123; int buf = s[i] - 'a'; if(!a[root].son[buf])&#123; a[root].son[buf] = ++tot; a[tot].f = root; &#125; root = a[root].son[buf]; &#125; return root;&#125;void cal(int x)&#123; sg[x] = 0; for(int i=0;i&lt;26;i++) if(a[x].son[i]) sg[x] ^= sg[a[x].son[i]] + 1;&#125;void dfs(int x)&#123; for(int i=0;i&lt;26;i++) if(a[x].son[i]) dfs(a[x].son[i]); cal(x);&#125;void update(int x)&#123; while(x)&#123; cal(x); x = a[x].f; &#125; cal(0);&#125;int main()&#123; // IN; int t,n; cin &gt;&gt; t; int step = 0; while(t--)&#123; //DEBUG(t); // DEBUG(""); tot = 0; printf("Case %d:\n",++step); cin &gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; s; _insert(); &#125; dfs(0); cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; s; update(_insert()); DEBUG(sg[0]?"1":"2"); &#125; for(int i=0;i&lt;=tot;i++)&#123; a[i].f = 0; mem(a[i].son,0); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSL的魔法(并查集) “新智认知” 杯上海高校程序设计竞赛暨第十七届上海大学程序设计春季联赛]]></title>
    <url>%2F2019%2F04%2F27%2F371%2F</url>
    <content type="text"><![CDATA[题目描述有两个长度为 n 的序列，$a0,a_1,…,a{n-1}$和$b0,b_1,…,b{n-1}$。CSL 有一种魔法，每执行一次魔法，可以任意挑选一个序列并任意交换序列中两个元素的位置。CSL 使用若干次魔法，得到最终的序列 a 和 b，并且想要让 的值最小化。求解 CSL 至少使用多少次魔法，能够达到最小化的目标。输入描述:第一行有一个整数 n，表示序列的长度。 接下来两行，每行有 n 个整数，分别表示初始序列 a 和 b。 输入数据保证每个序列里的数两两不同。 $2&lt;=n&lt;=10^5$ $2&lt;=a_i,b_i&lt;=10^5$输出描述:在一行输出一个整数，表示最少使用的魔法次数。示例1输入2 1 2 1 2输出1示例2输入2 1 2 2 1输出0$PS$.$x-&gt;y$表示$a[x]$当前应该对应的数字为$b[y]$ 首先要知道 - 最终结果一定是$a[i]$升序排列,$b[i]$降序排列或者反过来,这样保证$sum{a[i]b[i]}$的结果最小 在一个$a,b$数组对中一定都为$x-&gt;y$,$y-&gt;z$,$z-&gt;x$这类情况.或者是$x-&gt;y$,$y-&gt;z$,$z-&gt;q$,$q-&gt;$x等等,这里我们称这类现象为环,定义环的大小为环中数字个数(第一种大小为3,第二种为4).极端情况下环的大小为$n$.且数组中的数都在某一环内(因为每个数都能对应另外一个数) 这里不难推断出一个大小为$x$的环需要$x-1$次操作才能让两个数字对应起来.(比如$x-&gt;y$,$y-&gt;z$,$z-&gt;x$,需要交换其中某两个数才能使得$x-&gt;x$,$y-&gt;y$,$z-&gt;z$). 所以这道题就转化为了求环的个数 所以离散化+*并查集就能解决了 这里用离散化主要是因为数据类型为$[1,1e9]$,而$n$大小只有$1e5$. 有思路了代码就简单了 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define mid(a, b) ((a + b) / 2)#define OUT freopen("out.txt", "w", stdout)#define mem(a, b) memset(a, b, sizeof(a))#define DEBUG(a) cout &lt;&lt; (a) &lt;&lt; endl#define IN freopen("in.txt", "r", stdin)#define IO ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);using namespace std;typedef long long ll;const int maxn = 1e6 + 10;const int PI = acos(-1);const int MOD = 1e9 + 7;const int INF = 0x3f3f3f3f;const double EPS = 1e-7;typedef pair&lt;int,int&gt; PIR;int a[maxn];int b[maxn];struct node&#123; int a, b;&#125; t[maxn];void disc(int n) //离散化&#123; sort(b, b + n); int m; m = unique(b, b + n) - b; for (int i = 0; i &lt; n; ++i) a[i] = lower_bound(b, b + m, a[i]) - b + 1;&#125;int c[maxn];int d[maxn];int disc1(int n)&#123; sort(c, c + n); int m; m = unique(c, c + n) - c; for (int i = 0; i &lt; n; ++i) d[i] = lower_bound(c, c + m, d[i]) - c + 1; return m;&#125;vector&lt;PIR&gt; g;int pre[maxn];void init(int n)&#123; for(int i=0;i&lt;=n;i++)&#123; pre[i] = i; &#125;&#125;/*并查集*/int _find(int x)&#123; if(x != pre[x]) pre[x] = _find(pre[x]); return pre[x];&#125;void combine(int x,int y)&#123; int fx = _find(x); int fy = _find(y); if(x&gt;y) swap(x,y); if(fx!=fy) pre[fx] = fy;&#125;/******/int vis[maxn];bool vv[maxn];void dfs(int i)&#123; //将数组分割成不同的环 if(!vv[vis[i]])&#123; vv[vis[i]] = true; combine(vis[i],i); dfs(vis[i]); &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; init(n+5); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; b[i]; a[i] = b[i]; &#125; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; c[i]; d[i] = c[i]; &#125; int buf = disc1(n); disc(n); for (int i = 0; i &lt; n; i++) &#123; d[i] = buf - d[i] + 1; g.push_back(&#123;a[i], d[i]&#125;);//a[i]==d[i]表示这两个数相互对应,已经归位了 &#125; int cn3; cn3 = 0; for(PIR i:g) vis[i.second] = i.first; // for(PIR i:g) dfs(i.second); mem(vv,0); for(PIR i:g)&#123; int pos = _find(i.second); if(!vv[pos])&#123; //如果遇到新的环,cnt++ cn3++; vv[pos] = true; &#125; &#125; DEBUG(g.size()-cn3); //最终结果就为n-环的个数 return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用frp实现内网穿透]]></title>
    <url>%2F2019%2F04%2F27%2F367%2F</url>
    <content type="text"><![CDATA[最近碰见了一件事情,我宿舍的电脑想通过ssh远程连接到实验室,但是实验室的机器没有公网ip,不过能访问外网,经过一番折腾后,终于成功的用frp实现了内网穿透,连上了实验室的电脑 因为当时查各种资料花费时间挺多的,这里把我的经验分享出来,供大家参考转载请注明出处:bestsort.cn准备工作一台有公网ip的服务器需要连接的内网机器 我的机器类型:内网机器:Ubuntu18.04服务器:Ubuntu16.04部署好后连接时的主机:Win10 的 Ubuntu 子系统这里如果没有服务器的话可以去阿里云,腾讯云等租一台,学生机一个月10r,并不贵.下载并部署frpfrp已经在2018年3月更新到0.25版本了,这里采用的便是此版本先在服务器和内网机器上下载好frpwget https://github.com/fatedier/frp/releases/download/v0.25.0/frp_0.25.0_linux_amd64.tar.gz将 frps 及 frps.ini 放到具有公网 IP 的机器上。将 frpc 及 frpc.ini 放到处于内网环境的机器上。解压 tar -zxvf frp_0.25.0_linux_amd64.tar.gz公网机器登录,然后执行以下命令 cd frp_0.25.0_linux_amd64/ sudo vim frps.ini修改frps.ini为如下内容,保存并退出 # frps.ini [common] bind_port = 7000 最后启动frps并设置后台运行 nohup ./frps -c ./frps.ini &amp; 当看到这一行时,我们就可以ctrl+c退出了: nohup: 忽略输入并把输出追加到&#39;nohup.out&#39; 如果想确定frp是否后台运行,可以使用以下命令查看 ps -ef | grep frp内网机器执行以下命令 cd frp_0.25.0_linux_amd64/ sudo vim frpc.ini 将frpc.ini修改为如下形式: # frpc.ini [common] server_addr = x.x.x.x #这里填自己公网机器的ip server_port = 7000 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000#用于登录的端口号 保存并退出 然后在 frp_0.25.0_linux_amd64/目录下输入./frpc -c ./frpc.ini并运行,显示有success即可连接到内网frp部署好后,我们只需要ssh 内网用户名@公网ip -p -6000,即可成功登录文件访问如果要需要用到文件访问,则frpc.ini中的内容如下:# frpc.ini [common] server_addr = x.x.x.x#地址填自己服务器ip server_port = 7000 #以下内容为文件访问所要添加的,如果想远程连接,把上面的[ssh]模块添加在后面即可 [test_static_file] type = tcp remote_port = 1234#这里默认的6000端口我用于内网穿透了,就换了1234端口 plugin = static_file # 要对外暴露的文件目录 plugin_local_path = /tmp/file#绝对路径 # 访问 url 中会被去除的前缀，保留的内容即为要访问的文件路径 #plugin_strip_prefix = static 可不选,如要使用前缀去掉注释即可 plugin_http_user = abc #访问文件所需要的用户名,可不选 plugin_http_passwd = abc #密码,可不选 然后我们就可以通过浏览器访问 http://x.x.x.x:1234来查看位于 /tmp/file 目录下的文件了，会要求输入已设置好的用户名和密码(如果没设置则可直接查看)。]]></content>
      <categories>
        <category>VPS玩机</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组 数据结构详解与模板(可能是最详细的了)]]></title>
    <url>%2F2019%2F04%2F26%2F195%2F</url>
    <content type="text"><![CDATA[树状数组基础树状数组是一个查询和修改复杂度都为log(n)的数据结构。主要用于数组的单点修改&amp;&amp;区间求和. 另外一个拥有类似功能的是线段树. 具体区别和联系如下： 1.两者在复杂度上同级, 但是树状数组的常数明显优于线段树, 其编程复杂度也远小于线段树. 2.树状数组的作用被线段树完全涵盖, 凡是可以使用树状数组解决的问题, 使用线段树一定可以解决, 但是线段树能够解决的问题树状数组未必能够解决. 3.树状数组的突出特点是其编程的极端简洁性, 使用lowbit技术可以在很短的几步操作中完成树状数组的核心操作，其代码效率远高于线段树。 上面出现了一个新名词:lowbit.其实lowbit(x)就是求x最低位的1;下面加图进行解释 对于一般的二叉树,我们是这样画的 把位置稍微移动一下,便是树状数组的画法 上图其实是求和之后的数组,原数组和求和数组的对照关系如下,其中a数组是原数组,c数组是求和后的数组: C[i]代表 子树的叶子结点的权值之和 如图可以知道C[1]=A[1];C[2]=A[1]+A[2]; C[3]=A[3]; C[4]=A[1]+A[2]+A[3]+A[4]; C[5]=A[5]; C[6]=A[5]+A[6]; C[7]=A[7]; C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; 再将其转化为二进制看一下: C[1] = C[0001] = A[1]; C[2] = C[0010] = A[1]+A[2]; C[3] = C[0011] = A[3]; C[4] = C[0100] = A[1]+A[2]+A[3]+A[4]; C[5] = C[0101] = A[5]; C[6] = C[0110] = A[5]+A[6]; C[7] = C[0111] = A[7]; C[8] = C[1000] = A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; 对照式子可以发现 $C[i]=A[i-2^k+1]+A[i-2^k+2]+……A[i]$;（$k$ 为 $i$ 的二进制中从最低位到高位连续零的长度）例如 $i=8(1000)$ 时，$k=3$;$C[8] = A[8-2^3+1]+A[8-2^3+2]+……+A[8]$ 即为上面列出的式子 现在我们返回到 lowbit 中来 其实不难看出 lowbit(i) 便是上面的 $2^k$ 因为 $2^k$ 后面一定有 $k$ 个 $0$ 比如说$2^5==&gt;100000$ 正好是 $i$ 最低位的 1 加上后缀 0 所得的值 开篇就说了,lowbit(x) 是取出 x 的最低位 1;具体操作为int lowbit(x){return x&amp;(-x);} 极致简短! 现在我们来理解一下这行代码: 我们知道,对于一个数的负数就等于对这个数取反 +1 以二进制数 11010 为例: 11010 的补码为 00101,加 1 后为 00110,两者相与便是最低位的 1 其实很好理解,补码和原码必然相反,所以原码有 0 的部位补码全是 1 ,补码再 +1 之后由于进位那么最末尾的 1 和原码 最右边的 1 一定是同一个位置(当遇到第一个 1 的时候补码此位为 0 ,由于前面会进一位,所以此位会变为 1 ) 所以我们只需要进行a&amp;(-a)就可以取出最低位的 1 了 会了lowbit,我们就可以进行区间查询和单点更新了.单点更新:继续看开始给出的图 此时如果我们要更改A[1] 则有以下需要进行同步更新1(001) C[1]+=A[1] lowbit(1)=001 1+lowbit(1)=2(010) C[2]+=A[1] lowbit(2)=010 2+lowbit(2)=4(100) C[4]+=A[1] lowbit(4)=100 4+lowbit(4)=8(1000) C[8]+=A[1] 换成代码就是:1234void update(int x,int y,int n)&#123; for(int i=x;i&lt;=n;i+=lowbit(i)) //x为更新的位置,y为更新后的数,n为数组最大值 c[i] += y;&#125;区间查询:举个例子i=5C[4]=A[1]+A[2]+A[3]+A[4];C[5]=A[5];可以推出: sum(i = 5) ==&gt; C[4]+C[5];序号写为二进制: sum(101)=C[(100)]+C[(101)];第一次 101,减去最低位的 1 就是 100;其实也就是单点更新的逆操作 代码如下1234567int getsum(int x)&#123; int ans = 0; for(int i=x;i;i-=lowbit(i)) ans += c[i]; return ans;&#125;lowbit 会了,区间查询有了,单点更新也有了接下来该做题了 单击传送门移步HDU1166敌兵布阵附代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;vector&gt;#define For(a,b) for(int a=0;a&lt;b;a++)#define mem(a,b) memset(a,b,sizeof(a))#define _mem(a,b) memset(a,0,(b+1)&lt;&lt;2)#define lowbit(a) ((a)&amp;-(a))using namespace std;typedef long long ll;const int maxn = 5*1e4+5;const int INF = 0x3f3f3f3f;int c[maxn];void update(int x,int y,int n)&#123; for(int i=x;i&lt;=n;i+=lowbit(i)) c[i] += y;&#125;int getsum(int x)&#123; int ans = 0; for(int i=x;i;i-=lowbit(i)) ans += c[i]; return ans;&#125;int main()&#123; int t; int n; int x,y,z; string s; cin &gt;&gt; t ; for(int j=1;j&lt;=t;j++)&#123; scanf("%d",&amp;n); _mem(c,n); //初始化数组中前n+1个数为0 for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;z); update(i,z,n); &#125; cout &lt;&lt;"Case "&lt;&lt;j&lt;&lt;":"&lt;&lt;endl; while(1)&#123; cin &gt;&gt; s; if(s[0] == 'E') break; scanf("%d%d",&amp;x,&amp;y); if(s[0] == 'Q') cout &lt;&lt; getsum(y)-getsum(x-1)&lt;&lt;endl; else if(s[0] == 'A') update(x,y,n); else update(x,-y,n); &#125; &#125; return 0;&#125;高级操作求逆序对操作对于数组 a，我们将其离散化处理为数组 b.区间查询与单点修改代码如下1234567891011121314151617void update(int p)&#123; while(p&lt;=n) &#123; a[p] ++; p+=lowbit(p); &#125;&#125;int getsum(int p)&#123; int res = 0; while(p) res += a[p],p -= lowbit(p); return res;&#125;a 的逆序对个数为：1234for(int i=1;i&lt;=n;i++)&#123; update(b[i]+1); res += i-getsum(b[i]+1);&#125;res 就是逆序对个数，ask，需注意b[i]应该大于0原理此部分来自 ssimple_y 的博客 第一次插入的时候把5这个位置上加上1，read(x)值就是1，当前已经插入了一个数，所以他前面比他大的数的个数就等于 i - read(x) = 1 - 1 = 0，所以总数 sum += 0 第二次插入的时候，read(x)的值同样是1，但是 i - read(x) = 2 - 1 = 1，所以sum += 1 第三次的时候，read(x)的值是2，i - read(x) = 3 - 2 = 1，所以sum += 1 第四次，read(x)的值是1，i - read(x) = 4 - 1 = 3，所以sum += 3 第五次，read(x)的值是1，i - read(x) = 5 - 1 = 4，所以sum += 4 这样整个过程就结束了，所有的逆序对就求出来了。求区间最大值123456789101112131415161718void Update(int i,int v)&#123; while(i&lt;=maxY) &#123; t[i] = max(t[i],v); i += lowbit(i); &#125;&#125;int query(int i)&#123; int ans = 0; while(i) &#123; ans = max(ans,t[i]); i -= lowbit(i); &#125; return ans;&#125;该部分内容转自 胡小兔的OI博区间修改+单点查询通过“差分”（就是记录数组中每个元素与前一个元素的差），可以把这个问题转化为问题1。查询设原数组为a[i], 设数组d[i]=a[i]-a[i-1](a[0]=0)，则$a[i]=\sum_{j=1}^{i}d[j]$，可以通过d[i]求的前缀和查询。修改当给区间[l,r]加上x的时候，a[l]与前一个元素 a[l-1] 的差增加了x，a[r+1]与 a[r]的差减少了x。根据d[i]数组的定义，只需给a[l]加上 x, 给a[r+1] 减去x即可1234567891011void add(int p, int x)&#123; //这个函数用来在树状数组中直接修改 while(p &lt;= n) sum[p] += x, p += p &amp; -p;&#125;void range_add(int l, int r, int x)&#123; //给区间[l, r]加上x add(l, x), add(r + 1, -x);&#125;int ask(int p)&#123; //单点查询 int res = 0; while(p) res += sum[p], p -= p &amp; -p; return res;&#125;区间修改+区间查询这是最常用的部分，也是用线段树写着最麻烦的部分——但是现在我们有了树状数组！ 怎么求呢？我们基于问题2的“差分”思路，考虑一下如何在问题2构建的树状数组中求前缀和： 位置p的前缀和 = 在等式最右侧的式子$sum{i=1}^{p}sum{j=1}^{i}d[j]$中，d[1]被用了p次，d[2]被用了p-1次……那么我们可以写出： 位置p的前缀和 = 那么我们可以维护两个数组的前缀和：一个数组是 $sum1[i]=d[i]$另一个数组是 $sum2[i]=d[i]*i$查询位置p的前缀和即：$(p+1)*sum1$数组中p的前缀和 - sum2数组中p的前缀和。 区间[l, r]的和即：位置r的前缀和 - 位置l的前缀和。修改对于sum1数组的修改同问题2中对d数组的修改。 对于sum2数组的修改也类似，我们给 sum2[l] 加上 l x，给 sum2[r + 1] 减去 (r + 1) x。12345678910111213141516void add(ll p, ll x)&#123; for(int i = p; i &lt;= n; i += i &amp; -i) sum1[i] += x, sum2[i] += x * p;&#125;void range_add(ll l, ll r, ll x)&#123; add(l, x), add(r + 1, -x);&#125;ll ask(ll p)&#123; ll res = 0; for(int i = p; i; i -= i &amp; -i) res += (p + 1) * sum1[i] - sum2[i]; return res;&#125;ll range_ask(ll l, ll r)&#123; return ask(r) - ask(l - 1);&#125;用这个做区间修改区间求和的题，无论是时间上还是空间上都比带lazy标记的线段树要优。 二维树状数组 我们已经学会了对于序列的常用操作，那么我们不由得想到（谁会想到啊喂）……能不能把类似的操作应用到矩阵上呢？这时候我们就要写二维树状数组了！ 在一维树状数组中，tree[x]（树状数组中的那个“数组”）记录的是右端点为x、长度为lowbit(x)的区间的区间和。 那么在二维树状数组中，可以类似地定义tree[x][y]记录的是右下角为(x, y)，高为lowbit(x), 宽为 lowbit(y)的区间的区间和。单点修改+区间查询123456789101112131415161718void add(int x, int y, int z)&#123; //将点(x, y)加上z int memo_y = y; while(x &lt;= n)&#123; y = memo_y; while(y &lt;= n) tree[x][y] += z, y += y &amp; -y; x += x &amp; -x; &#125;&#125;void ask(int x, int y)&#123;//求左上角为(1,1)右下角为(x,y) 的矩阵和 int res = 0, memo_y = y; while(x)&#123; y = memo_y; while(y) res += tree[x][y], y -= y &amp; -y; x -= x &amp; -x; &#125;&#125;区间修改 + 单点查询我们对于一维数组进行差分，是为了使差分数组前缀和等于原数组对应位置的元素。 那么如何对二维数组进行差分呢？可以针对二维前缀和的求法来设计方案。 二维前缀和： $sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]$ 那么我们可以令差分数组$d[i][j]$表示$a[i][j]$与$a[i-1][j]+a[i][j-1]-a[i-1][j-1]$的差。 例如下面这个矩阵 1 4 8 6 7 2 3 9 5 对应的差分数组就是 1 3 4 5 -2 -9 -3 5 1 当我们想要将一个矩阵加上x时，怎么做呢？ 下面是给最中间的3*3矩阵加上x时，差分数组的变化：0 0 0 0 0 0 +x 0 0 -x 0 0 0 0 0 0 0 0 0 0 0 -x 0 0 +x 这样给修改差分，造成的效果就是：0 0 0 0 0 0 x x x 0 0 x x x 0 0 x x x 0 0 0 0 0 0 那么我们开始写代码吧！123456789101112131415161718192021222324void add(int x, int y, int z)&#123; int memo_y = y; while(x &lt;= n)&#123; y = memo_y; while(y &lt;= n) tree[x][y] += z, y += y &amp; -y; x += x &amp; -x; &#125;&#125;void range_add(int xa, int ya, int xb, int yb, int z)&#123; add(xa, ya, z); add(xa, yb + 1, -z); add(xb + 1, ya, -z); add(xb + 1, yb + 1, z);&#125;void ask(int x, int y)&#123; int res = 0, memo_y = y; while(x)&#123; y = memo_y; while(y) res += tree[x][y], y -= y &amp; -y; x -= x &amp; -x; &#125;&#125;区间修改 + 区间查询类比之前一维数组的区间修改区间查询，下面这个式子表示的是点(x, y)的二维前缀和： $\sum{i=1}^{x}\sum{j=1}^{y}\sum{k=1}^{i}\sum{h=1}^{j}d[h][k]$(d[h][k]为点(h, k)对应的“二维差分”(同上题))这个式子炒鸡复杂:$O(n^4)$的时间复杂度！，但利用树状数组，我们可以把它优化到$O(log2n)$！ 首先，类比一维数组，统计一下每个$d[h][k]$出现过多少次。$d[1][1]$出现了$x_y$次，$d[1][2]$出现了$x(y-1)$次……$d[h][k]$出现了$(x-h+1)(y-k+1)$次。 那么这个式子就可以写成： $sum{i=1}^{x}sum{j=1}^{y}d[i][j](x+1-i)(y+1-j)$ 把这个式子展开，就得到： 那么我们要开四个树状数组，分别维护： $d[i][j]_j$,$d[i][j]_i$,$d[i][j]_j$,$d[i][j]_ij$ 这样就完成了！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;ll read()&#123; char c; bool op = 0; while((c = getchar()) &lt; '0' || c &gt; '9') if(c == '-') op = 1; ll res = c - '0'; while((c = getchar()) &gt;= '0' &amp;&amp; c &lt;= '9') res = res * 10 + c - '0'; return op ? -res : res;&#125;const int N = 205;ll n, m, Q;ll t1[N][N], t2[N][N], t3[N][N], t4[N][N];void add(ll x, ll y, ll z)&#123; for(int X = x; X &lt;= n; X += X &amp; -X) for(int Y = y; Y &lt;= m; Y += Y &amp; -Y)&#123; t1[X][Y] += z; t2[X][Y] += z * x; t3[X][Y] += z * y; t4[X][Y] += z * x * y; &#125;&#125;void range_add(ll xa, ll ya, ll xb, ll yb, ll z)&#123; //(xa, ya) 到 (xb, yb) 的矩形 add(xa, ya, z); add(xa, yb + 1, -z); add(xb + 1, ya, -z); add(xb + 1, yb + 1, z);&#125;ll ask(ll x, ll y)&#123; ll res = 0; for(int i = x; i; i -= i &amp; -i) for(int j = y; j; j -= j &amp; -j) res += (x + 1) * (y + 1) * t1[i][j] - (y + 1) * t2[i][j] - (x + 1) * t3[i][j] + t4[i][j]; return res;&#125;ll range_ask(ll xa, ll ya, ll xb, ll yb)&#123; return ask(xb, yb) - ask(xb, ya - 1) - ask(xa - 1, yb) + ask(xa - 1, ya - 1);&#125;int main()&#123; n = read(), m = read(), Q = read(); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; ll z = read(); range_add(i, j, i, j, z); &#125; &#125; while(Q--)&#123; ll ya = read(), xa = read(), yb = read(), xb = read(), z = read(), a = read(); if(range_ask(xa, ya, xb, yb) &lt; z * (xb - xa + 1) * (yb - ya + 1)) range_add(xa, ya, xb, yb, a); &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++) printf("%lld ", range_ask(i, j, i, j)); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】图论题目集合]]></title>
    <url>%2F2019%2F04%2F22%2F116%2F</url>
    <content type="text"><![CDATA[最小生成树+并查集【HDU】1213 How Many Tables 基础并查集★1272 小希的迷宫 基础并查集★1325&amp;&amp;poj1308 Is It A Tree? 基础并查集★1856 More is better 基础并查集★1102 Constructing Roads 基础最小生成树★1232 畅通工程 基础并查集★1233 还是畅通工程 基础最小生成树★1863 畅通工程 基础最小生成树★1875 畅通工程再续 基础最小生成树★1879 继续畅通工程 基础最小生成树★3371 Connect the Cities 简单最小生成树★1301 Jungle Roads 基础最小生成树★1162 Eddy’s picture 基础最小生成树★1198 Farm Irrigation 基础最小生成树★1598 find the most comfortable road 枚举+最小生成树★★1811 Rank of Tetris 并查集+拓扑排序★★3926 Hand in Hand 同构图★3938 Portal 离线+并查集★★2489 Minimal Ratio Tree dfs枚举组合情况+最小生成树★4081 Qin Shi Huang’s National Road System 最小生成树+DFS★★4126 Genghis Khan the Conqueror 枚举+最小生成树+DFS(难)★★★★1829&amp;&amp;poj2492 A Bug’s Life 基础种类并查集★1558 Segment set 计算几何+并查集★3461 Code Lock 并查集(有点难想到)★★3367 Pseudoforest 最大生成树★2473 Junk-Mail Filter 并查集+设立虚父节点(马甲)★★3172 Virtual Friends 带权并查集★3635 Dragon Balls 带权并查集★3047 Zjnu Stadium 带权并查集★3038 How Many Answers Are Wrong 种类并查集★★2818 Building Block 带权并查集★3234 Exclusive-OR 异或并查集(难)★★★2121 Ice_cream’s world II 最小树形图(要输出根有点恶心)★★4009 Transfer water 最小树形图(模板题)★3311 Dig The Wells 斯坦纳树(状压DP)(模板题)★★4085 Peach Blossom Spring 斯坦纳树(状压DP)(有可能是森林…)★★★2586 How far away ？ LCA★2874 Connections between cities LCA★3486 Interviewe RMQ★2888 Check Corners 二维RMQ★3183 A Magic Lamp RMQ(有点难想到,有点难联系到RMQ)★★【POJ】1258 最经典的MST★1789 Truck History 最小生成树★1287 Networking 简单★2349 Arctic Network 简单★1611 The Suspects 并查集★2377 kruskal★2524 Ubiquitous Religions 并查集★2236 Wireless Network 并查集+计算几何★2560 Kruskal 并查集★1861 Kruskal ★3625 prim★1679 - The Unique MST(基础) 判断MST是否唯一★3522 - Slim Span(基础) 求一颗生成树，让最大边最小边差值最小★2485 Highways MST中的最长边★2395 最小生成树的最长边★1751 Highways 求出方案★POJ-1182 食物链 种类并查集★★POJ 1456 Supermarket 贪心+区间合并★POJ-1703 种类并查集★POJ-1988 种类并查集★POJ-1733 Parity game 种类并查集，先要离散化一下，不影响结果★POJ-1417 True Liars(难) 并查集+DP 种类并查集★★POJ-2912 Rochambeau(难) baidu的题,很不错…是食物链的加强版.判断裁判比较难想.★★★POJ 2728 Desert King(中等) 最优比率生成树★★POJ 1639 Picnic Planning(较难) 顶点度数有限制的最小生成树★★POJ 3164 Command Network(难) 最小树形图★★poj3723 好题!!! ★★poj3228 好好题!!! ★★【ZOJ】ZOJ-3261 逆向并查集 ★★最短路系列【HDU】1548 A strange lift 基础最短路(或bfs)★2544 最短路 基础最短路★3790 最短路径问题 基础最短路★2066 一个人的旅行 基础最短路(多源多汇,可以建立超级源点和终点)★2112 HDU Today 基础最短路★1874 畅通工程续 基础最短路★1217 Arbitrage 货币交换 Floyd (或者 Bellman-Ford 判环)★1245 Saving James Bond 计算几何+最短路★1317 XYZZY Bellman-Ford判环,有负权★1535 Invitation Cards 有向图的来回最短路,(反向建图)★1546 Idiomatic Phrases Game 最短路★2680 Choose the best route 最短路★2923 Einbahnstrasse 最短路★3339 In Action 最短路+背包★2224 The shortest path 双调旅行商问题★★2807 The Shortest Path 矩阵运算+最短路(floyd)★★1595 find the longest of the shortest枚举+最短路(删掉任意一条边的最长最短路)★★3986 Harry Potter and the Final Battle 枚举+最短路(删掉任意一条边的最长最短路)★★1599 find the mincost route floyd求最小环★1839 Delay Constrained… 二分下限+最短路(带限制最短路)★★3631 Shortest Path Floyd插点法★★4114 Disney’s FastPass 最短路+二维状压DP(难)★★★3832 Earth Hour 三点连通(斯坦纳树)★3873 Invade the Mars Dij变体(好题!,带限制最短路)★★★4063 Aircraft 几何构图+最短路★★★★hdu4179 Difficult Routes dis()()开二维状态的最短路(带限制最短路)★★1869 六度分离 Floyd最短路★1385 Minimum Transport Cost 最短路+输出路径(输出字典序最小路径,有点恶心)★★1224 free DIY Tour 最短路+输出路径★1142 A Walk Through the Forest 最短路+记忆搜索★★1596 find the safest road 乘积最小的最短路★1598 find the most comfortable road 二分速度差+最短路(带限制最短路)★★2722 Here We Go(relians) Again 最短路★2962 Trucking 二分+最短路(带限制最短路)★★1690 Bus System 最短路★2433 Travel 删边+最短路之和(预处理桥边)★★★2363 Cycling 二分+最短路(带限制最短路)★★2377 Bus Pass 最短路(寻找一个点的最长最短路最小)★★2833 WuKong 最短路+记忆化搜索(求两条最短路的最多公共点)★★1688 Sightseeing 最短次短路条数★★3191 How Many Paths Are There 次短路条数★★2482 Transit search 最短路★★★3768 Shopping 最短路+dfs(或最短路+状压DP)★★3035 War 平面图最小割(建图麻烦)★★3870 Catch the Theves 平面图最小割(建图麻烦)★★3860 Circuit Board 平面图最小割(建图麻烦)★★【POJ】1062 昂贵的聘礼 竟然可以和最短路联系起来★★1094 Sorting It All Out Floyd判环+拓扑排序★1125 Stockbroker Grapevine Floyd★1135 Domino Effect 最短路,比较有意思★★1161 Walls 最短路(图太恶心了)★★1502 MPI Maelstrom Floyd★1511 Invitation Cards 来回最短路★1556 The Doors 计算几何+最短路★★1724 ROADS 带限制的最短路,dis()()开二维来记录信息(或广搜)★★1734 Sightseeing trip floyd最小环路径★1797 Heavy Transportation 二分枚举+最短路★1847 Tram 简单最短路★1860 Currency Exchange 货币兑换★1949 Chores 反向建边,求最长路★★2139 Six Degrees of Cowvin Bacon Floyd★2240 Arbitrage 货币兑换★2253 Frogger 二分+最短路★2312 坦克大战 spfa最短路本质变形—&gt;广搜★2387 Til the Cows Come Home 基础最短路★2394 Checking an Alibi 最短路★2449 Remmarguts’ Date A*求第K短路★★2457 Part Acquisition 最短路 (输出路径)★★2472 106 miles to Chicago 乘积最短路(log一下,乘变加)★★2502 Subway2570 Fiber Network floyd3013 圣诞树3037 Skiing3072 Robot3114 Countries in War 强联通+最短路3160 Father Christmas flymouse 强联通+最长路3255 Roadblock3259 Wormholes （寻找负权回路）3268 Silver Cow Part3311 Hie with the Pie floyd+状压3328 Cliff Climbing3439 Server Relocation3463 Sightseeing 次短路条数31593521 Geometric Map 计算几何+最短路3549 GSM phone 计算几何+最短路3594 Escort of Dr. Who How3613 Cow Relays 经过N条边的最短路 // floyd + 二分矩阵3615 Cow Hurdles3621 最优比率环3635 full tank?3660 传递闭包3662 Telephone Lines差分约束系列【HDU】1384 Intervals1529 Cashier Employment1531 King1534 Schedule Problem3440 House Man3592 World Exhibition3666 THE MATRIX PROBLEM【POJ】120112751364171629492983315931693687二分匹配系列普通匹配,多重匹配【HDU】1068 Girls and Boys1150 Machine Schedule1151 Air Raid1179 Ollivanders: Makers of Fine Wands since 382 BC.1281 棋盘游戏1498 50 years, 50 colors1507 Uncle Tom’s Inherited Land*1528 Card Game Cheater1845 Jimmy’s Assignment2063 过山车2119 Matrix2444 The Accomodation of Students2768 Cat vs. Dog3081 Marriage Match II3360 National Treasures1045 也可搜索1350 最小路径覆盖3118 类似二分匹配3729238910542819 完全匹配1668 二分+多重匹配3605 多重匹配3861 强连通+二分匹配2236 无题IIhdu3468hdu4185 奇偶匹配【POJ】1087 A Plug for UNIX1274 The Perfect Stall1469 COURSES1486 Sorting Slides 二分图的必须边1548 Robots1698 Alice’s Chance1719 Shooting Contest1904 King’s Quest 求二分图所有可能的匹配边2060 Taxi Cab Scheme 最小路径覆盖2112 Optimal Milking 二分+多重匹配2226 Muddy Fields 行列的覆盖2239 Selecting Courses2289 Jamie’s Contact Groups 二分+多重匹配2446 Chessboard2536 Gopher II2584 T-Shirt Gumbo2594 Treasure Exploration 可相交最小路径覆盖2672 Hotkeys2724 Purifying Machine3020 Antenna Placement3041 Asteroids 简单行列匹配3189 Steady Cow Assignment 二分+多重匹配3207 Ikki’s Story IV - Panda’s Trick3216 Repairing Company3343 Against Mammoths3692 Kindergarten2771 最大独立集KM算法系列【HDU】2255 奔小康赚大钱1533 Going Home1853 Cyclic Tour3488 Tour3435 A new Graph Game2426 Interesting Housing Problem2853 Assignment3718 Similarity3722 Card Game3395 Special Fish2282 Chocolate2813 One fihgt one2448 Mining Station on the Sea3315 My Brute3523 Image copy detection【POJ】2195 Going Home 最小权值匹配2400 Supervisor, Supervisee 输出所有最小权匹配2516 Minimum Cost 最小权值匹配或最小费用流3565 Ants3686 The Windy’s 最小权值匹配最大团&amp;稳定婚姻系列【HDU】1530 Maximum Clique1435 Stable Match3585 maximum shortest distance 二分+最大团1522 Marriage is Stable1914 The Stable Marriage Problem【POJ】1129 四色定理 着色问题1419 最大独立集2989 极大团3487 The Stable Marriage Problem 稳定婚姻强双联通系列【HDU】强连通:1269 迷宫城堡 判断是否是一个强连通2767 Proving Equivalences 至少加几条边让整个图变成强连通3836 Equivalent Sets 至少加几条边让整个图变成强连通1827 Summer Holiday 传递的最小费用3072 Intelligence System 传递的最小费用3861 The King’s Problem 强连通+二分匹配3639 Hawk-and-Chicken 强连通缩点 + 树形dp（累加子节点的总权值）3594 Cactus 仙人掌图双连通:2242 考研路茫茫——空调教室 双联通缩点+树形DP2460 Network 边双连通3849 By Recognizing These Guys, We Find Social Networks Useful 双连通求桥3896 Greatest TC 双连通4005 The war 边双连通LCA:2586 How far away ？2874 Connections between cities3078 Network LCA+排序3830 Checkers 二分+LCA【POJ】强连通:1236 Network of Schools2553 The Bottom of a Graph 好题！ 找出度为0的集合2186 Popular Cows 好题！ 找出度为0的，其他分量都指向它的集合2375 Cow Ski Area 强连通2762 Going from u to v or from v to u? 缩点+拓扑排序3160 Father Christmas flymouse 强连通+最短路3180 The Cow Prom 判断有几个环， 分量中元素大于1的个数3114 Countries in War 强连通+最短路3592 Instantaneous Transference 强连通分量+最长路1904 King’s Quest 强连通+并查集双连通：3694 Network 边双连通 (同hdu2460)3177 Redundant Paths 构造边双连通3352 Road Construction 构造边双连通2942 Knights of the Round Table (点双连通经典题)1515 Street Directions (无向图改有向图)1438 One-way Traffic (混合图改有向图)LCA:1330 Nearest Common Ancestors1470 Closest Common Ancestors1986 Distance Queries3417 Network3728 The merchant LCA+并查集,更新询问2763 Housewife Wind LCA+树状数组2-SAT系列【HDU】3062 Party1824 Let’s go home3622 Bomb Game3715 Go Deeper1815 Building roads2723 Get Luffy Out1816 Get Luffy Out *1814 Peaceful Commission4115 Eliminate the Conflict【POJ】2296 Map Labeler2723 Get Luffy Out2749 Building roads3207 Ikki’s Story IV - Panda’s Trick3648 Wedding3678 Katu Puzzle3683 Priest John’s Busiest Day3905 Perfect Election欧拉回路系列【HDU】1878 欧拉回路 判断3018 Ant Trip 一笔画问题11162894 兹鼓欧拉回路19563472 混合欧拉【POJ】2513 欧拉路1041 John’s trip 欧拉回路1386 Play on Words 单词接龙2230 Watchcow 欧拉回路2513 Colored Sticks 无向图欧拉路2337 Catenyms 欧拉路径1392 Ouroboros Snake 兹鼓欧拉回路1780 code1637 混合欧拉【zoj】1992拓扑排序系列【HDU】1285 确定比赛名次2094 产生冠军2647 Reward3342 Legal or Not1811 Rank of Tetris 拓扑+并查集3231 三维拓扑【POJ】1094 Sorting It All Out Floyd+拓扑2367 Genealogical tree3660 Cow Contest3687 Labeling Balls 神奇的拓扑1128 Frame Stacking DFS版拓扑1270 Following Orders 拓扑+回溯1420 Spreadsheet 模拟拓扑2762 Going from u to v or from v to u? 强连通+拓扑3553 Task schedule竞赛图系列竞赛图下的哈密顿问题Strange Country II ZOJ-3332Task Sequences POJ-1776The book SGU-122Tour Route POJ-3780Tour Route HDOJ-3414网络流系列【HDU】1532 Drainage Ditches(基础) (最大流)3549 Flow Problem(基础) (最大流)3572 Task Schedule (最大流)任务分配,判断满流2732 Leapin’ Lizards(难) (最大流)3338 Kakuro Extension (最大流)(数和)神奇最大流行进列出2883 kebab (最大流)判断满流3605 Escape (最大流)(多重匹配3081 Marriage Match II (二分最大流)+并查集3277 Marriage Match III (二分最大流)同上,多了拆点3416 Marriage Match IV (最大流)最短路+最大流2485 Destroying the bus stations (最大流)最短路+最大流3468 Treasure Hunting (最大流)(二分匹配)+最短路3551 Hard Problem (最大流)3998 Sequence(难) (DP+最大流)最长上升子序列3917 Road constructions (最大权闭包)3879 Base Station (最大权闭包)3061 Battle (最大权闭包)3996 Gold Mine (最大权闭包)3472 HS BDC (混合欧拉)hdu4183 来回走不重复点的网络流.1533 Going Home(基础) (费用流)3488 Tour (费用流)圈3435 A new Graph Game (费用流)圈1853 Cyclic Tour (费用流)圈2686 Matrix (费用流)3376 Matrix Again (费用流)3667 Transportation (费用流)拆边3315 My Brute (费用流)(可用KM)3395 Special Fish (费用流)(可用KM匹配)2448 Mining Station on the Sea (费用流)(可用最短路+KM匹配)4067 Random Maze(难) (费用流)3947 River Problem(难) (费用流)神奇费用流,流量不等式建图3046 Pleasant sheep and big big wolf (最小割)1565 方格取数(1) (最小割)1569 方格取数(2) (最小割)3820 Golden Eggs (最小割)方格加强3491 Thieves (最小割)最小点割集3657 Game (最小割)最大点权独立集3313 Key Vertex (最小割)3251 Being a Hero (最小割)3157 Crazy Circuits (上下流)3002 King of Destruction (全局最小割)3691 Nubulsa Expo (全局最小割)【POJ】1087 A Plug for UNIX (最大流)(可用二分匹配)1274 The Perfect Stall (最大流)(可用二分匹配)1325 Machine Schedule (最大流)(可用二分匹配)1698 Alice’s Chance (最大流)(可用二分匹配)2239 Selecting Courses (最大流)(可用二分匹配)2446 Chessboard (最大流)(可用二分匹配) 好题啊2536 Gopher II (最大流)(可用二分匹配)2771 Guardian of Decency (最大流)二分匹配最大独立集3041 Asteroids (最大流)(简单二分匹配)2584 T-Shirt Gumbo (最大流)(多重匹配)3189 Steady Cow Assignment(中等) (二分最大流)(多重匹配)1149 PIGS (最大流) 绝对经典的构图题1273 Drainage Ditches (最大流)(基础)1459 Power Network(基础) (最大流)3281 Dining (最大流)2112 Optimal Milking(基础) (二分最大流)2289 Jamie’s Contact Groups (二分最大流)2391 Ombrophobic Bovines(中等) (二分最大流)2455 Secret Milking Machine(基础) (二分最大流)3228 Gold Transportation (二分最大流)(并查集)2699 The Maximum Number of Strong Kings(较难) (枚举人数 + 最大流)3498 March of the Penguins(中等) (最大流)枚举汇点,满足点容量限制的网络流2987 Firing(较难) (最大权闭包)1637 Sightseeing tour(Crazy) (混合欧拉)2135 Farm Tour (费用流) (来回最短路)2175 Evacuation Plan(中等) (费用流) 消圈2195 Going Home (费用流)2516 Minimum Cost (费用流)3422 Kaka’s Matrix Travels(中等) (费用流)拆点3680 Intervals(较难) (费用流)经典,费用流+离散化3686 The Windy’s (费用流)(KM匹配)3762 The Bonus Salary! (费用流)1815 Friendship(中等) (最小割)最小点割集1966 Cable TV Network(中等) (最小割)最小点割集2125 Destroying The Graph(难) (最小割)最小点权覆盖3084 Panic Room(中等，好题) (最小割)边连通度3204 Ikki’s Story I - Road Reconstruction(基础) (最小割)求关键边3308 Paratroopers(较难) (最小割)乘积取对数,最小点权覆盖3436 ACM Computer Factory (最小割)收集流,残留搜集找边3469 Dual Core CPU(中等) (最小割)收集流3921 Destroying the bus stations (最小割)点连通2396 Budget(中等) (有源汇的上下界可行流)3155 Hard Life(很挑战一题) (最大密度子图)2914 Minimum Cut (无向图最小割)dancing links系列1001 Easy Finding POJ-37401002 Power Stations HDOJ-36631003 Treasure Map ZOJ-32091004 Lamp HDOJ-28281005 whosyourdaddy HDOJ-34981006 Bomberman - Just Search! HDOJ-35291007 Square Destroyer POJ-10841008 Matrix HDOJ-21191009 Divisibility HDOJ-33351010 Radar HDOJ-22951011 Fire station HDOJ-36561012 Repair Depots HDOJ-31561013 Dominoes HDOJ-25181014 Street Fighter HDOJ-39571015 Sudoku Killer HDOJ-14261016 Sudoku POJ-26761017 Sudoku POJ-30741018 Sudoku POJ-30761019 Su-Su-Sudoku HDOJ-27801020 Sudoku HDOJ-31111021 Sudoku HDOJ-39091022 Squiggly Sudoku HDOJ-40691023 Triangle War II ZOJ-30381024 A Puzzling Problem HDOJ-16031025 Maximum Clique HDOJ-1530hust1017 精确覆盖。fzu1686,nuaa1507 重复覆盖。hit2199,2882,2959 精确覆盖(数独)。sSPOJ1771 精确覆盖(N皇后问题)。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kruscal 算法 最小生成树模板（hdu 1233 ）]]></title>
    <url>%2F2019%2F04%2F22%2F114%2F</url>
    <content type="text"><![CDATA[kruskal 和 prim 算法都是求最小生成树经常用到的算法，其中，prim 适用于稠密图（边较多），而 kruskal 更适用于稀疏图（边较少）。其时间复杂度为 O（elog2(e)）. 其中，e 为图的边 AD 和 CE 是最短边，长度为 5，AD 是 第一个选择的边，被突出显示。 CE 现在是不构成循环的第二条最短的边，长度为 5，突出显示为第二个边。 下一条边，长度为 6 的 DF，突出显示为第三条边。 接下来的最短边是 AB 和 BE，都是长度为 7. 随机选一条，这里我们选 AB，并且突出显示。边缘 BD 以红色突出显示，因为在 B 和 D 之间已经存在一条路径（绿色），所以如果选择它，它将形成一个循环（ABD）。 继续突出显示下一条最小的边，BE 长度为 7. 许多个边缘以红色显示：BC，因为它会形成回路 BCE。DE，因为它会形成回路 DEBA 和 FE 因为它会形成 FEBAD。 最后，该过程以长度为 9 的边 EG 结束，并找到最小生成树。 kruskal 和 prim 都是基于贪心的思想，其中，kruskal 是每次将属于不同集合的最小的一条边合并。这样，一直合并下去，最终会得到一棵最小生成树（总点数一定，连接的点不断增多，所以未连接的点就会逐渐减少直到为 0），需要注意的是，kruskal 是基于并查集优化的，所以了解 kruskal 算法之前，应该先看一下并查集。使用结构体储存边的信息：struct edge{int a,b; //a为起点，b为终点 int v; //v为该边的权值 }s[maxn];///将结构体按权值排序后，依次进行合并操作并查集合并及路径压缩：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141int pre[maxn]; ///各集合int Find(int a)&#123; ///寻找祖宗节点的同时进行路径压缩 int root = a; int tmp; while(root != pre[root])root = pre[root]; while(a != root)&#123; tmp = a; a = pre[a]; pre[tmp] = root; &#125; return root;&#125;void combine(int a,int b)&#123; ///合并a，b两个集合，这里我们规定将较大的数并入到较小的数中 int x = Find(a); int y = Find(b); if(x &gt; y) swap(x,y); pre[y] = x;&#125;3;kruskal 主代码：int kruscal(int n,int m)&#123; int ans = 0; For(i,m)&#123; if(Find(s[i].a)!=Find(s[i].b))&#123; ///如果a点所在的集合和b点所在的集合不相交 combine(s[i].a,s[i].b); ///合并两个集合 ans += s[i].v; n--; &#125; if(n == 1) ///当已经连了n-1条边时，就已经构成了最小生成树因为每n个点要连在一起只需要n-1条线即可 break; &#125; return ans;&#125;``` * * *例题：hdu1233 某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府 “畅通工程” 的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。 **Input** 测试输入包含若干测试用例。每个测试用例的第 1 行给出村庄数目 N (&lt; 100)；随后的 N (N-1)/2 行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从 1 到 N 编号。 当 N 为 0 时，输入结束，该用例不被处理。 **Output** 对每个测试用例，在 1 行里输出最小的公路总长度。 **Sample Input** 3 1 2 1 1 3 2 2 3 4 4 1 2 1 1 3 4 1 4 1 2 3 3 2 4 2 3 4 5 0 **Sample Output** 3 5 Huge input, scanf is recommended. 裸 kruskal 即可 参考代码：```cpp#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define For(i,n) for(int i=0;i&lt;n;i++)#define mem(a) memset(a,0,sizeof(a))using namespace std;const int INF = 0x3f3f3f3f;const int maxn = 1e4+5;typedef long long ll;struct edge&#123; int a,b; int v;&#125;s[maxn];int pre[maxn];bool cmp(edge a,edge b)&#123;return a.v &lt; b.v;&#125;int Find(int a)&#123; int root = a; int tmp; while(root != pre[root])root = pre[root]; while(a != root)&#123; tmp = a; a = pre[a]; pre[tmp] = root; &#125; return root;&#125;void combine(int a,int b)&#123; int x = Find(a); int y = Find(b); if(x &gt; y) swap(x,y); pre[y] = x;&#125;int kruscal(int n,int m)&#123; int ans = 0; For(i,m)&#123; if(Find(s[i].a)!=Find(s[i].b))&#123; combine(s[i].a,s[i].b); ans += s[i].v; n--; &#125; if(n == 1) break; &#125; cout &lt;&lt; ans &lt;&lt;endl;&#125;int main() &#123; int n; int a,b,c; int cnt; while(cin &gt;&gt; n &amp;&amp; n)&#123; mem(s); For(i,n+1) pre[i] = i; cnt = 0; For(j,n*(n-1)/2)&#123; cin &gt;&gt; a &gt;&gt; b&gt;&gt;c ; s[cnt].a = a; s[cnt].b = b; s[cnt++].v = c; &#125; sort(s,s+cnt,cmp); ///将边的权值按从小到大排序 kruscal(n,n*(n-1)/2); ///一共n个点，n*(n-1)/2条边 &#125; return 0; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c 班级管理系统]]></title>
    <url>%2F2019%2F04%2F22%2F108%2F</url>
    <content type="text"><![CDATA[文档 主要包含以下数据 账号信息:id, 密码，身份信息. 学生信息:id, 姓名，c 语言成绩，英语成绩，数学成绩，总成绩. 采用二进制文本的形式储存实现有以下功能:添加学生 (教师) 账号信息浏览所有学生信息按照指定 id 查询信息修改指定 id 信息删除指定 id 信息修改密码重置系统扩展功能:排序浏览学生和账号信息分别存放在不同的文件中把文件中的学生和账号信息导入的程序中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#include &lt;string.h&gt;#define SUPERKEY 123456typedef struct Class &#123; long long id; char name[10]; int cScore; int mathScore; int englishScore; int allScore; struct Class *next;&#125; Class;typedef struct Identity &#123; long long id; long long key; int identity; ///1表示教师,0表示学生; struct Identity *next;&#125; Identity;void Show(char*);void Print(Class *s) &#123; ///对内容进行输出 printf(" %-10lld %-13s%-13d%-13d%-13d%-5d\n",s-&gt;id,s-&gt;name,s-&gt;cScore,s-&gt;mathScore,s-&gt;englishScore,s-&gt;allScore);&#125;;void Init(); ///系统重置void GotoTeacher(long long,long long,Identity*,Class*); ///教师端void GotuStudent(long long,long long,Identity*,Class*); ///学生端void Admin(void*); ///管理员界面void LogIn(); ///登录端口void GotoXY(int,int); ///移动光标到输入栏long long KeyIn(); ///密文输入int LoadInformation(long long,long long); ///加载账号信息;void SaveFile(void *,char*); ///存文件void *readFile(char*); ///读取文件void Add(Class*,Identity*,char*); ///添加void Change(long long,void*,char*); ///修改void *Find(long long id,void *head,char*func); ///查找(*-&gt;next即为查找到的数据)void ViewAll(Class *); ///查看所有void Delete(long long,Class*,Identity*,char*); ///删除void Sort(Class*); ///排序int main() &#123; LogIn(); return 0;&#125;long long KeyIn() &#123; ///密文输入**** char key[20], c; int i = 0; memset(key,0,sizeof(key)); while ((c = getch())!='\r') &#123; if(c != 8) &#123; key[i++] = c; printf("*"); &#125; else &#123; printf("\b \b"); &#125; &#125; key[i] = 0; return atoll(key);&#125;void GotoXY(int x,int y) &#123; ///定位光标位置到指定坐标 HANDLE hOut; hOut = GetStdHandle(STD_OUTPUT_HANDLE); COORD pos= &#123;x,y&#125;; SetConsoleCursorPosition(hOut,pos);&#125;void LogIn() &#123; ///登录界面 long long id; long long key; while(1) &#123; Show("Login"); GotoXY(13,3); scanf("%lld",&amp;id); GotoXY(13,5); key = KeyIn(); LoadInformation(id,key); &#125;&#125;int LoadInformation(long long id,long long key) &#123; Identity *accont = (Identity*)readFile("ACC"); Class *student = (Class*)readFile("STU"); Identity *p = accont; Show("Load"); while(p = p-&gt;next) &#123; if(p-&gt;id == id&amp;&amp;p-&gt;key == key) &#123; if(p-&gt;identity) GotoTeacher(id,key,accont,student); else GotuStudent(id,key,accont,student); return 0; &#125; &#125; long long superKey; system("cls"); printf("┌────────────────────────────────────┐\n"); printf("│账号密码错误!!! │\n"); printf("│请输入管理员密码: │\n"); printf("└────────────────────────────────────┘\n"); GotoXY(19,2); superKey = KeyIn(); if(superKey == SUPERKEY) Admin(accont); else &#123; getchar(); printf("\n\n密码错误!"); Sleep(2000); &#125; system("cls"); return 1;&#125;void ViewAll(Class *head) &#123; Class *p = head; Show("splitter"); while(p = p-&gt;next) Print(p);&#125;void ViewAllAcc(Identity*head) &#123; Identity *p = head; Show("splitter"); while(p = p-&gt;next) printf("%10lld%10d\n",p-&gt;id,p-&gt;key);&#125;void Add(Class *student,Identity*accont,char*func) &#123; Identity *addAccont = (Identity*)malloc(sizeof(Identity)); printf("请输入你要添加的id:\n"); if(strcmp(func,"STU")==0) &#123; Class *add = (Class*)malloc(sizeof(Class)); scanf("%lld",&amp;add-&gt;id); if(((Identity*)Find(add-&gt;id,accont,"ACC"))-&gt;next) &#123; printf("此id已存在\n"); free(add); free(addAccont); return; &#125; printf("请输入该生名字:\n"); scanf("%s",add-&gt;name); printf("请输入c成绩,数学成绩,英语成绩(以空格隔开)\n"); scanf("%d%d%d",&amp;add-&gt;cScore,&amp;add-&gt;mathScore,&amp;add-&gt;englishScore); add-&gt;allScore = add-&gt;cScore+add-&gt;mathScore+add-&gt;englishScore; addAccont-&gt;id = add-&gt;id; addAccont-&gt;key = 123456; addAccont-&gt;identity = 0; add-&gt;next = student-&gt;next; student-&gt;next = add; SaveFile(student,"STU"); &#125; else &#123; scanf("%lld",&amp;addAccont-&gt;id); if(((Identity*)Find(addAccont-&gt;id,accont,"ACC"))-&gt;next) &#123; printf("此id已存在\n"); free(addAccont); return; &#125; printf("请输入该账号的初始密码:\n"); addAccont-&gt;key = KeyIn(); addAccont-&gt;identity = 1; &#125; addAccont-&gt;next = accont-&gt;next; accont-&gt;next = addAccont; SaveFile(accont,"ACC");&#125;void Change(long long id,void *head,char* func) &#123; if(strcmp(func,"STU")==0) &#123; Class *Cur = ((Class*)Find(id,head,"STU"))-&gt;next; if(Cur) &#123; printf("请按照姓名,c语言成绩,数学成绩,英语成绩的格式输入(以空格隔开)\n"); scanf("%s%d%d%d",Cur-&gt;name,&amp;Cur-&gt;cScore,&amp;Cur-&gt;mathScore,&amp;Cur-&gt;englishScore); Cur-&gt;allScore = Cur-&gt;cScore + Cur-&gt;englishScore + Cur-&gt;mathScore; &#125; else printf("查无此人\n"); SaveFile(head,"STU"); &#125; else &#123; Identity *Cur = ((Identity*)Find(id,head,"ACC"))-&gt;next; printf("请输入新密码:\n"); Cur-&gt;key = KeyIn(); printf("\n"); SaveFile(head,"ACC"); &#125;&#125;void Delete(long long id,Class*student,Identity*accont,char*func) &#123; if(strcmp(func,"STU")==0) &#123; Class *p = Find(id,student,"STU"); if(p-&gt;next) &#123; Class *r = p-&gt;next; p-&gt;next = r-&gt;next; free(r); &#125; else &#123; printf("操作有误\n"); return; &#125; SaveFile(student,"STU"); &#125; Identity *p = Find(id,accont,"ACC"); if(p-&gt;next) &#123; if(p-&gt;identity==0) &#123; Class *r = p-&gt;next; p-&gt;next = r-&gt;next; free(r); &#125; &#125; else &#123; printf("操作有误\n"); &#125; SaveFile(accont,"ACC"); printf("成功!!!\n");&#125;void *Find(long long id,void *head,char *func) &#123; if(strcmp(func,"STU")==0) &#123; Class *p = (Class*)head; while(p-&gt;next&amp;&amp;p-&gt;next-&gt;id !=id) p = p-&gt;next; return p; &#125; else &#123; Identity *p = (Identity*)head; while(p-&gt;next&amp;&amp;p-&gt;next-&gt;id !=id) p = p-&gt;next; return p; &#125;&#125;void *readFile(char*func) &#123; FILE* fp; if(strcmp(func,"STU")==0) &#123; Class *head = (Class*)malloc(sizeof(Class)); Class *p,*r = head; head-&gt;next = NULL; fp = fopen("student.txt", "ab+"); while(1) &#123; p=(Class*)malloc(sizeof(Class)); if(fread(p,sizeof(Class)-sizeof(Class*),1,fp)) &#123; r-&gt;next = p; r = p; &#125; else break; &#125; r-&gt;next = NULL; return head; &#125; else &#123; Identity *head = (Identity*)malloc(sizeof(Identity)); Identity *p,*r = head; head-&gt;next = NULL; fp = fopen("accont.txt", "ab+"); while(1) &#123; p=(Identity*)malloc(sizeof(Identity)); if(fread(p,sizeof(Identity)-sizeof(Identity*),1,fp)) &#123; r-&gt;next = p; r = p; &#125; else break; &#125; r-&gt;next = NULL; return head; &#125;&#125;void SaveFile(void *head,char*func) &#123; FILE *fp; if(strcmp(func,"STU")==0) &#123; fp = fopen("student.txt","wb"); Class* p = (Class*)head; while(p = p-&gt;next) fwrite(p,sizeof(*p)-sizeof(Class*),1,fp); &#125; else &#123; fp = fopen("accont.txt","wb"); Identity* p = (Identity*)head; while(p = p-&gt;next) fwrite(p,sizeof(*p)-sizeof(Identity*),1,fp); &#125; fclose(fp);&#125;void GotuStudent(long long id,long long key,Identity* accont,Class*student) &#123; ///学生端 int input; while(1) &#123; Show("student"); scanf("%d",&amp;input); switch(input) &#123; case 1: Show("splitter"); Print(((Class*)(Find(id,student,"STU")))-&gt;next); break; case 2: Change(id,accont,"ACC"); break; case 3: return; default: printf("输入有误"); &#125; system("pause"); &#125;&#125;void GotoTeacher(long long id,long long key,Identity*accont,Class*student) &#123; ///教师端 while(1) &#123; Show("teacher"); int input; scanf("%d",&amp;input); switch(input) &#123; case 1: Add(student,accont,"STU"); break; case 2: Sort(student); ViewAll(student); break; case 3: &#123; long long findId; printf("请输入查询的id:\n"); scanf("%lld",&amp;findId); Class* find = ((Class*)Find(findId,student,"STU"))-&gt;next; if(find) &#123; Show("splitter"); Print(find); &#125; else printf("查无此人\n"); break; &#125; case 4: &#123; long long changeId; printf("请输入修改的id:\n"); scanf("%lld",&amp;changeId); Change(changeId,student,"STU"); &#125; break; case 5: &#123; long long deleteId; printf("请输入要删除的id:\n"); scanf("%lld",&amp;deleteId); Delete(deleteId,student,accont,"STU"); break; &#125; case 6: Change(id,accont,"ACC"); break; case 7: return; default: printf("输入错误,请重新输入\n"); Sleep(1000); &#125; system("pause"); &#125;&#125;void Admin(void *head) &#123; while(1) &#123; system("cls"); Show("Admin"); int input; scanf("%d",&amp;input); switch(input) &#123; case 1: Add(NULL,head,"ACC"); break; case 2: &#123; long long deleteId; printf("请输入要删除的id:\n"); scanf("%lld",&amp;deleteId); Delete(deleteId,NULL,head,"ACC"); break; &#125; case 3: return; case 4: Init(); break; default: printf("输入有误\n"); &#125; system("pause"); &#125;&#125;void Show(char *func) &#123; system("cls"); if(strcmp(func,"splitter")==0) &#123; ///Splitter printf(" id 姓名 c语言成绩 数学成绩 英语成绩 总分\n"); printf("==========================================================================\n"); &#125; else if(strcmp(func,"teacher")==0) &#123; ///Teacher; printf("┌───────────────────────────────────┐\n"); printf("│ 学生成绩管理系统 │\n"); printf("│ 教师端 │\n"); printf("│───────────────────────────────────│\n"); printf("│ 添加学生信息 --&gt;1 │\n"); printf("│ 浏览所有学生信息 --&gt;2 │\n"); printf("│ 查询学生信息 --&gt;3 │\n"); printf("│ 修改学生信息 --&gt;4 │\n"); printf("│ 删除学生信息 --&gt;5 │\n"); printf("│ 修改密码 --&gt;6 │\n"); printf("│ 退出系统 --&gt;7 │\n"); printf("└───────────────────────────────────┘\n"); &#125; else if(strcmp(func,"student")==0) &#123; printf("┌────────────────────────────────────┐\n"); printf("│──────────学生成绩管理系统──────────│\n"); printf("│────────────────────────────────────│\n"); printf("│ 查询自己成绩信息 --&gt;1 │\n"); printf("│ 修改密码 --&gt;2 │\n"); printf("│ 退出系统 --&gt;3 │\n"); printf("└────────────────────────────────────┘\n"); &#125; else if(strcmp(func,"Login")==0) &#123; printf("┌────────────────────────────────────┐\n"); printf("│──────────学生成绩管理系统──────────│\n"); printf("│────────────────────────────────────│\n"); printf("│请输入账号： │\n"); printf("│────────────────────────────────────│\n"); printf("│请输入密码： │ \n"); printf("└────────────────────────────────────┘\n"); &#125; else if(strcmp(func,"Admin")==0) &#123; printf("┌───────────────────────────────────┐\n"); printf("│ 学生成绩管理系统 │\n"); printf("│ 管理员端 │\n"); printf("│───────────────────────────────────│\n"); printf("│ 添加教师账号 --&gt;1 │\n"); printf("│ 删除教师账号 --&gt;2 │\n"); printf("│ 退出系统 --&gt;3 │\n"); printf("│ 重置系统 --&gt;4 │\n"); printf("└───────────────────────────────────┘\n"); &#125; else &#123; ///Load char loadR[] = &#123;"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"&#125;; char loadL[] = &#123;"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"&#125;; const int leng = sizeof(loadR)/sizeof(char); char *ploadR[leng+5],*ploadL[leng+5]; int i; printf("\n\n"); for(i=0;i&lt;leng;i++)&#123; ploadR[i] = &amp;loadR[i]; ploadL[i] = &amp;loadL[i]; &#125; for(i=1;i &lt;= leng; i++) &#123; printf("\r%50s Loading %3d%% %-50s",ploadL[leng-i],i*2,ploadR[leng-i]); Sleep(40); &#125; printf("\n"); &#125;&#125;void Init() &#123; ///重置系统 printf("请注意,该操作将会清空系统内所有信息!\n"); Sleep(1000); printf("1.执行\n2.不执行\n"); int flag; scanf("%d",&amp;flag); if(flag==1) &#123; FILE *fin = fopen("student.txt","w"); FILE *fout = fopen("accont.txt","w"); fclose(fin); fclose(fout); printf("重置成功!\n"); Sleep(1000); return; &#125; else if(flag==2) return; else printf("输入有误,默认返回\n"); Sleep(1000); return;&#125;void Sort(Class* head) &#123; ///冒泡,q,p为交换数据的前一个节点 Class* p = head,*q; while(p-&gt;next)&#123; q = p; while(q = q-&gt;next)&#123; if(q-&gt;next&amp;&amp; p-&gt;next-&gt;allScore &gt; q-&gt;next-&gt;allScore)&#123; Class *tmp = p-&gt;next; p-&gt;next = q-&gt;next; q-&gt;next = q-&gt;next-&gt;next; p-&gt;next-&gt;next = tmp; &#125; &#125; p = p-&gt;next; &#125;&#125;]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51Nod 2006 飞行员配对 二分图匹配 匈牙利算法]]></title>
    <url>%2F2019%2F04%2F22%2F104%2F</url>
    <content type="text"><![CDATA[关于二分图有一个很通俗的解释 现在你是一个媒婆,给你一票人,你要尽可能多的撮合这票人里面的男生和女生 当然强扭的瓜不甜,如果男生和女生相互之间都没有感觉的话是没办法强行让他们在一起的 51Nod 2006 的 飞行员配对 就是一道二分图匹配的入门题 下面让我们来看看题目2006 飞行员配对(二分图最大匹配)题目来源： 网络流24题基准时间限制：1 秒 空间限制：131072 KB 分值: 0 难度：基础题第二次世界大战时期，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2名飞行员，其中1名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空 军一次能派出最多的飞机 。对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案， 使皇家空军一次能派出最多的飞机。Input第1行有2个正整数 m 和 n。n 是皇家空军的飞行 员总数(n&lt;100);m 是外籍飞行员数。外籍飞行员编号为 1~m;英国飞行员编号为 m+1~n。接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。输入最后以 2 个-1 结束。 Output 第 1 行是最佳飞行 员配对方案一次能派出的最多的飞机数 M。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。Input示例5 101 71 82 62 92 103 73 84 74 85 10-1 -1Output示例4特定的英国飞行员只喜欢特定的外籍飞行员,这道题 就是让你求出1-&gt;m和m+1-&gt;n的情侣对数 先整理一下二分图的思想:以下简称英/外 样例中外为1-5号,英为6-10号我们先把这个样例用图表示出来 为了区分，这里的1-5都是用的不同颜色的线上面就是样例所构成的二分图 匈牙利算法的思想就是尽可能的匹配更多的人，所以用递归来对所有能匹配情况进行实验，代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define maxn 200#define INF 0x3f3f3f3f#define mem(a,b) memset(a,b,sizeof(a))typedef long long ll;int m,n,t,used[maxn],map[maxn][maxn],next[maxn];bool Find(int x)&#123; for(int i=m+1;i&lt;=n;i++)&#123; if(map[x][i]&amp;&amp;!used[i])&#123;//i还没有找到自己的拍档并且x和i是可以组成拍档的 used[i] = 1; if(next[i]==0||Find(next[i]))&#123;///如果i没有拍档或者i还可以找到下一个拍档 next[i] = x; return true; &#125; &#125; &#125; return false;&#125;int match()&#123; //开始正式当媒婆~~~ int sum = 0; for(int i=1;i&lt;=m;i++)&#123; mem(used,0); if(Find(i)) sum++; &#125; return sum;&#125;int main()&#123; int u,v; mem(map,0); mem(used,0); mem(next,0); cin &gt;&gt; m &gt;&gt; n; while(cin &gt;&gt; u &gt;&gt; v&amp;&amp;u!=-1&amp;&amp;v!=-1) map[u][v] = 1; cout &lt;&lt; match() &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c用餐管理系统----------文件链表相关操作]]></title>
    <url>%2F2019%2F04%2F22%2F102%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260#include"stdio.h"#include"string.h"#include"stdlib.h"#define MaxSize 20typedef struct guest_info &#123; char name[8]; int sum; char time[10]; int number; struct guest_info * next;&#125; GuestLink,* Pointer;void Insert(Pointer * Head);void Search(Pointer Head );void Update(Pointer Head);void Delete(Pointer * Head);void Show(Pointer Head);Pointer Sort(Pointer );///排序void Storage(Pointer ); ///储存Pointer ReadFile();///浏览文件int main() &#123; Pointer Head=NULL; int i; do &#123; printf("\n"); printf("1---插入(Insert)\n"); printf("2---查询(Search)\n"); printf("3---修改(Update)\n"); printf("4---删除-(Delete)\n"); printf("5---显示(Show)\n"); printf("6---退出(Exit)\n"); printf("7---排序(Sort)\n"); printf("8---录入文件(Storage)\n"); printf("9---读取数据(ReadFile)\n"); scanf("%d",&amp;i); switch(i) &#123; case 1: Insert(&amp;Head); break; case 2: Search(Head); break; case 3: Update(Head); break; case 4: Delete(&amp;Head); break; case 5: Show(Head); break; case 6: break; case 7: Head = Sort(Head); break; case 8: Storage(Head); break; case 9: Head = ReadFile(); Show(Head); break; default: printf("错误选择！请重选"); break; &#125; &#125; while(i!=6); return 0;&#125;void Insert(Pointer * Head) &#123; int in_number; Pointer p,q,r; printf("请输入编号:"); scanf("%d",&amp;in_number); p=q=* Head; while(p!=NULL) &#123; if(p-&gt;number==in_number) &#123; printf("已经有相同的编号:"); return; &#125; else &#123; q=p; p=p-&gt;next; &#125; &#125; r=(Pointer)malloc(sizeof(GuestLink)); r-&gt;next=NULL; if(r==NULL) &#123; printf("分配空间失败!"); return; &#125; if(q==NULL) * Head=r; else &#123; q-&gt;next=r; &#125; r-&gt; number=in_number; printf("请输入姓名:"); scanf("%s",r-&gt;name); printf("请输入人数:"); scanf("%d", &amp;r-&gt;sum); printf("请输入用餐时间:"); scanf("%s", r-&gt;time);&#125;void Search(Pointer Head) &#123; int flag=1; int number; Pointer p; printf("请输入要查询的编号:"); scanf("%d", &amp;number); p=Head; while(p!=NULL&amp;&amp;flag) &#123; if(p-&gt;number==number) &#123; printf("姓名:%s",p-&gt;name); printf("人数:%d",p-&gt;sum); printf("用餐时间:%s",p-&gt;time); flag=0; &#125; else p=p-&gt;next; &#125; if(flag) printf("没有查询到!!");&#125;void Update(Pointer Head) &#123; int flag=1; int number; Pointer p; printf("请输入要修改的编号:"); scanf("%d",&amp;number); p=Head; while(p!=NULL&amp;&amp;flag) &#123; if(p-&gt;number==number) &#123; printf("请输入人数:"); scanf("%d",p-&gt;sum); printf("请输入用餐时间:"); scanf("%s",p-&gt;time); flag=0; &#125; else p=p-&gt;next; &#125; if(flag) printf("没有找到要修改的记录!!");&#125;void Delete(Pointer *Head) &#123; int flag=1; int number; Pointer p,q; printf("请输入要删除数据的编号"); scanf("%d",&amp;number); p=q=* Head; while(p!=NULL&amp;&amp;flag) &#123; if(p-&gt;number==number) &#123; if(p==* Head) &#123; *Head=p-&gt;next; free(p); &#125; else &#123; q-&gt;next=p-&gt;next; free(p); &#125; flag=0; &#125; else &#123; q=p; p=p-&gt;next; &#125; &#125; if(flag) printf("没有找到可以删除的数据!!");&#125;void Show(Pointer Head) &#123; Pointer p; p=Head; while(p!=NULL) &#123; printf("姓名: %-10s",p-&gt;name); printf("人数: %-10d",p-&gt;sum); printf("用餐时间: %-10s",p-&gt;time); printf("编号: %-10d\n",p-&gt;number); p=p-&gt;next; &#125;&#125;Pointer Sort(Pointer Head) &#123; Pointer pfirst,ptail,pminBefore,pmin,p; pfirst = NULL; while(Head!=NULL) &#123; for (p = Head, pmin = Head; p-&gt;next != NULL; p = p-&gt;next) &#123; if(strcmp(p-&gt;next-&gt;time,pmin-&gt;time) &lt; 0) &#123; pminBefore = p; pmin = p-&gt;next; &#125; &#125; if(pfirst == NULL) &#123; pfirst = pmin; ptail = pmin; &#125; else &#123; ptail-&gt;next = pmin; ptail = pmin; &#125; if(pmin == Head) Head = Head-&gt;next; else pminBefore-&gt;next = pmin-&gt;next; &#125; if(pfirst != NULL) ptail-&gt;next = NULL; Head = pfirst; return Head;&#125;void Storage(Pointer Head) &#123; ///储存 Pointer cur; cur = Head; FILE *fp = fp = fopen( "学生信息.txt", "w" ); while(cur != NULL)&#123; fprintf(fp, "%s\t%d\t%s\t%d\n", cur-&gt;name,cur-&gt;sum,cur-&gt;time,cur-&gt;number); cur = cur-&gt;next; &#125; fclose(fp);&#125;Pointer ReadFile() &#123; char name[8]; int sum; Pointer r,s; Pointer first; first = (Pointer)malloc(sizeof(GuestLink)); r = first; first-&gt;next = NULL; char time[10]; int number; FILE* fp; fp = fopen("学生信息.txt", "r"); while(1) &#123; fscanf(fp, "%s%d%s%d",name,&amp;sum,time,&amp;number); if(feof(fp)) break; s=(Pointer)malloc(sizeof(GuestLink)); strcpy(s-&gt;name,name); s-&gt;sum = sum; strcpy(s-&gt;time,time); s-&gt;number = number; r-&gt;next = s; r = s; &#125; r-&gt;next = NULL; return first-&gt;next; fclose(fp);&#125;///浏览文件*/]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言班费收支系统-------二进制文件操作]]></title>
    <url>%2F2019%2F04%2F21%2F77%2F</url>
    <content type="text"><![CDATA[共约370行代码,撸了半天撸出来了 主要包含以下数据 班费收支编号,收入/支出,经办人.原因.金额.备注,余额; 采用二进制文本的形式储存 实现有以下功能: 添加班费收支信息 浏览所有班费收支信息 按照不同字段(收支编号,原因等)查询班费收支信息 修改班费收支信息///这个对二进制的修改很麻烦,我就退而求其次了,把所有文本的内容读取出来,修改了之后再重新写入 扩展功能: 按某些字段进行排序浏览 不同收入和支出分别存放在不同的文件中 把文件中的收入和支出信息导入的程序中 当中还有很多做的不好的地方,代码重复率很高,我争取改进123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt; ///消息窗口处理的头文件,此源码只使用了其中的Sleep函数和清屏函数#include &lt;string.h&gt; ///字符串处理的头文件#define maxn 500typedef struct Class &#123; int id; //id int kind; //收入\支出 char person[maxn]; //经手人 char result[maxn]; //原因 int amount; //数额 char tips[maxn]; //备注&#125; Class;void Print(Class s) &#123; ///对内容进行输出 printf("%5d%20d%20s%20s%20d%20s\n",s.id,s.kind,s.person,s.result,s.amount,s.tips);&#125;;void Init();void Watch(); ///浏览void Add(); ///添加void Find(); ///查找void Change(); ///修改void Find1(int,Class*,int); //查找idvoid Find2(int,Class*,int); //查找收入\输出,下面函数同理void Find3(int,Class*,char*);void Find4(int,Class*,char*);void Find5(int,Class*,int);void Input(); ///输入int cmp1(const void*,const void*);int cmp2(const void*,const void*);int cmp3(const void*,const void*);int cmp4(const void*,const void*);int cmp5(const void*,const void*);int cmp6(const void*,const void*);int main() &#123; Input(); return 0;&#125;void Init()&#123; printf("请注意,该操作将会清空收支信息!\n"); Sleep(1000); printf("1.执行\n2.返回主菜单\n"); int flag; scanf("%d",&amp;flag); if(flag==1)&#123; FILE *fin = fopen("income.txt","wb"); ///用wb方式打开又关闭文件可生成此文件/// FILE *fout = fopen("expenditure.txt","wb"); fclose(fin); fclose(fout); printf("重置成功!\n"); Sleep(1000); return; &#125; else if(flag==2) return; else printf("输入有误,默认返回主菜单\n"); Sleep(1000); return;&#125;void Change() &#123; FILE *fin = fopen("income.txt","rb"); FILE *fout = fopen("expenditure.txt","rb"); FILE *f; Class s[maxn]; int i,j; for(i=0; fread(&amp;s[i],sizeof(Class),1,fin); i++); for(j=0; fread(&amp;s[i],sizeof(Class),1,fout); j++); fclose(fin); fclose(fout); i += j; int id; int flag = 0; printf("请输入ID:\n"); scanf("%d",&amp;id); for(j=0; j&lt;i; j++) if(s[j].id == id) &#123; flag = 1; break; &#125; printf(flag?"请按照经办人 收入(0)/支出(1) 原因 金额 备注的格式写入信息,写入后此ID所对应的信息为此时输入的内容\n":"该ID不存在\n"); Sleep(1000); if(!flag) return; scanf("%s %d %s %d %s",s[j].person,&amp;s[j].kind,s[j].result,&amp;s[j].amount,s[j].tips); fin = fopen("income.txt","wb"); fout = fopen("expenditure.txt","wb"); fclose(fin); fclose(fout); for(j=0; j&lt;i; j++) &#123; if(s[j].kind == 1) &#123; f = fopen("expenditure.txt","ab+"); &#125; else f = fopen("income.txt","ab+"); fwrite(&amp;s[j],sizeof(Class),1,f); fclose(f); &#125; printf("修改成功,1S后返回上一菜单\n"); Sleep(1000);&#125;void Watch() &#123; system("cls"); FILE *fin = fopen("income.txt","rb"); FILE *fout = fopen("expenditure.txt","rb");///收入和支出的文件指针 Class s[maxn]; int i,j; for(i=0; fread(&amp;s[i],sizeof(Class),1,fin); i++)///无限读取,直到文件读完为止,fread当文件已经读完或者读到EOF的时候返回0,这个式子才不成立,循环跳出 s[i].kind = 0; for(j=0; fread(&amp;s[i],sizeof(Class),1,fout); j++) s[i].kind = 1; fclose(fin); fclose(fout); i += j; ///此时i为收入和支出的总次数next: system("cls"); printf("请输入浏览方式:\n"); printf("1.按照ID排序\n"); printf("2.按照种类排序\n"); printf("3.按照经办人排序\n"); printf("4.按照原因排序\n"); printf("5.按照金额排序\n"); printf("6.按照备注排序\n"); int n; ///输入排序方式 scanf("%d",&amp;n); switch(n) &#123; case 1: qsort(s,i,sizeof(s[0]),cmp1);///qsort为c语言内置快速排序函数,需要与比较函数cmp一同使用,位于头文件stdlib.h中,这里统一为从小到大排序 ///cmp的具体写法有好几种,可以百度qsort cmp写法 ///能实现对数组,数字,字符,结构体等多种数据类型排序 break; case 2: qsort(s,i,sizeof(s[0]),cmp2); break; case 3: qsort(s,i,sizeof(s[0]),cmp3); break; case 4: qsort(s,i,sizeof(s[0]),cmp4); break; case 5: qsort(s,i,sizeof(s[0]),cmp5); break; case 6: qsort(s,i,sizeof(s[0]),cmp6); break; default: printf("输入错误,按照默认排序输出\n"); &#125; int balance = 0;///余额 for(j=0; j&lt;i; j++) &#123; Print(s[j]); if(s[j].kind) balance -= s[j].amount; ///计算余额 else balance += s[j].amount; &#125; printf("余额为:%5d\n",balance); int juge; ///下一步操作next1: printf("返回主菜单请输入0\n"); printf("返回上一菜单请输入1\n"); scanf("%d",&amp;juge); if(juge==1) //判断是不是输入错误 goto next; else if (juge != 0) &#123; printf("输入错误,请重新输入\n"); goto next1; &#125; return;&#125;void Add() &#123; Class s; int flag;///判断要写入的数据种类 FILE *f; while(1) &#123; system("cls"); printf("请输入要输入的数据种类:\n0.收入 1.支出 2.停止输入\n"); scanf("%d",&amp;flag); if(flag == 1) &#123; f = fopen("expenditure.txt","ab+"); s.kind = 1; &#125; else if(flag == 0) &#123; f = fopen("income.txt","ab+"); s.kind = 0; &#125; else &#123; if(flag!=2) printf("输入错误请重新输入\n"),Sleep(1000); else break; continue; &#125; fseek(f, 0, SEEK_END); ///将文件指针移到文件末尾,方便追加输入 if(f == NULL) printf("打开失败\n"); else &#123; printf("请按照班费收支编号(请注意保证编号唯一) 经办人 原因 金额 备注的格式写入"); printf("\n中间用空格隔开,如果没有备注请在备注栏写无,其他栏同理\n"); scanf("%d%s%s%d%s",&amp;s.id,s.person,s.result,&amp;s.amount,s.tips); if(fwrite(&amp;s,sizeof(Class),1,f)!=1)///将一个结构体以二进制写入文件 printf("保存失败"); else printf("录入成功"); Sleep(1000); &#125; fclose(f); &#125;&#125;void Input() &#123;revert: system("cls"); ///清屏函数 printf("*************班费收支系统*************\n"); printf("请按快捷键进行以下操作:\n"); printf("1 添加班费收支信息\n"); printf("2 浏览所有班费收支信息\n"); printf("3 按照不同字段查询班费收支信息\n"); printf("4 修改班费收支信息\n"); printf("5 退出系统\n"); printf("6 重置系统\n"); int input; scanf("%d",&amp;input); switch(input) &#123; case 1: Add(); break; case 2: Watch(); break; case 3: Find(); break; case 4: Change(); break; case 5: return; case 6: Init(); break; default: printf("输入错误,请重新输入\n"); Sleep(1000); ///消息框延迟1000ms显示 &#125; goto revert;&#125;int cmp1(const void *a,const void *b) &#123; Class *c = (Class*)a; Class *d = (Class*)b; return c-&gt;id-d-&gt;id;&#125;int cmp2(const void *a,const void *b) &#123; Class *c = (Class*)a; Class *d = (Class*)b; return c-&gt;kind-d-&gt;kind;&#125;int cmp3(const void *a,const void *b) &#123; Class *c = (Class*)a; Class *d = (Class*)b; return strcmp(c-&gt;person,d-&gt;person);&#125;int cmp4(const void *a,const void *b) &#123; Class *c = (Class*)a; Class *d = (Class*)b; return c-&gt;result-d-&gt;result;&#125;int cmp5(const void *a,const void *b) &#123; Class *c = (Class*)a; Class *d = (Class*)b; return c-&gt;amount-d-&gt;amount;&#125;int cmp6(const void *a,const void *b) &#123; Class *c = (Class*)a; Class *d = (Class*)b; return strcmp(c-&gt;tips,d-&gt;tips);&#125;void Find() &#123; FILE *fin = fopen("income.txt","rb"); FILE *fout = fopen("expenditure.txt","rb");///收入和支出的文件指针 Class s[maxn]; int i,j; for(i=0; fread(&amp;s[i],sizeof(Class),1,fin); i++) s[i].kind = 0; for(j=0; fread(&amp;s[i],sizeof(Class),1,fout); j++) s[i].kind = 1; fclose(fin); fclose(fout); i += j; ///此时i为收入和支出的总次数 int n;///输入的信息 char Buf[maxn];///查询的内容 int buf;///查询的内容 printf("请输入要查找的类别:\n"); printf("1.编号\n"); printf("2.收入\支出\n"); printf("3.经办人\n"); printf("4.原因\n"); printf("5.金额\n"); scanf("%d",&amp;n); getchar(); switch(n) &#123; case 1: printf("请输入ID:\n"); scanf("%d",&amp;buf); Find1(i,&amp;s[0],buf); break; case 2: printf("请输入种类\n0.收入 1.支出\n"); scanf("%d",&amp;buf); Find2(i,&amp;s[0],buf); break; case 5: printf("请输入金额:\n"); scanf("%d",&amp;buf); Find5(i,&amp;s[0],buf); break; case 3: printf("请输入经手人:\n"); scanf("%s",Buf); Find3(i,&amp;s[0],Buf); break; case 4: printf("请输入原因:\n"); scanf("%s",Buf); Find4(i,&amp;s[0],Buf); break; default: printf("输入有误\n"); &#125; printf("3S后返回上一页\n"); Sleep(3000); return;&#125;void Find1(int n,Class* s,int x) &#123; ///S为存储数据的结构体数组,n为数据总量,x为要查找的ID,下面同理 int i; for(i=0; i&lt;n; i++) &#123; if(x == s[i].id) Print(s[i]); &#125; printf("输出完毕\n");&#125;void Find2(int n,Class* s,int x) &#123; int i; for(i=0; i&lt;n; i++) &#123; if(x == s[i].kind) Print(s[i]); &#125; printf("输出完毕\n");&#125;void Find3(int n,Class* s,char a[]) &#123; int i; for(i=0; i&lt;n; i++) if(strcmp(s[i].person,a) == 0) Print(s[i]); printf("输出完毕\n");&#125;void Find4(int n,Class* s,char a[]) &#123; int i; for(i=0; i&lt;n; i++) if(strcmp(s[i].result,a) == 0) Print(s[i]); printf("输出完毕\n");&#125;void Find5(int n,Class* s,int x) &#123; int i; for(i=0; i&lt;n; i++) &#123; if(x == s[i].amount) Print(s[i]); &#125; printf("输出完毕\n");&#125;]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过金矿模型介绍动态规划]]></title>
    <url>%2F2019%2F04%2F21%2F72%2F</url>
    <content type="text"><![CDATA[对于动态规划，每个刚接触的人都需要一段时间来理解，特别是第一次接触的时候总是想不通为什么这种方法可行，这篇文章就是为了帮助大家理解动态规划，并通过讲解基本的01背包问题来引导读者如何去思考动态规划。本文力求通俗易懂，无异性，不让读者感到迷惑，引导读者去思考，所以如果你在阅读中发现有不通顺的地方，让你产生错误理解的地方，让你难得读懂的地方，请跟贴指出，谢谢！ ——第一节——初识动态规划———— 经典的01背包问题是这样的： 有一个包和n个物品，包的容量为m，每个物品都有各自的体积和价值，问当从这n个物品中选择多个物品放在包里而物品体积总数不超过包的容量m时，能够得到的最大价值是多少？[对于每个物品不可以取多次，最多只能取一次，之所以叫做01背包，0表示不取，1表示取] 为了用一种生动又更形象的方式来讲解此题，我把此题用另一种方式来描述，如下： 有一个国家，所有的国民都非常老实憨厚，某天他们在自己的国家发现了十座金矿，并且这十座金矿在地图上排成一条直线，国王知道这个消息后非常高兴，他希望能够把这些金子都挖出来造福国民，首先他把这些金矿按照在地图上的位置从西至东进行编号，依次为0、1、2、3、4、5、6、7、8、9，然后他命令他的手下去对每一座金矿进行勘测，以便知道挖取每一座金矿需要多少人力以及每座金矿能够挖出多少金子，然后动员国民都来挖金子。 题目补充1：挖每一座金矿需要的人数是固定的，多一个人少一个人都不行。国王知道每个金矿各需要多少人手，金矿i需要的人数为peopleNeeded[i]。 题目补充2：每一座金矿所挖出来的金子数是固定的，当第i座金矿有peopleNeeded[i]人去挖的话，就一定能恰好挖出gold[i]个金子。否则一个金子都挖不出来。 题目补充3：开采一座金矿的人完成开采工作后，他们不会再次去开采其它金矿，因此一个人最多只能使用一次。 题目补充4：国王在全国范围内仅招募到了10000名愿意为了国家去挖金子的人，因此这些人可能不够把所有的金子都挖出来，但是国王希望挖到的金子越多越好。 题目补充5：这个国家的每一个人都很老实（包括国王），不会私吞任何金子，也不会弄虚作假，不会说谎话。 题目补充6：有很多人拿到这个题后的第一反应就是对每一个金矿求出平均每个人能挖出多少金子，然后从高到低进行选择，这里要强调这种方法是错的，如果你也是这样想的，请考虑背包模型，当有一个背包的容量为10，共有3个物品，体积分别是3、3、5，价值分别是6、6、9，那么你的方法取到的是前两个物品，总价值是12，但明显最大值是后两个物品组成的15。 题目补充7：我们只需要知道最多可以挖出多少金子即可，而不用关心哪些金矿挖哪些金矿不挖。 那么，国王究竟如何知道在只有10000个人的情况下最多能挖出多少金子呢？国王是如何思考这个问题的呢？ 国王首先来到了第9个金矿的所在地（注意，第9个就是最后一个，因为是从0开始编号的，最西边的那个金矿是第0个），他的臣子告诉他，如果要挖取第9个金矿的话就需要1500个人，并且第9个金矿可以挖出8888个金子。听到这里国王哈哈大笑起来，因为原先他以为要知道十个金矿在仅有10000个人的情况下最多能挖出多少金子是一件很难思考的问题，但是，就在刚才听完他的臣子所说的那句话时，国王已经知道总共最多能挖出多少金子了，国王是如何在不了解其它金矿的情况下知道最多能挖出多少金子的呢？他的臣子们也不知道这个谜，因此他的臣子们就问他了：“最聪明的国王陛下，我们都没有告诉您其它金矿的情况，您是如何知道最终答案的呢？” 得意的国王笑了笑，然后把他最得意的“左、右手”叫到跟前，说到：“我并不需要考虑最终要挖哪些金矿才能得到最多的金子，我只需要考虑我面前的这座金矿就可以了，对于我面前的这座金矿不外乎仅有两种选择，要么挖，要么不挖，对吧？” “当然，当然”大臣们回答倒。 国王继续说道：“如果我挖取第9座金矿的话那么我现在就能获得8888个金子，而我将用去1500个人，那么我还剩下8500个人。我亲爱的左部下，如果你告诉我当我把所有剩下的8500个人和所有剩下的其它金矿都交给你去开采你最多能给我挖出多少金子的话，那么我不就知道了在第9个金矿一定开采的情况下所能得到的最大金币数吗？” 国王的左部下听后回答道：“国王陛下，您的意思是如果我能用8500个人在其它金矿最多开采出x个金币的话，那您一共就能够获得 x + 8888个金子，对吗？” “是啊，是啊……如果第9座金矿一定开采的话……”大臣们点头说到。 国王笑着继续对着他的右部下说到：“亲爱的右部下，也许我并不打算开采这第9座金矿，那么我依然拥有10000个人，如果我把这10000个人和剩下的金矿都给你的话，你最多能给我挖出多少个金子呢？” 国王的右部下聪明地说道：“尊敬的国王陛下，我明白您的意思了，如果我回答最多能购开采出y个金币的话，那您就可以在y和x+8888之间选择一个较大者，而这个较大者就是最终我们能获得的最大金币数，您看我这样理解对吗？” 国王笑得更灿烂了，问他的左部下：“那么亲爱的左部下，我给你8500个人和其余金矿的话你能告诉我最多能挖出多少金子吗？” “请您放心，这个问题难不倒我”。左部下向国王打包票说到。 国王高兴地继续问他的右部下：“那右部下你呢，如果我给你10000个人和其余金矿的话你能告诉我最多能挖出多少金子吗？” “当然能了！交给我吧！”右部下同左部下一样自信地回答道。 “那就拜托给你们两位了，现在我要回到我那舒适的王宫里去享受了，我期待着你们的答复。”国王说完就开始动身回去等消息了，他是多么地相信他的两个大臣能够给他一个准确的答复，因为国王其实知道他的两位大臣要比他聪明得多。 故事发展到这里，你是否在想国王的这两个大臣又是如何找到让国王满意的答案的呢？他们为什么能够如此自信呢？事实上他们的确比国王要聪明一些，因为他们从国王的身上学到了一点，就是这一点让他们充满了自信。 国王走后，国王的左、右部下来到了第8座金矿，早已在那里等待他们的金矿勘测兵向两位大臣报道：“聪明的两位大臣，您们好，第8座金矿需要1000个人才能开采，可以获得7000个金子”。 因为国王仅给他的左部下8500个人，所以国王的左部下叫来了两个人，对着其中一个人问到：“如果我给你7500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 然后国王的左部下继续问另一个人：“如果我给你8500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 国王的左部下在心里想着：“如果他们俩都能回答我的问题的话，那国王交给我的问题不就解决了吗？哈哈哈！” 因为国王给了他的右部下10000个人，所以国王的右部下同样也叫来了两个人，对着其中一个人问：“如果我给你9000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 然后国王的右部下继续问他叫来的另一个人：“如果我给你10000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 此时，国王的右部下同左部下一样，他们都在为自己如此聪明而感到满足。 当然，这四个被叫来的人同样自信地回答没有问题，因为他们同样地从这两个大臣身上学到了相同的一点，而两位自认为自己一样很聪明的大臣得意地笑着回到了他们的府邸，等着别人回答他们提出来的问题，现在你知道了这两个大臣是如何解决国王交待给他们的问题了吗？ 那么你认为被大臣叫去的那四个人又是怎么完成大臣交给他们的问题的呢？答案当然是他们找到了另外八个人！ 没用多少功夫，这个问题已经在全国传开了，更多人的人找到了更更多的人来解决这个问题，而有些人却不需要去另外找两个人帮他，哪些人不需要别人的帮助就可以回答他们的问题呢？ 很明显，当被问到给你z个人和仅有第0座金矿时最多能挖出多少金子时，就不需要别人的帮助，因为你知道，如果z大于等于挖取第0座金矿所需要的人数的话，那么挖出来的最多金子数就是第0座金矿能够挖出来的金子数，如果这z个人不够开采第0座金矿，那么能挖出来的最多金子数就是0，因为这唯一的金矿不够人力去开采。让我们为这些不需要别人的帮助就可以准确地得出答案的人们鼓掌吧，这就是传说中的底层劳动人民！ 故事讲到这里先暂停一下，我们现在重新来分析一下这个故事，让我们对动态规划有个理性认识。 子问题： 国王需要根据两个大臣的答案以及第9座金矿的信息才能判断出最多能够开采出多少金子。为了解决自己面临的问题，他需要给别人制造另外两个问题，这两个问题就是子问题。 思考动态规划的第一点——最优子结构： 国王相信，只要他的两个大臣能够回答出正确的答案（对于考虑能够开采出的金子数，最多的也就是最优的同时也就是正确的），再加上他的聪明的判断就一定能得到最终的正确答案。我们把这种子问题最优时母问题通过优化选择后一定最优的情况叫做“最优子结构”。 思考动态规划的第二点——子问题重叠： 实际上国王也好，大臣也好，所有人面对的都是同样的问题，即给你一定数量的人，给你一定数量的金矿，让你求出能够开采出来的最多金子数。我们把这种母问题与子问题本质上是同一个问题的情况称为“子问题重叠”。然而问题中出现的不同点往往就是被子问题之间传递的参数，比如这里的人数和金矿数。 思考动态规划的第三点——边界： 想想如果不存在前面我们提到的那些底层劳动者的话这个问题能解决吗？永远都不可能！我们把这种子问题在一定时候就不再需要提出子子问题的情况叫做边界，没有边界就会出现死循环。 思考动态规划的第四点——子问题独立： 要知道，当国王的两个大臣在思考他们自己的问题时他们是不会关心对方是如何计算怎样开采金矿的，因为他们知道，国王只会选择两个人中的一个作为最后方案，另一个人的方案并不会得到实施，因此一个人的决定对另一个人的决定是没有影响的。我们把这种一个母问题在对子问题选择时，当前被选择的子问题两两互不影响的情况叫做“子问题独立”。 这就是动态规划，具有“最优子结构”、“子问题重叠”、“边界”和“子问题独立”，当你发现你正在思考的问题具备这四个性质的话，那么恭喜你，你基本上已经找到了动态规划的方法。 有了上面的这几点，我们就可以写出动态规划的转移方程式，现在我们来写出对应这个问题的方程式，如果用gold[mineNum]表示第mineNum个金矿能够挖出的金子数，用peopleNeeded[mineNum]表示挖第mineNum个金矿需要的人数，用函数f(people,mineNum)表示当有people个人和编号为0、1、2、3、……、mineNum的金矿时能够得到的最大金子数的话，f(people,mineNum)等于什么呢？或者说f(people,mineNum)的转移方程是怎样的呢？ 答案是： 当mineNum = 0且people &gt;= peopleNeeded[mineNum]时 f(people,mineNum) = gold[mineNum] 当mineNum = 0且people &lt; peopleNeeded[mineNum]时 f(people,mineNum) = 0 当mineNum != 0时 f(people,mineNum) = f(people-peopleNeeded[mineNum], mineNum-1) + gold[mineNum]与f(people, mineNum-1)中的较大者，前两个式子对应动态规划的“边界”，后一个式子对应动态规划的“最优子结构”请读者弄明白后再继续往下看。 ——第二节——动态规划的优点———— 现在我假设读者你已经搞清楚了为什么动态规划是正确的方法，但是我们为什么需要使用动态规划呢？请先继续欣赏这个故事： 国王得知他的两个手下使用了和他相同的方法去解决交代给他们的问题后，不但没有认为他的两个大臣在偷懒，反而很高兴，因为他知道，他的大臣必然会找更多的人一起解决这个问题，而更多的人会找更更多的人，这样他这个聪明的方法就会在不经意间流传开来，而全国人民都会知道这个聪明的方法是他们伟大的国王想出来的，你说国王能不高兴吗？ 但是国王也有一些担忧，因为他实在不知道这个“工程”要动用到多少人来完成，如果帮助他解决这个问题的人太多的话那么就太劳民伤财了。“会不会影响到今年的收成呢？”国王在心里想着这个问题，于是他请来了整个国家里唯一的两个数学天才，一个叫做小天，另一个叫做小才。 国王问小天：“小天啊，我发觉这个问题有点严重，我知道其实这可以简单的看成一个组合问题，也就是从十个金矿中选取若干个金矿进行开采，看看哪种组合得到的金子最多，也许用组合方法会更好一些。你能告诉我一共有多少种组合情况吗？” “国王陛下，如果用组合方法的话一共要考虑2的10次方种情况，也就是1024种情况。”小天思考了一会回答到。 “嗯……，如果每一种情况我交给一个人去计算能得到的金子数的话，那我也要1024个人，其实还是挺多的。”国王好像再次感觉到了自己的方法是正确的。 国王心理期待着小才能够给它一个更好的答案，问到：“小才啊，那么你能告诉我用我的那个方法总共需要多少人吗？其实，我也计算过，好像需要的人数是1+2+4+8+16+32+64+……，毕竟每一个人的确都需要找另外两个人来帮助他们……” 不辜负国王的期待，小才微笑着说到：“亲爱的国王陛下，其实我们并不需要那么多人，因为有很多问题其实是相同的，而我们只需要为每一个不同的问题使用一个人力便可。” 国王高兴的问到：“此话如何讲？” “打个比方，如果有一个人需要知道1000个人和3个金矿可以开采出多少金子，同时另一个人也需要知道1000个人和3个金矿可以开采出多少金子的话，那么他们可以去询问相同的一个人，而不用各自找不同的人浪费人力了。” 国王思考着说到：“嗯，很有道理，如果问题是一样的话那么就不需要去询问两个不同的人了，也就是说一个不同的问题仅需要一个人力，那么一共有多少个不同的问题呢？” “因为每个问题的人数可以从0取到10000，而金矿数可以从0取到10，所以最多大约有10000 10 等于100000个不同的问题。” 小才一边算着一边回答。 “什么？十万个问题？十万个人力？”国王有点失望。 “请国王放心，事实上我们需要的人力远远小于这个数的，因为不是每一个问题都会遇到，也许我们仅需要一、两百个人力就可以解决这个问题了，这主要和各个金矿所需要的人数有关。” 小才立刻回答到。 故事的最后，自然是国王再一次向他的臣民们证明了他是这个国家里最聪明的人，现在我们通过故事的第二部分来考虑动态规划的另外两个思考点。 思考动态规划的第五点——做备忘录： 正如上面所说的一样，当我们遇到相同的问题时，我们可以问同一个人。讲的通俗一点就是，我们可以把问题的解放在一个变量中，如果再次遇到这个问题就直接从变量中获得答案，因此每一个问题仅会计算一遍，如果不做备忘的话，动态规划就没有任何优势可言了。 思考动态规划的第六点——时间分析： 正如上面所说，如果我们用穷举的方法，至少需要2^n个常数时间，因为总共有2^n种情况需要考虑，如果在背包问题中，包的容量为1000，物品数为100，那么需要考虑2^100种情况,这个数大约为10的30次方。 而如果用动态规划，最多大概只有1000\100 = 100000个不同的问题，这和10的30次方比起来优势是很明显的。而实际情况并不会出现那么多不同的问题，比如在金矿模型中，如果所有的金矿所需人口都是1000个人，那么问题总数大约只有100个。 非正式地，我们可以很容易得到动态规划所需时间，如果共有questionCount个相同的子问题，而每一个问题需要面对chooseCount种选择时，我们所需时间就为questionCount * chooseCount个常数。在金矿模型中，子问题最多有大概people n 个(其中people是用于开采金矿的总人数，n是金矿的总数)，因此questionCount = people n，而就像国王需要考虑是采用左部下的结果还是采用右部下的结果一样，每个问题面对两个选择，因此chooseCount = 2,所以程序运行时间为 T = O(questionCount chooseCount) =O(people n)，别忘了实际上需要的时间小于这个值，根据所遇到的具体情况有所不同。 这就是动态规划的魔力，它减少了大量的计算，因此我们需要动态规划！ ——第三节——动态规划的思考角度————— 那么什么是动态规划呢？我个人觉得，如果一个解决问题的方法满足上面六个思考点中的前四个，那么这个方法就属于动态规划。而在思考动态规划方法时，后两点同样也是需要考虑的。 面对问题要寻找动态规划的方法，首先要清楚一点，动态规划不是算法，它是一种方法，它是在一件事情发生的过程中寻找最优值的方法，因此，我们需要对这件事情所发生的过程进行考虑。而通常我们从过程的最后一步开始考虑，而不是先考虑过程的开始。 打个比方，上面的挖金矿问题，我们可以认为整个开采过程是从西至东进行开采的（也就是从第0座开始），那么总有面对最后一座金矿的时候（第9座），对这座金矿不外乎两个选择，开采与不开采，在最后一步确定时再去确定倒数第二步，直到考虑第0座金矿（过程的开始）。 而过程的开始，也就是考虑的最后一步，就是边界。 因此在遇到一个问题想用动态规划的方法去解决时，不妨先思考一下这个过程是怎样的，然后考虑过程的最后一步是如何选择的，通常我们需要自己去构造一个过程，比如后面的练习。 ——第四节——总结———- 那么遇到问题如何用动态规划去解决呢？根据上面的分析我们可以按照下面的步骤去考虑： 1、构造问题所对应的过程。 2、思考过程的最后一个步骤，看看有哪些选择情况。 3、找到最后一步的子问题，确保符合“子问题重叠”，把子问题中不相同的地方设置为参数。 4、使得子问题符合“最优子结构”。 5、找到边界，考虑边界的各种处理方式。 6、确保满足“子问题独立”，一般而言，如果我们是在多个子问题中选择一个作为实施方案，而不会同时实施多个方案，那么子问题就是独立的。 7、考虑如何做备忘录。 8、分析所需时间是否满足要求。 9、写出转移方程式。 ——第五节——练习———- 题目一：买书 有一书店引进了一套书，共有3卷，每卷书定价是60元，书店为了搞促销，推出一个活动，活动如下： 如果单独购买其中一卷，那么可以打9.5折。 如果同时购买两卷不同的，那么可以打9折。 如果同时购买三卷不同的，那么可以打8.5折。 如果小明希望购买第1卷x本，第2卷y本，第3卷z本，那么至少需要多少钱呢？（x、y、z为三个已知整数）。 当然，这道题完全可以不用动态规划来解，但是现在我们是要学习动态规划，因此请想想如何用动态规划来做？ 答案： 1、过程为一次一次的购买，每一次购买也许只买一本（这有三种方案），或者买两本（这也有三种方案），或者三本一起买（这有一种方案），最后直到买完所有需要的书。 2、最后一步我必然会在7种购买方案中选择一种，因此我要在7种购买方案中选择一个最佳情况。 3、子问题是，我选择了某个方案后，如何使得购买剩余的书能用最少的钱？并且这个选择不会使得剩余的书为负数。母问题和子问题都是给定三卷书的购买量，求最少需要用的钱，所以有“子问题重叠”，问题中三个购买量设置为参数，分别为i、j、k。 4、的确符合。 5、边界是一次购买就可以买完所有的书，处理方式请读者自己考虑。 6、每次选择最多有7种方案，并且不会同时实施其中多种，因此方案的选择互不影响，所以有“子问题独立”。 7、我可以用minMoney[i][j][k]来保存购买第1卷i本，第2卷j本，第3卷k本时所需的最少金钱。 8、共有x y z 个问题，每个问题面对7种选择，时间为：O( x y z 7) = O( x y z )。 9、用函数MinMoney(i,j,k)来表示购买第1卷i本，第2卷j本，第3卷k本时所需的最少金钱，那么有： MinMoney(i,j,k)=min(s1,s2,s3,s4,s5,s6,s7),其中s1,s2,s3,s4,s5,s6,s7分别为对应的7种方案使用的最少金钱： s1 = 60 0.95 + MinMoney(i-1,j,k) s2 = 60 0.95 + MinMoney(i,j-1,k) s3 = 60 0.95 + MinMoney(i,j,k-1) s4 = (60 + 60) 0.9 + MinMoney(i-1,j-1,k) s5 = (60 + 60) 0.9 + MinMoney(i-1,j,k-1) s6 = (60 + 60) 0.9 + MinMoney(i-1,j,k-1) s7 = (60 + 60 + 60) 0.85 + MinMoney(i-1,j-1,k-1) ——第六节——代码参考——— 下面提供金矿问题的程序源代码帮助读者理解，并提供测试数据给大家练习。 输入文件名为“beibao.in”，因为这个问题实际上就是背包问题，所以测试数据文件名就保留原名吧。 输入文件第一行有两个数，第一个是国王可用用来开采金矿的总人数，第二个是总共发现的金矿数。 输入文件的第2至n+1行每行有两个数，第i行的两个数分别表示第i-1个金矿需要的人数和可以得到的金子数。 输出文件仅一个整数，表示能够得到的最大金子数。输入样例： 100 5 77 92 22 22 29 87 50 46 99 90输出样例： 133参考代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*=========程序信息========对应题目：01背包之金矿模型使用语言：c++使用编译器：Visual Studio 2005.NET使用算法：动态规划算法运行时间：O(people * n) [people是人数，n是金矿数]作者：贵州大学05级 刘永辉 昵称：SDJL编写时间：2008年8月联系QQ：44561907E-Mail：44561907@qq.com获得更多文章请访问我的博客：www.cnblogs.com/sdjl如果发现BUG或有写得不好的地方请发邮件告诉我:)转载请保留此部分信息:)*/#include "stdafx.h"#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;const int max_n = 100;//程序支持的最多金矿数const int max_people = 10000;//程序支持的最多人数int n;//金矿数int peopleTotal;//可以用于挖金子的人数int peopleNeed[max_n];//每座金矿需要的人数int gold[max_n];//每座金矿能够挖出来的金子数int maxGold[max_people][max_n];//maxGold[i][j]保存了i个人挖前j个金矿能够得到的最大金子数，等于-1时表示未知//初始化数据 void init()&#123; ifstream inputFile("beibao.in"); inputFile&gt;&gt;peopleTotal&gt;&gt;n; for(int i=0; i&lt;n; i++) inputFile&gt;&gt;peopleNeed[i]&gt;&gt;gold[i]; inputFile.close(); for(int i=0; i&lt;=peopleTotal; i++) for(int j=0; j&lt;n; j++) maxGold[i][j] = -1;//等于-1时表示未知 [对应动态规划中的“做备忘录”]&#125;//获得在仅有people个人和前mineNum个金矿时能够得到的最大金子数，注意“前多少个”也是从0开始编号的int GetMaxGold(int people, int mineNum)&#123; //申明返回的最大金子数 int retMaxGold; //如果这个问题曾经计算过 [对应动态规划中的“做备忘录”] if(maxGold[people][mineNum] != -1) &#123; //获得保存起来的值 retMaxGold = maxGold[people][mineNum]; &#125; else if(mineNum == 0)//如果仅有一个金矿时 [对应动态规划中的“边界”] &#123; //当给出的人数足够开采这座金矿 if(people &gt;= peopleNeed[mineNum]) &#123; //得到的最大值就是这座金矿的金子数 retMaxGold = gold[mineNum]; &#125; else//否则这唯一的一座金矿也不能开采 &#123; //得到的最大值为0个金子 retMaxGold = 0; &#125; &#125; else if(people &gt;= peopleNeed[mineNum])//如果给出的人够开采这座金矿 [对应动态规划中的“最优子结构”] &#123; //考虑开采与不开采两种情况，取最大值 retMaxGold = max(GetMaxGold(people - peopleNeed[mineNum],mineNum -1) + gold[mineNum], GetMaxGold(people,mineNum - 1)); &#125; else//否则给出的人不够开采这座金矿 [对应动态规划中的“最优子结构”] &#123; //仅考虑不开采的情况 retMaxGold = GetMaxGold(people,mineNum - 1); &#125; //做备忘录 maxGold[people][mineNum] = retMaxGold; return retMaxGold;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; //初始化数据 init(); //输出给定peopleTotal个人和n个金矿能够获得的最大金子数，再次提醒编号从0开始，所以最后一个金矿编号为n-1 cout&lt;&lt;GetMaxGold(peopleTotal,n-1); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3的ACM输入输出格式]]></title>
    <url>%2F2019%2F04%2F21%2F70%2F</url>
    <content type="text"><![CDATA[python自己不是很会,但是这门语言在ACM方面还是有很多价值的,比如说大数之类的,这里记录一下python3的输入输出以作参考 第一种多组输入模板格式：while True: try: #caption = list(map(int, input().split())) #ans = 0 #for i in caption: # ans += i #print(ans) except EOFError: break 第一种模板适合那些没有告诉有多少组数据，只是让你不断地输入，典型的题型如 A+B 问题。 第二种有限输入模板格式：T = int(input()) for case in range(T): #caption = list(map(int, input().split())) #ans = 0 #for i in caption: # ans += i #print(ans) 第二种模板格式适合题目要求首先输入一个整数，代表有几组输入，然后再输入每组数据的具体值。 以上两个输入输出模板格式基本能解决 acm 里遇到的输入输出了，当然，有的时候还需适当地添加一些额外的条件停止。 再次送上一篇大佬用 python2 写的各类格式博客 ——ACM 八大输入输出格式之 Python 版 python3 与 python2 有些不同，适当做些修改即可。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python 对list排序(sort)]]></title>
    <url>%2F2019%2F04%2F21%2F68%2F</url>
    <content type="text"><![CDATA[转载注明出自bestsort.cn,谢谢合作12345678910111213141516171819202122232425262728293031323334#对字符按ASCII码从小到大排序：l = ['a','Z','w','C','Q','b','t']l.sort()print(l)#从大到小：l = ['a','Z','w','C','A','b','t']l.sort(reverse=True)print(l)#按字母顺序从小到大排序：l = ['a','Z','w','C','A','b','t']l.sort(key=str.lower)print(l)#按字母顺序从大到小排序：l = ['a','Z','w','C','A','b','t']l.sort(key=str.lower,reverse=True)print(l)#后文中如果要反序的同理在sort里面加上reverse = True就ok#对list中特殊的terple(dictionary)元素为排序：#按value排序l = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]l.sort(key=lambda k:k[1])print(l)#按照key排序l = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]l.sort(key=lambda k:k[0])print(l)#先按key后按value排序l = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]l.sort(key=lambda k:(k[0],k[1]))print(l)#对key按字母顺序排序后对value按从大到小排序l = [('Bob', 75), ('Adam', 92), ('bart', 96), ('Lisa', 88)]l.sort(key=lambda k:(k[0].lower(),k[1]))print(l)其他的大同小异，有了这些应该可以类推出来]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C二叉树操作图解(建树,遍历,销毁)]]></title>
    <url>%2F2019%2F04%2F21%2F66%2F</url>
    <content type="text"><![CDATA[后面有图解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 100typedef char DataType; //定义数据类型typedef struct BiNode&#123; DataType data; struct BiNode *Lchild,*Rchild;&#125; BiTree;//前序遍历------顺序:根-&gt;左-&gt;右void QPreOrder(BiNode *root)&#123; if(root == NULL) return; else &#123; printf("%c ",root-&gt;data); //根 QPreOrder(root-&gt;Lchild); //左 QPreOrder(root-&gt;Rchild); //右 &#125;&#125;//后序遍历------:顺序:左-&gt;右-&gt;根void HPreOrder(BiNode *root)&#123; if(root == NULL) return; else &#123; HPreOrder(root-&gt;Lchild); //左 HPreOrder(root-&gt;Rchild); //右 printf("%c ",root-&gt;data); //根 &#125;&#125;//中序遍历------顺序:左-&gt;根-&gt;右void ZPreOrder(BiNode *root)&#123; if(root == NULL) return; else &#123; ZPreOrder(root-&gt;Lchild); //左 printf("%c ",root-&gt;data); //根 ZPreOrder(root-&gt;Rchild); //右 &#125;&#125;//建树BiNode *CreatBiTree(BiNode *root)&#123; char chr; scanf("%c",&amp;chr); if(chr == '#') root = NULL;//遇到#说明孩子为NULL,返回上一结点 else&#123; root = (BiNode *)malloc(sizeof(BiNode)); root-&gt;data = chr; root-&gt;Lchild = CreatBiTree(root-&gt;Lchild); //从左至右建树 root-&gt;Rchild = CreatBiTree(root-&gt;Rchild); &#125; return root;&#125;//销毁树void DesTree(BiNode *root)&#123; if(root == NULL) return ; DesTree(root-&gt;Lchild); DesTree(root-&gt;Rchild); free(root); //从最右依次free至根节点 &#125;int main()&#123; BiNode *root = NULL; root = CreatBiTree(root); printf("前序遍历结果:\n"); QPreOrder(root); printf("\n"); printf("中序遍历结果:\n"); ZPreOrder(root); printf("\n"); printf("后序遍历结果:\n"); HPreOrder(root); printf("\n"); return 0;&#125;比如说,我要构造下图的二叉树 那么我们的输入应该是:ABDG##H###CE#I##F##解析: 从A-&gt;G:未遇见特殊字符’#’,依次建立左子树. G-&gt;H:G后读入特殊字符’#’,则G左孩子为空; 继续读入下一个字符; 依然是’#’,则G右孩子为空. 此时G左右孩子已输入,返回上一层D. 读入字符’H’写入D右孩子. 其他的以此类推即可 关于遍历: 依照上图前序遍历结果:A B D G H C E I F中序遍历结果:G D H B A E I C F后序遍历结果:G H D B I E F C A]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C循环链表操作模板]]></title>
    <url>%2F2019%2F04%2F21%2F63%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 100 typedef int DataType; //将数据类型定义为DataType,方便修改,这样如果需要改成char只需要改这里就行了typedef struct Node&#123; DataType data; struct Node *next;&#125;Node;Node *CreatList(DataType a[],int n)&#123; Node *first = (Node*)malloc(sizeof(Node)); first-&gt;next = NULL; Node *r = NULL,*p = NULL; r = first; for(int i = 0;i &lt; n;i++)&#123; p = (Node*)malloc(sizeof(Node)); p-&gt;data = a[i]; p-&gt;next = NULL; r-&gt;next = p; r = p; &#125; p-&gt;next = first-&gt;next; //链表末端指向链表头 //此处是单链表和循环链表的差别 return first;&#125; //删除第x位的元素void DeleteData(Node *first,int x)&#123; Node *p = first-&gt;next; Node *r; int cnt = 1; //cnt统计结点数 while(p-&gt;next != first-&gt;next &amp;&amp; cnt &lt; x -1)&#123; //判断是否遍历完成，当P为链表尾的时候，P-&gt;next应指向第一个元素,即first-next; p = p-&gt;next; &#125; //敲黑板划重点 //比如说链表中有数据 1 2 3 4 5 //要删除位置为3 （此时对应数据也是3） //则令P指向第2个位置时停下来（修改指针域使P(此时P指向2)-&gt;next==P-&gt;next-&gt;next (p-&gt;next-&gt;next指向4） r = p-&gt;next; p-&gt;next = r-&gt;next; free(r); //释放删除位的空间，防止内存泄漏 //如果要取得删除的数据 //则在函数声明中添加参数DataType *ptr //并将要删除的数据赋值给×ptr后再free&#125;//循环链表其他操作如果需要遍历，则类似此函数，设置一个标记flag即可//具体函数可参考我博客中的C单链表操作void PrintList(Node *first)&#123; int flag = 0;//设置标记，当链表遍历完成后停止 Node *p = first-&gt;next; while(p != first -&gt;next || !flag)&#123; printf("%d ",p-&gt;data); p = p-&gt;next; flag = 1; &#125;&#125;int main()&#123; Node* first = NULL; int n; int i,k = 2,x = 1; DataType Data[maxn]; scanf("%d",&amp;n); for(i = 0;i &lt; n;i++) scanf("%d",&amp;Data[i]); first = CreatList(Data,n); PrintList(first); DeleteData(first,k); printf("\nAfter Delete:\n"); PrintList(first); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环(C循环链表)]]></title>
    <url>%2F2019%2F04%2F21%2F61%2F</url>
    <content type="text"><![CDATA[约瑟夫环（约瑟夫问题）是一个数学的应用问题： 已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。 一个挺简单的循环的题，拿来初学者学链表时练手很适合 talk is cheap, show me the code 下面是代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 100 //最多100个人同时处于环中typedef int DataType;typedef struct Node&#123; DataType data; struct Node *next;&#125;Node;Node *CreatList(DataType a[],int n)&#123; Node *first = (Node*)malloc(sizeof(Node)); first-&gt;next = NULL; Node *r = NULL,*p = NULL; r = first; for(int i = 0;i &lt; n;i++)&#123; p = (Node*)malloc(sizeof(Node)); p-&gt;data = a[i]; p-&gt;next = NULL; r-&gt;next = p; r = p; &#125; p-&gt;next = first-&gt;next; // 建立循环链表 return first;&#125;void DeleteData(Node *first,int n,int x)&#123; Node *p = first-&gt;next; Node *r; int ptr; for(int i = 1;i &lt; n;i++) p = p-&gt;next; //确定第一个退出的人的位置 while(p-&gt;next != p)&#123; //一直循环到链表中只剩下一个人为止，则这个人就为最后存活的那一个 for( int i = 1;i &lt;= x - 1;i++)&#123; p = p-&gt;next; //循环找第X位淘汰的人 &#125; ptr = (p-&gt;next)-&gt;data; r = p-&gt;next; p-&gt;next = r-&gt;next; free(r); //淘汰出局 &#125; printf("%d",p-&gt;data); //荒野逃生，绝地吃鸡（逃）&#125;int main()&#123; Node* first = NULL; int n; int i,k,x = 1; k = 3; //每隔K个人便淘汰一个 DataType Data[maxn]; scanf("%d",&amp;n); for(i = 0;i &lt; n;i++)&#123; Data[i] = i + 1; &#125; first = CreatList(Data,n); //创建循环链表 DeleteData(first,n,k); //Game Begining，开始淘汰出局 return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C单链表操作模板]]></title>
    <url>%2F2019%2F04%2F21%2F58%2F</url>
    <content type="text"><![CDATA[函数顺序依次为单链表的创建（头插和尾插法），初始化，判空，遍历，求链表长度，按值查找，按位查找，插入，删除，销毁操作 并且在主函数中举例说了链表的创建，遍历，求长，删除，插入操作;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int DataType; //用DataType 替代 int方便修改数据类型typedef struct Node&#123; DataType data; //数据域 struct Node *next; //指针域&#125;Node;//建立单链表(尾插法）//比如说数据1 2 3 4 5//链表中从头指针开始数据顺序为1 2 3 4 5//每次从链表末尾插入Node *CreatTailList(DataType a[],int n)&#123; Node *s = NULL,*r = NULL; Node *first = (Node *)malloc( sizeof(Node)); r = first;//尾指针初始化 first -&gt; next = NULL; int i = 0; for(i;i &lt; n;i++)&#123; s = (Node*)malloc(sizeof(Node)); s -&gt; data = a[i]; r-&gt; next = s; r = s; //将结点S插入到终端结点之后 &#125; r -&gt; next = NULL; //终端结点指针指向NULL return first;&#125;//建立单链表（头插法）//比如说数据1 2 3 4 5//链表中从头指针开始数据顺序为5 4 3 2 1//每次从链表头部插入Node *CreatHeadList(DataType a[],int n)&#123; Node *s = NULL; Node *first = (Node*)malloc(sizeof(Node)); first -&gt; next= NULL; int i = 0; for(i;i &lt; n;i++)&#123; s = (Node*)malloc(sizeof(Node)); s -&gt; data = a[i]; s -&gt; next = first -&gt; next; first-&gt; next = s; &#125; return first;&#125;//链表初始化Node *InitList()&#123; Node *first = (Node *)malloc(sizeof(Node)); first-&gt;next = NULL; return first;&#125;//判断空是否为空链表int Empty(Node *first)&#123; if(first-&gt;next == NULL) return 1; return 0;&#125;//遍历void PrintList(Node*first)&#123; Node*p = first -&gt; next; while(p != NULL)&#123; printf("%d ",p-&gt;data); p = p-&gt;next; &#125;&#125;//求链表长度int Length(Node*first)&#123; Node *p = first-&gt;next; int cnt = 0; while(p != NULL)&#123; cnt++; p = p -&gt; next; &#125; return cnt;&#125;//按值查找，查找失败返回0,成功返回数据所在位置int Locale(Node *first,int x)&#123; Node *p = first-&gt;next; int cnt = 1; while(p != NULL)&#123; p = p -&gt; next; cnt ++; if( p -&gt; data == x) return cnt; &#125; return 0;&#125;//按位查找，失败返回0,成功返回指向第x个数据的指针ptrint Get(Node *first,int x,DataType *ptr)&#123; Node *p = first-&gt;next; int cnt = 1; while(p != NULL &amp;&amp; cnt &lt; x)&#123; p = p -&gt; next; cnt ++; &#125; if(p == NULL) return 0; *ptr = p-&gt;data; return 1;&#125;//插入int Insert(Node *first,int x,DataType t)&#123; //x 为插入位置，t为要插入的数据 Node *s = NULL,*p = first; int cnt = 0; while ( p != NULL &amp;&amp; cnt &lt; x - 1)&#123; p = p -&gt; next; cnt ++; &#125; if(p == NULL )&#123; return 0; // 插入位置错误返回0 &#125; s = (Node*)malloc(sizeof(Node));//请求分配空间 . s -&gt; data = t; //申请一个结点,数据域为x s -&gt; next = p -&gt; next; //将结点S插入到结点P之后 p -&gt; next = s; return 1;&#125;//删除某一位置的结点int Delete(Node *first,int i,DataType *ptr)&#123; //i为要删除的数据，ptr取得删除的值 Node *p = first,*q = NULL; int cnt = 0; DataType x; while(p != NULL &amp;&amp; cnt &lt; i - 1)&#123; p = p -&gt; next; cnt++; &#125; if(p == NULL || p-&gt; next == NULL)&#123; return 0; //删除失败 &#125; q = p -&gt; next; *ptr = q -&gt; data; //删除失败的值 p -&gt; next = q -&gt; next; free(q); return 1;&#125;//销毁void DestroyList(Node *first)&#123; Node *p = first; while (first != NULL)&#123; //依次释放储存空间 first = first -&gt; next; free(p); p = first; &#125;&#125;int main()&#123; Node *first; DataType data[] = &#123;1,2,3,4,5&#125;; int x,n; n = sizeof(data)/sizeof(data[0]);//求出数组data中元素个数 first = CreatTailList(data,n);//尾插 printf("After Creat,the data is: "); PrintList(first); printf("\n"); if(Delete(first,3,&amp;x))&#123; printf("After Delete,the data is: "); PrintList(first); printf(" Delete %d",x); printf("\n"); &#125; else printf("Delete Defult\n"); if(Insert(first,2,7))&#123; printf("After Insert,the data is: "); PrintList(first); printf("\n"); &#125; else printf("Insert Defult\n"); printf("the List Length is: %d",Length(first)); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c语言栈的实现以及操作]]></title>
    <url>%2F2019%2F04%2F21%2F56%2F</url>
    <content type="text"><![CDATA[此文章包含了栈的结构体实现,单数据类型实现,以及清空,判空,入栈,出栈,求栈顶元素的实现 栈是一个非常简单的数据结构 栈本身就相当于一摞盘子,每个数据就是一个盘子,每次你只能把盘子放在最上面或者拿走最上面的盘子 实现起来也非常容易,用数组来模拟这堆盘子 那么我们如果有一个索引TOP时刻指向最上面的那个盘子,栈不就实现了么? 第一段是单数据类型的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define maxn 110//栈的最大值typedef int elem; //方便修改数据类型typedef struct&#123; int top; ///栈顶的索引 elem index[maxn];&#125;Stack;Stack stack; ///为了方便这里直接定义全局变量了,用局部变量的话在每个函数加上取地址符和声明就行了void stack_pop()&#123; ///元素出栈,此函数无返回值 stack.top--;&#125;void stack_push(elem buf)&#123; ///元素入栈 stack.index[++stack.top] = buf;&#125;int stack_empty()&#123;///判空,如果栈为空的话返回1,否则返回0 return stack.top == -1;&#125;void stack_clear()&#123; ///清空栈 stack.top = -1;&#125;int stack_size()&#123; ///求栈内元素数 return stack.top+1;&#125;elem stack_top()&#123; ///返回栈顶元素 return stack.index[stack.top];&#125;int main()&#123; stack_clear();///初始化栈 elem buf; buf = 10; stack_push(buf); printf("%d\n",stack_top()); printf("%d\n",stack_empty()); printf("%d\n",stack_size()); stack_pop(); printf("%d\n",stack_size()); return 0;&#125;下面是结构体栈的实现,和上面的基本一样,只修改了部分代码,添加了一个可以糅合数据类型的结构体数组elem#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define maxn 11typedef struct &#123; int n; char str[maxn];&#125;elem; ///要存用栈储的数据类型typedef struct&#123; int top; ///栈顶的索引 elem index[maxn];&#125;Stack;Stack stack; ///为了方便这里直接定义全局变量了,用局部变量的话加上取地址符和声明就行了void stack_pop()&#123; ///元素出栈,此函数无返回值 stack.top--;&#125;void stack_push(elem buf)&#123; ///元素入栈 stack.index[++stack.top].n = buf.n; strcpy(stack.index[stack.top].str,buf.str);&#125;int stack_empty()&#123;///判空,如果栈为空的话返回1,否则返回0 return stack.top == -1;&#125;void stack_clear()&#123; ///清空栈 stack.top = -1;&#125;int stack_size()&#123; ///求栈内元素数 return stack.top+1;&#125;elem stack_top()&#123; ///返回栈顶元素 return stack.index[stack.top];&#125;int main()&#123; stack_clear(); elem buf; buf.n = 1; strcpy(buf.str,"abc"); stack_push(buf); printf("%d %s\n",stack_top().n,stack_top().str); printf("%d\n",stack_empty()); printf("%d\n",stack_size()); stack_pop(); printf("%d\n",stack_size()); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ACM修炼指南（bestsort个人版 -----持续更新ing）]]></title>
    <url>%2F2019%2F04%2F21%2F47%2F</url>
    <content type="text"><![CDATA[欢迎转载，注明出处即可部分分类可能有误，欢迎指正如果有什么遗漏的，欢迎联系博主，感激不尽其中，部分链接来自于我队友baiyi_destroyer,以及头头lxt_lucia的博客acm修炼指南. 点击进入网上通用版个人版模板下载链接声明下载链接可能不能及时更新，需要最新版请留言博主模板下载链接—————-入门—————-基本算法尺取法前缀和贪心活动安排问题筛选法素数打表同余定理快速幂GCDint gcd(int a,int b){return b?gcd(b,a%b):a;}扩展gcd查找二分查找三分查找哈希（散列表）枚举开关问题递归n皇后问题回溯法数据结构入门数据结构（自己动手实现）链表栈队列二叉树图图的基本概念拓扑排序并查集路径压缩动态规划入门简单递推斐波那契数列楼梯问题母牛问题平面分割问题简单dp数塔问题01背包最长公共子序列（LCS）最长上升子序列（LIS）其余预备知识codeblocks的使用时间复杂度的计算c++入门ubuntu使用qsort，sort，strcpy,strcmp等库函数的使用—————-基础—————-JAVA大数博弈巴什博弈威佐夫博弈尼姆博弈SG函数与SG定理树上删边游戏组合数学容斥原理各类组合数第一类斯特林数第二类斯特林数贝尔数卡特兰数那罗延数默慈金数康托展开康托逆展开母函数错位排序基姆拉尔森公式计算几何离散化凸包叉积点积pick定理三角形外新极角排序线段相交动态规划背包九讲数位dp概率dp状压dp区间dp树形dp数据结构线段树建树单点查询单点更新区间查询区间更新延迟标记并查集逆向并查集按秩合并路径压缩种类并查集树状数组lowbit操作区间查询单点更新单点查询区间更新区间查询区间更新区间求最值划分树RMQ问题图链式前向星拓扑排序最小生成树prim（适合稠密图）kruskal（适合稀疏图）朱刘算法（适合有向图）最短路floydDijkstra堆优化队列优化bellman-fordSPFADijkstra+堆优化第k短路（A*算法）分层最短路搜索bfs（广度优先搜索）dfs（深度优先搜索）网络流二分图匹配匈牙利算法二分图完备匹配增广路最小费用流树最近公共祖先（LCA）tarjan离线倍增欧拉序+RMQ树链剖分数论求逆元exgcd快速幂递推欧拉函数唯一分解定理中国剩余定理串最长回文子串manacher算法回文树模式匹配KMP扩展KMPTire树AC自动机数学斯特林公式高斯消元STLvectorqueuestringmapset迭代器进阶莫比乌斯反演波亚计数A*+可持续化可并堆KD树]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ACM修炼指南（网上通用版 -----已修改格式方便查看）]]></title>
    <url>%2F2019%2F04%2F21%2F43%2F</url>
    <content type="text"><![CDATA[目录点击进入bestsort修炼指南个人版数据结构栈，队列，链表,树哈希表，哈希数组堆，优先队列双端队列可并堆左偏堆二叉查找树Treap伸展树并查集集合计数问题二分图的识别平衡二叉树二叉排序树线段树一维线段树二维线段树树状数组一维树状数组N维树状数组字典树后缀数组，后缀树块状链表哈夫曼树桶，跳跃表Trie树(静态建树、动态建树)AC自动机LCA和RMQ问题KMP算法图论基本图算法图广度优先遍历深度优先遍历拓扑排序割边割点强连通分量Tarjan算法双连通分量强连通分支及其缩点图的割边和割点最小割模型、网络流规约2-SAT问题欧拉回路哈密顿回路最小生成树Prim算法Kruskal算法(稀疏图)Sollin算法次小生成树第k小生成树最优比例生成树最小树形图最小度限制生成树平面点的欧几里德最小生成树平面点的曼哈顿最小生成树最小平衡生成树最短路径有向无环图的最短路径-&gt;拓扑排序非负权值加权图的最短路径-&gt;Dijkstra算法(可使用二叉堆优化)含负权值加权图的最短路径-&gt;Bellmanford算法含负权值加权图的最短路径-&gt;Spfa算法(稠密带负权图中SPFA的效率并不如Bellman-Ford高)全源最短路弗洛伊德算法Floyd全源最短路Johnson算法次短路径第k短路径差分约束系统平面点对的最短路径(优化)双标准限制最短路径最大流增广路-&gt;Ford-Fulkerson算法预推流Dinic算法有上下界限制的最大流节点有限制的网络流无向图最小割-&gt;Stoer-Wagner算法有向图和无向图的边不交路径Ford-Fulkerson迭加算法含负费用的最小费用最大流匹配Hungary算法最小点覆盖最小路径覆盖最大独立集问题二分图最优完备匹配Kuhn-Munkras算法不带权二分匹配：匈牙利算法带权二分匹配：KM算法一般图的最大基数匹配一般图的赋权匹配问题拓扑排序弦图稳定婚姻问题广搜广搜的状态优化利用M进制数存储状态转化为串用hash表判重按位压缩存储状态双向广搜A*算法深搜深搜的优化位运算剪枝函数参数尽可能少层数不易过大双向搜索或者是轮换搜索IDA*算法记忆化搜索动态规划四边形不等式理论不完全状态记录青蛙过河问题利用区间dp背包类问题0-1背包，经典问题无限背包，经典问题判定性背包问题带附属关系的背包问题-1背包问题双背包求最优值构造三角形问题带上下界限制的背包问题(012背包)线性的动态规划问题积木游戏问题决斗（判定性问题）圆的最大多边形问题统计单词个数问题棋盘分割日程安排问题最小逼近问题(求出两数之比最接近某数/两数之和等于某数等等)方块消除游戏(某区间可以连续消去求最大效益)资源分配问题数字三角形问题漂亮的打印邮局问题与构造答案最高积木问题两段连续和最大2次幂和问题N个数的最大M段子段和交叉最大数问题判定性问题的dp(如判定整除、判定可达性等)模K问题的dp特殊的模K问题，求最大(最小)模K的数变换数问题单调性优化的动态规划1-SUM问题2-SUM问题序列划分问题(单调队列优化)剖分问题(多边形剖分/石子合并/圆的剖分/乘积最大)凸多边形的三角剖分问题乘积最大问题多边形游戏(多边形边上是操作符,顶点有权值)石子合并(N^3/N^2/NLogN各种优化)贪心的动态规划最优装载问题部分背包问题乘船问题贪心策略双机调度问题Johnson算法状态dp牛仔射击问题(博弈类)哈密顿路径的状态dp两支点天平平衡问题一个有向图的最接近二部图树形dp完美服务器问题(每个节点有3种状态)小胖守皇宫问题网络收费问题树中漫游问题树上的博弈树的最大独立集问题树的最大平衡值问题构造树的最小环数论中国剩余定理欧拉函数欧几里得定理欧几里德辗转相除法求GCD(最大公约数)扩展欧几里得大数分解与素数判定佩尔方程同余定理(大数求余)素数测试一千万以内：筛选法一千万以外：米勒测试法连分数逼近因式分解循环群生成元素数与整除问题进制位.同余模运算数学组合数学排列组合容斥原理递推关系和生成函数Polya计数法Polya计数公式Burnside定理N皇后构造解幻方的构造满足一定条件的hamilton圈的构造Catalan数Stirling数斐波拉契数调和数连分数MoBius反演偏序关系理论加法原理和乘法原理计算几何基本公式叉乘点乘常见形状的面积、周长、体积公式坐标离散化线段判断两线段（一直线、一线段）是否相交求两线段的交点多边形判定凸多边形,顶点按顺时针或逆时针给出,(不)允许相邻边共线判点在凸多边形内或多边形边上,顶点按顺时针或逆时针给出判点在凸多边形内,顶点按顺时针或逆时针给出,在多边形边上返回0判点在任意多边形内,顶点按顺时针或逆时针给出判线段在任意多边形内,顶点按顺时针或逆时针给出,与边界相交返回1多边形重心多边形切割(半平面交)扫描线算法多边形的内核三角形内心外心重心垂心费马点圆判直线和圆相交,包括相切判线段和圆相交,包括端点和相切判圆和圆相交,包括相切计算圆上到点p最近点,如p与圆心重合,返回p本身计算直线与圆的交点,保证直线与圆有交点计算线段与圆的交点可用这个函数后判点是否在线段上计算圆与圆的交点,保证圆与圆有交点,圆心不重合计算两圆的内外公切线计算线段到圆的切点点集最小圆覆盖可视图的建立对踵点经典问题平面凸包三维凸包Delaunay剖分/Voronoi图计算方法二分法二分法求解单调函数相关知识用矩阵加速的计算迭代法三分法解线性方程组LUP分解高斯消元解模线性方程组定积分计算多项式求根周期性方程线性规划快速傅立叶变换随机算法0/1分数规划三分法求解单峰(单谷)的极值迭代逼近矩阵法博弈论极大极小过程Nim博弈威佐夫博弈巴什博弈博弈树SG函数]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[建立自己的 BLOG（2）— ssh登陆并进行相关设置]]></title>
    <url>%2F2019%2F04%2F21%2F21%2F</url>
    <content type="text"><![CDATA[请查看以下列表并按顺序完成[ ] 租用一台服务器(VPS)[x] ssh登陆并进行相关设置[ ] 搭建 LAMP / LNMP 环境[ ] 搭建WordPressssh登陆软件windows环境下，一般采用PuTTy或者Xshell登陆 Liunx下，我一般习惯用终端命令行登陆 Android下，推荐使用JuiceSSH IOS下推荐使用 一般Liunx 在终端用ssh root@你的IP地址,软件在SSH -&gt; IP地址栏中输入自己的ip，端口默认22并正确输入账号密码就可以登陆了。 需要注意的是Liunx输入密码的时候光标并不会闪烁，并不是系统卡死了 。输完密码后按回车即可。 这里因为我的windows10内置了OpenSSH工具，这里就直接用命令行连了 这里可以看到用户已经变成了root@vultr，表示我们已经连接到服务器了添加新用户并修改权限拿到一台服务器的最重要的事情就是禁用root用户远程登陆，因为网上会有一些对服务器root密码进行暴力破解的，如果不禁用root登陆的话一天可能会被攻击很多次。要知道root用户密码落在别人手里是一件非常危险的事情。所以这里我们进行配置ssh 先输入adduser newname，创建新用户，这里的newname替换成自己能记住的名字就行，我这里就用newname代替了。然后修改新用户密码：passwd newname,重复输入2次密码即可 输入cd /home,回车，输入ls，回车即可看到自己刚刚创建的用户文件夹。创建好用户后我们去修改newname的用户权限vim /etc/sudoers.这里可能会提示command not found，用包管理工具安装vim就好了:yum install vim -y(CentOS)或者apt-get install vim(Ubuntu)。 如上图，跳转到101行左右，在root ALL=（ALL） ALL下按i进入编辑模式并添加一行 newname ALL=(ALL) ALL，然后esc，输入:w！强制保存并按esc输入:q退出验证是否成功修改权限：输入su newname切换到newname用户，再输入sudo su，如果能如下这样来回切换即为成功注意最前面用户名的变化，从此以后我们就可以用ssh newname@ip登陆服务器了。在任何命令前加上sudo并输入newname的密码后即可以root权限执行此命令禁止root用户SSH登陆输入vim /etc/ssh/sshd_config进入ssh服务端配置，将PermitRootLogin前的#去掉（如果有的话）并把yes改为no，esc然后:wq保存并退出。输入systemctl restart sshd.service重启sshd服务即可.退出再用root登陆一次，显示Permission denied即表示Root账户远程登陆已禁用到此为止服务器已经配置好了，接下来就是搭建LNMP / LAMP环境了]]></content>
      <categories>
        <category>VPS玩机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[建立自己的BLOG（1）---租用一台服务器]]></title>
    <url>%2F2019%2F04%2F21%2F18%2F</url>
    <content type="text"><![CDATA[请查看以下列表并按顺序完成[x] 租用一台服务器(VPS)[ ] ssh登陆并进行相关设置[ ] 搭建 LAMP / LNMP 环境[ ] 搭建WordPress起因前不久，终于受不了CSDN的广告轰炸了，但是博客园的后台编辑器界面又实在实在太老旧了，正好手上有服务器，就想借助wordpress自己搭建一个BLOG服务器优劣一般来讲海外服务器厂商带宽高，最低配一般都是母机共用1G带宽，但是延迟高，每月有流量限制，并且高带宽可以有很多其他用途 国内厂商延迟低，带宽低，服务便捷 就我的两台VPS（Vultr和阿里云各一台）比较来讲：类型Vultr阿里云月付5$10￥(学生机)CPU一核一核内存1G1G带宽1G共享带宽1M其他特点按小时扣费仅学生Ping测试（5次平均）210+ms50+ms其中，我的Vultr服务器位于洛杉矶，阿里云位于华东2动手租用服务器服务器租用有很多选择，海外一般就推荐Vultr和Banwagong(俗称搬瓦工)，这两家都是口碑很不错的服务商，且都支持支付宝支付。国内推荐阿里云和腾讯云，这两者都有学生优惠，且很容易认证。Vultr：充值可以此链接注册并获得 充值10刀送50刀 的优惠。当然我也会因为您的充值而获利。 注册好后,单击左边的Billing进行充值，支持支付宝(Aplay) 和 微信(WeChat Pay) ，充值完毕后点击Billing 界面的 History,就能看到自己的账户余额了选择服务器单击左边的Servers，并点击右上角的+号进入服务器租用界面 能看到这里默认的是东京，月付10刀的服务器。这里我们一般选择Los Angeles和New York 的服务器，Vultr是一家美国服务商，所以选本地的VPS质量会好很多，不要选新加坡和东京的，因为这两个地方的线路是走美国绕道回中国，绕了世界大半圈！！！然后BLOG的话选择5$/月的就可以了 如果我们要省事的话，在第二步Server Type点击Application，里面有wordpress的一键安装镜像（（强烈推荐使用）），当然还有其它很常用的镜像比如GitLab,NextCloud等等，可以根据自己喜好选择。这里如果是选择的WordPress的话，付款后 直接在浏览器 中输入服务器IP即可进入WordPress设置页面，并忽略掉上面的第三步和第四步。 毕竟是手把手教程嘛，这里我选择不用一键镜像，只安装默认（CentOS7 64位）的镜像 选择完后单击Deploy Now,进入服务器管理页面，这里已经可以看到一台服务器正在安装了 我们点进去就能查看到这台服务器的IP地址和密码 到这里Vultr服务器租用已经完成了，可以进入下一步ssh登陆并进行相关设置了注意事项Vultr 的服务器是按小时扣费的，如果不用的话需要销毁服务器，停止运行是照常扣费的。 如果想更换服务器只需要销毁当前服务器然后再开一台就行了，花费0.01$阿里云：点此进入阿里云学生机租用页面，阿里云我们一般都会使用学生优惠，这里并不是指学生才能购买学生机，阿里云2018云翼计划规定24岁以下自动获得学生身份。到现在（2019年4月17日）依然有效。 点此进入云翼计划 进行购买后，点击右上角控制台，进入云服务器ECS即可看到自己的服务器了注意事项云翼计划的机器配置带宽较低，推荐购买的时候选择轻型应用服务器（5M 带宽每月流量限额 1000G），配合 CDN 和 OSS 够用很久了。云翼计划的机器可以续费，但是只能续费2次]]></content>
      <categories>
        <category>VPS玩机</category>
      </categories>
  </entry>
</search>
